{"pages":[{"title":"","text":"你不該與任何特定的技術白頭到老，應該尋求廣泛而足夠的基礎知識與經驗，讓你能夠在任何特殊的狀況挑選合適的解決方案。 - &lt;&lt; Pragmatic Programmer &gt;&gt; 這是我從一本很喜歡的書上 &lt;&lt;學徒模式-優秀軟體開發者的養成之路&gt;&gt; 看到的一段話，我把它視為軟體技術學習之路上的宗旨。 你好，我是 Mujing，\b\b 現為以網站軟體開發維生的專業工作者 \b、喜愛程式語言 JavaScript 的靈活與 Ruby 的整潔、樂於根據需求嘗試不同的解決方法，不論你有技術相關問題還是其他話題想聊聊，都歡迎一起交流。 Facebook moojitsai@gmail.com 工作經歷 Frontend Engineer - Snapask 知之有限公司 (2020 - now) 負責官網功能重構，並與設計師搭配一同優化網站使用者體驗 根據需求規劃及實作內部文章排程管理後台介面 改善現有專案架構及優化部署流程 Frontend Engineer - 承啟科技股份有限公司 (2019 - 2020) 開發 AI Training 系統前端介面。(使用 React.js) 優化開發流程：將 Git Flow 導入專案流程 優化部署流程：導入 CI / CD 流程 (使用 DroneCI) 確保產品穩定性：使用 Cypress 進行 E2E 測試 Frontend Engineer - 辰峰企業管理顧問有限公司 (2018 - 2019) 負責機票後台訂單系統的前端介面開發 考量產品開發時程，選用 Vue.js 進行開發 與後端工程師共同進行後端 API Schema 規劃 負責前端專案部署 （使用 Linux Command Line) Backend Engineer - 可思科技 (2017 - 2018) 使用 CMS 系統開發網站功能及插件，並維護 Mysql 資料庫 為公司租借虛擬主機，並搭配 Apache Server 架設網站 使用 Linux Command Line 進行專案部署，並負責網域購買以及 SSL 憑證簽發 使用 JQuery 開發基礎網站前端互動功能 使用 GeoIP 過濾特定國家之 IP ，做到流量管控。 其他連結 詳細經歷請參考 CakeResume。","link":"/about/index.html"}],"posts":[{"title":"Vue.js小遊戲實作-60秒算數挑戰","text":"大家好，我在六角地下城6f，這樓的挑戰是實作小遊戲，題目的邏輯是在六十秒內會產生隨機兩個數字去隨機做加減乘除， 答對就加一分，答錯就扣一分，秒數越少，題目越困難，得分就越高分。 題目詳細規則如下： 0~20 秒為 1位數計算 (ex. 5-3) 21~40 秒為 2 位數計算 (ex. 30*19) 41~60 秒為 3 位數計算 (ex. 332+312) 加減乘除規則請用隨機產生，不可寫死題目，60 秒內可無限次數答題。 0~40 秒答對加一分 41~60 秒答對加五分 答錯扣一分，最多僅能扣到零分 我打算在這個專案做邏輯梳理的練習，因此會盡量把有機會重複使用的部分拆成methods，這個專案只會講述核心部分的邏輯，也就是如何產生題目，以及一些可能的問題點，其他細節部分希望你自己做做看，你可以在這裡看到我實做的成果。或是也可以直接參考原始碼。 規則流程－運算： 產生隨機兩個數字 產生運算符號（加減乘除） 等待使用者輸入 檢查正確答案與使用者輸入是否符合 產生下一道題目 規則流程－時間： 挑戰者按下開始後，切換頁面並開始倒數 倒數60秒 檢查現在秒數，根據不同秒數決定不同難度的題目及得分 60秒倒數完畢後，切換顯示頁面，不讓挑戰者繼續輸入 挑戰者查看得分，等待按下「再次挑戰」後重新此流程 需特別注意的規則細節： 因為數字是隨機產生，因此在某些情況下要注意，否則會有負數產生： 減法時，會有前後數字大小的問題 除法時，會有數字大小以及除不盡的問題 最後挑戰者重新開始時記得clearInterval 專案實作 - 基本配置 這個專案我是使用vue-cli，因為規模並不是很大，也不能跳頁，因此不打算另外切出Component。 資料結構的部分，因為會有重置資料的需求，我把原本習慣寫在data()裡面的資料拉出來，放在獨立的function回傳，這樣我就可以輕易的拿到預設的資料。 // outside Vue instance function initData(){ return { pages:['start','game','result'], operatorList:['+','-','x','÷'], operator:'+', currentPage:'start', score: '000', time_remain:60, currentTime:'00:00', quizNumbers:[], } } // inside Vue instance export default { name: 'app', data(){ return initData() } } 已知狀態有三種，因此我直接根據不同狀態去顯示不同頁面，這邊寫法可以依照自己習慣去更改： &lt;div :class=&quot;pages[0]&quot; v-if=&quot;currentPage==pages[0]&quot; &gt; ... &lt;/div&gt; &lt;div :class=&quot;pages[1]&quot; v-if=&quot;currentPage==pages[1]&quot; &gt; ... &lt;/div&gt; &lt;div :class=&quot;pages[2]&quot; v-if=&quot;currentPage==pages[2]&quot; &gt; ... &lt;/div&gt; 專案實作 - 邏輯實現 倒數方法 - 使用setTimeInterval 要能夠時線倒數，代表必須每隔一秒改變畫面上的時間值，這裡用setTimeInterval最適合不過了，他會每隔一段時間去執行寫入的方法： methods:{ ... timeReducer(){ let timer = setInterval(()=&gt;{ if( this.time_remain&gt;0){ this.currentTime = this.convertSeconds(this.time_remain -=1 ) }else{ clearInterval(timer) this.currentPage= this.pages[2] } }, 1000) return timer }, ... } 但在使用完後記得要清除這個interval，因為他會一直執行，如果沒有清除，在挑戰者再次開始遊戲時，如果沒有清楚，就會有兩個interval重疊，遊戲就無法順利進行，這邊我是在倒數完之後在setTimeInterval裡面直接使用clearInterval清除。 隨機產生運算子 因為加減乘除運算子必須隨機產生，所以我將這四種運算方式寫在陣列裡面(operatorList)，然後用JS的random方法去隨機挑選這個陣列的元素： methods:{ ... randomOperator(){ let order = Math.floor(Math.random()*100) % 4 this.operator = this.operatorList[order] } ... } 取得不同位數的數字 依照上面整理的規則，我們第一個會需要處理的部份是隨機產生數字，JS裡面可以用Math.random() 去解決，但要注意這個方法回傳的值是介於0~1之間的浮點數，後面要自己去調整才能拿到自己想要的格式。 以及要考量到可能會有需要拿不同位數數字的需求，所以在這個method我用digits當作參數來表示欲取得的位數： // inside Vue instance ...methods:{ ... getDigits(digits){ switch(digits){ case 1 : return Math.floor((Math.random() * 10) + 1) ; case 2 : return Math.floor((Math.random() * 100) + 10) ; case 3 : return Math.floor((Math.random() * 100) + 100) ; } }, } 取得數字之後的處理 加上setQuizNumber方法，根據不同時間取得不同位數的數字： //setQuizNumber let digit; switch (true){ case (this.time_remain&gt;=40 &amp;&amp; this.time_remain&lt;=60): { digit = 1 break; } case (this.time_remain&gt;=20 &amp;&amp; this.time_remain&lt;=40): { digit = 2 break; } case (this.time_remain&gt;=0 &amp;&amp; this.time_remain&lt;=20): { digit = 3 break; } } let result = [] let firstNum=this.getDigits(digit); let secondNum=this.getDigits(digit); 我們不想要答案有負數或小數點產生，所以在減法時，必須注意第一個數字是否大於第二個，至於加法跟乘法就沒有這個問題，所以我加上判斷，如果第一個數大於第二個，就做swap交換： //setQuizNumber if(firstNum &lt; secondNum){ let temp = firstNum firstNum = secondNum secondNum = temp } 最後為了在除法時，讓兩數是可以整除的，所以必須確保第二個數字是第一個數字的因數，以及不能有質數出現，我加入的判斷質數的方法isPrime跟取得數字所有因數的方法getFactors，以及後面會有從因數裡面雖機挑選一個數字的需求，所已加入陣列隨機挑選元素的方法getArrayRandomItem： methods:{ ... isPrime(num) { for(var i = 2; i &lt; num; i++) if(num % i === 0) return false; return num &gt; 1; }, getFactors(number,digits){ let factors = Array .from(Array(number + 1), (_, i) =&gt; i) .filter(i =&gt; number % i === 0) if(digits){ factors = factors.filter(factor=&gt;(factor+'').length===digits) } return factors }, getArrayRandomItem(array){ return array[Math.floor(Math.random()*array.length)]; }, ... } 最後過濾掉質數後，從第一個數字的因數（陣列）裡面去隨機選出一個數當作第二個數字，就可以送出了： //setQuizNumber if(this.operator=='÷' &amp;&amp; ( firstNum % secondNum!==0)){ while(this.isPrime(firstNum)) firstNum = this.getDigits(digit); while(this.isPrime(secondNum)) secondNum = this.getDigits(digit); secondNum = this.getArrayRandomItem(this.getFactors(firstNum,digit)) } result = result.concat([firstNum,secondNum]) this.quizNumbers = result 做到這裡產生題目的邏輯就完成了。 再次挑戰－ 重置所有資料 還記得我一開始把原始狀態拉出來單獨放在function裡嗎？現在就可以拿來用了，使用Object.assign，可以直接對目標物件赴值，如果屬性重複，以參數越後面屬性的值為主（後面寫入的會蓋掉前面的），可以參考 官方文件，順帶一提Object.assign不支援深度拷貝，如果你要複製的物件裡面還要物件，要特別注意，他只會複製那個物件的參考，後面你只要改動到該子物件，則所有該物件的參考都會跟著一起被改變。（參考官方文件） methods:{ ... onResetClick(){ Object.assign(this.$data, initData()); this.currentPage = this.pages[0] }, ... } this.$data是Vue裡面提供取得data物件的api，詳細可參考官方文件。 到這邊所有核心的邏輯都講完了，再提一次我並沒有從頭到尾講得很詳細，希望你試著自己去理清楚來龍去脈，自己識做看看，若還是看不懂也沒關係，可以參考我的原始碼，在自己做做看，有任何問題可以一起討論，感謝你的收看，下次見啦。","link":"/2019/02/18/60s-challenge/"},{"title":"Vue.js 井字遊戲 - OOXX","text":"大家好，我在地下城8樓，題目是3x3井字遊戲，直覺想到最簡單的方式就是暴力檢查，每個Row跟Column去檢查有沒有相等的，最後加上對角線兩條。也看到別樓有分享Alex1&amp;10解法，覺得很高明。 不過我想看看有沒有不一樣的做法，相信一定有。剛剛講到Row跟Column，就讓我想到二維陣列。沒錯，整個井字窗格根本可以用座標來看，今天這個題目的解法會以二維陣列為主軸來解說作法，切版的部分則比較繁瑣且不難所以不會多提，有問題可以再跟我討論。 你可以在這裡看到我的成果，或是參考原始碼。 規則 先手為 Ｏ，後手為 X，某方獲勝時，上方會紀錄各方的獲勝戰績 每回合結束後，會判定結果頁(平手、Ｏ獲勝、X獲勝) 需符合 RWD，能在低螢幕解析度也能遊玩，介面不能超出 x 軸，至少在以下解析度能夠遊玩: iPhone SE 320px iPhone 8 375px iPhone PLUS 414px 請使用瀏覽器離線儲存技術，將戰績保留起來 資料結構 為了讓對應到畫面的資料可以更直觀的操作跟查詢，我是這樣訂定格式的： data(){ return { ... currentPlayer:0, gameStatus:[[null,null,null], [null,null,null], [null,null,null]] }} 陣列第0個元素代表的是第一個Row，Row本身也是陣列，剛好由左到右對應到0、1、2的位置，(0,0)對應到最左上，(2,2)對應到最右下，這樣直觀多了，如下圖所示： 然後用0表示O、1表示X，與上述資料結構的currentPlayer一樣，null則表示尚未下棋的位置，不過這邊不建議用0來做任何的判斷，原因稍後再提。 判斷勝利者 因為我用的資料表示是： O為0，X為1，因此如果整列、整行或交叉相加都是0，或是3，代表有人勝出，這時我只要取得currentPlayer就知道獲勝的是誰了。 判斷勝利邏輯 要判斷目前賽況是否有人勝出，我們需要檢查的部分有: 每個Row（橫排）是否有連線 每個Column（直行）是否有連線 對角線是否有連線 判斷對角線的部分比較麻煩，但你應該可以看出，使用陣列的方式可以清楚區分出Row跟Column，讓檢查更方便，檢查的時間點是每次使用者點完要下的棋格之後的瞬間，檢查完最後切換使用者(玩家)。 methods:{ ... onSectionClick(x,y){ if (this.gameStatus[y][x]!==null) return //防止重複下棋 this.gameStatus[y][x] = this.currentPlayer//下棋 this.checkResult()//檢查賽況 this.togglePlayer()//&lt;---下完後切換使用者 },} 因為是二維陣列所以要兩層for迴圈，注意這邊因為要先取用Row，所以陣列的操作必須先從y (也就是直排) 開始選取，而不是一般座標的表示方式(x,y)，當然可以透過改變資料結構做出比較直觀的使用方式，不過因為沒有很困難，且為了解說方便，這邊就不做調整。 let status = this.gameStatus for(let y=0; y&lt;status.length; y++){ for(let x=0; x&lt;status[y].length; x++ ){ // 用status[y][x]取得棋格元素 &lt;-----重要 } } 知道取得陣列的方式之後就可以開始逐行逐列檢查啦！ 檢查Row / Column是否有連線 想要取得Row整行的和，每次的y必須固定，我是在x為0的時候，取得後面兩個x+1、x+2元素，相加後算出總和，。 methods:{ ... getSumOfRow(x,y){ let status = this.gameStatus if(x!==0 ) return return status[y][x]+ status[y][x+1]+ status[y][x+2] },} Coloum總和則為x y與上述相反： getSumOfColumn(x,y){ let status = this.gameStatus if(y!==0 ) return return status[y][x]+ status[y+1][x]+ status[y+2][x] }, 取得總合後判斷是否有0或是3就知道有無勝出。 檢查對角線是否有連線 一樣是在迴圈一開始x為0以及ｙ為0的時候做判斷，在取得總和之前，我先看看是不是整個對角線都已經被下過棋了，如果沒有，則直接return 跳出不做任何動作。 methods:{ getSumOfNegativeSlash(x,y){ let status = this.gameStatus if(x!==0 || y!==0 ) return if( !(this.isNumber(status[y][x]) &amp;&amp; this.isNumber(status[y+1][x+1]) &amp;&amp; this.isNumber(status[y+2][x+2]))) return return status[y][x]+ status[y+1][x+1]+status[y+2][x+2] }, } 另一個方向的對角線是同樣的做法，看到這裡的你應該可以推算出邏輯，如果還是不懂，可以參考文章開頭處的專案原始碼。 整合所有的判斷邏輯 - checkResult method 最後整個判斷邏輯如下，我把三種情況（Row / Column / 對腳線）個別寫下條件之後用OR串起來，只要狀況符合其中一種條件，就會結束賽局。 checkResult(){ let status = this.gameStatus for(let y=0; y&lt;status.length; y++){ for(let x=0; x&lt;status[y].length; x++ ){ let sumOfCol = this.getSumOfColumn(x,y) let sumOfRow = this.getSumOfRow(x,y) if( ( this.isRowAllNumber(x,y) &amp;&amp; sumOfRow=== 0||sumOfRow=== 3 )||( this.isColumnAllNumber(x,y) &amp;&amp; sumOfCol === 0||sumOfCol === 3 )||( this.getSumOfNegativeSlash(x,y)===0 || this.getSumOfNegativeSlash(x,y)===3 || this.getSumOfPositiveSlash(x,y)===0 || this.getSumOfPositiveSlash(x,y)===3 )){ this.setScore() this.goResultPage(this.currentPlayer) } } } this.checkIfFinish() }, 這邊有一個蠻麻煩的雷點就是js裡面null+0居然還是0，害我沒辦法直接正確判斷結果，導致我還寫了一個isRowAllNumber來判斷該列/欄是否全是數字，所以不推薦用0跟null搭配來當做相加的判斷。（你可以打開開發者工具試試看） 使用localStorage紀錄分數 這邊我使用localStorage來永久儲存比數，localStorage操作方式有以下幾種： localStorage.setItem(‘key’,‘content’) localStorage.getItem(‘key’) localStorage.removeItem(‘key’) 瀏覽器上有另外一個操作方式很類似的api叫做sessionStorage，差別就在於localStorage除非主動刪除，否則會永久保留在瀏覽器、sessionStorage則是在分頁關閉後就會被刪除。 我把上面三個api另外包成三個function，讓我在各個元件可以方便使用，統一使用方式，以下是setItem的包裝： export const setStorage = (name, content) =&gt; { if (!name) return; if (typeof content !== &quot;string&quot;) { content = JSON.stringify(content); } window.localStorage.setItem(name, content); }; getStorage、removeStorage則是類似的方式，在此就不多提。 多思考一些 - 重置分數按鈕 這邊思考的是，既然可以儲存戰績，那如果可以讓玩家手動清除分數，應該會更好用，很多遊戲也有這種功能。所以我將原本入口的START按鈕改為CONTINUE跟RESTART，如果兩邊分數為0才只顯示START。 雖然是小地方但可以增加樂趣，算是一點小優化，給有興趣的人參考。","link":"/2019/03/09/8f-ooxx/"},{"title":"瀏覽器的時光機—歷史堆疊、 pushState 與 replaceState API","text":"或許 pushState 與 replaceState 這兩個詞你可能沒聽過，但是瀏覽器「上一頁、下一頁」功能你一定不陌生，其實這兩個 API 是瀏覽器提供給開發者操作瀏覽紀錄用的，透過這兩個 API 並搭配事件處理，我們就可以將瀏覽器預設的「上一頁下一頁」修改成我們想要的客製化結果。 使用情境說明 pushState / replaceState 與點擊新連結有什麼不一樣 pushState / replaceState 與 Stack 結構 pushState / replaceState 使用方式 onpopstate 事件 一個栗子 使用情境說明 最近接到了必須修改瀏覽器歷史紀錄行為的需求，所以順便寫了篇文章整理下來。 在公司負責的產品是類似 AWS 那樣資源控制的後台介面，前端部分雖然使用了 React 作為主要工具，但架構上有點像是由 Webpack 打包出靜態檔， 之後交由後端 Server 來處理前端內容，所以無法直接將路由控制交給 React 作使用。 什麼意思？一般 SPA 原理是由 JS 產生動態內容並即時掛到 DOM 上，但這個產品流程上是這樣： 在開發階段由 Webpack 將源碼打包成瀏覽器看得懂的程式碼，一個工具模組對應一個頁面 在產品運行階段由 Node Server 來處理剛剛 Webpack 打包好的靜態檔案 因此除非在後端做更詳細的路由修改，否則無法作更複雜的路由變化（ex.巢狀路由） 而在這種情況下如果某一工具模組需要以多個頁面來進行資料的設定流程，就沒辦法像一般我們所習慣的使用框架的 Router 函式庫 — React-Router 或是 Vue-Router 讓路由與頁面動態地做搭配，因此 pushState 及 replaceState 這兩個 API 就特別適合這個時候拿出來使用。 （可能還是可以，只是在當時沒有太多時間做調查的情況下，我當下所做的決定就是使用這兩個 API 來解決） 首先讓我們先來了解 pushState 與 replaceState 在做什麼事情。 pushState / replaceState 與點擊連結有什麼不一樣 兩種方式都會改變瀏覽器網址列的內容，但 pushState 與 replaceState 差別在於**會不會發送新的 Http Request，**這點應該不難發現，一般我們點擊新連結時，因為會發送 Request ，對後端重新要求一份的 HTML 內容，因此這個時候會看到瀏覽器重新刷新了頁面。 相對的 pushState 與 replaceState 這兩個 API 則單純只會修改網址列的內容，而不會刷新頁面，只是如果使用者在網址列按下 Enter 或重新整理的話，就一樣會發出 Request 。這與單純點擊的效果相同。 瀏覽器記錄與 Stack 結構 關於今天提到的兩個 API，如果查詢 JS 的 MDN 文件的話，關於 pushState 會得到以下的說明： In an HTML document, the history.pushState() method adds a state to the browser's session history stack. 而 replaceState 則是 : The replaceState() method modifies the current history entry, replacing it with the state objects, title, and URL passed in the method parameters. 讀完這兩段雖然可能沒辦法馬上弄清楚說明的意思，但從內容我們可以看到一個蠻重要的部分：「 history stack.」這是否說明瀏覽器記錄與資料結構裡的堆疊 ( Stack ) 有關？沒錯，瀏覽器裡的歷史紀錄就是以堆疊的形式儲存下來供使用者作使用，首先讓我們來看看堆疊是什麼，可以看看以下的模型圖。 我們可以使用 push 與 pop 兩種方法分別對堆疊結構加入一筆新的資料或是取出最後一筆資料，因此，關於堆疊有一個很常見的描述就是「先進後出」。其他前端常用到的資料結構可以參考我之前鐵人賽的文章。 所以堆疊套用在歷史紀錄上是怎麼回事呢？每當我們從同一個頁面點擊網址轉到新的頁面時，就是在對歷史紀錄的堆疊使用 push 方法新增一筆新的瀏覽紀錄 ，而當我們執行上一頁往前瀏覽時，就像是在使用 pop 方法取出最後一筆瀏覽紀錄（網頁位置）。 pushState / replaceState 使用方法 history.pushState(state, title, url); 現在讓我們回到這兩個 API 上 ， pushState 與 replaceState 都接受三個參數，分別是： state：每個 history stack 都會可以給一個 state 物件。 title : 更新後頁面的 title 標籤內容設定，不過根據官方文件說明，目前為止大部分瀏覽器都會忽略他，因此最安全的方法是傳入空字串，不做任何修改。 url : 執行該方法後想要更新的想要更新的 url 但是這兩個長得這麼像的方法在使用上有什麼不ㄧ樣呢？首先，前面提到這兩個 API 都只會更改網址列內容而不會發出新的 Request (刷新頁面），而它們在使用上其實也差不多，差別在改變歷史紀錄堆疊的方式而已。 pushState 在被呼叫之後會真的對瀏覽歷史紀錄堆疊新增一筆紀錄，所以如果用 console.log 把 history.length （歷史紀錄堆疊的長度）印出來看的話會發現長度多了 1 。 而 replaceState 在呼叫後雖然ㄧ樣會改變網址列內容，但 history.length 的值卻不會有任何改變，這是因為如果用堆疊的方式來看歷史紀錄的話， replaceState 只會修改堆疊的最後一筆紀錄內容，也就是目前的網址列內容。 onpopstate 事件 在瀏覽器上一頁按鈕被執行時，堆疊的最上層，也就是最後一筆瀏覽紀錄會被取( pop ) 出，新的一筆紀錄網址會被更改到網址列內，而這時會觸發瀏覽器的內建事件 — popstate 事件。所以如果有些客製化功能想要搭配上一頁按鈕執行，就可以使用這個事件。使用： window.onpopstate = (event)=&gt;{ //事件函式內容 } 就可以寫入自訂的事件內容。 一個栗子 說了這麼多，來舉個實際的例子看看運作方式如何吧，現在我有三個按鈕，每個按鈕點擊後各自會呼叫有不同參數的 pushState 方法，而這時因為是第一次進入頁面，所以 history.length 是 1 。 所以如果我依序點擊 first 、second 、 third 按鈕之後，應該會在瀏覽器歷史裡新增三筆紀錄堆疊。 可以從上圖看到目前的網址內容變成 third.html ，但頁面仍然是原本的內容，沒有刷新，而瀏覽紀錄堆疊長度也真的變成 4 。這時的堆疊裡應該分別是： first.html -&gt; first.html -&gt; second.html -&gt; third.html 堆疊裡的最後一筆紀錄是 third.html ，所以現在如果點擊上ㄧ頁按鈕，理論上會回到 second.html 堆疊。 透過上圖可以看出確實如此，而且搭配 onpopstate 事件把 event 物件印出來可以看到在 pushState 時傳入的 state 物件的內容 也會隨著被 pop出來。還有一個可以注意的地方是我們在做以上這些操作時，都沒有任何頁面刷新的情況發生，但確實改變了瀏覽紀錄堆疊。 總結 上面總共提到了 pushState、replaceState 及 onpopstate 事件，也提到歷史紀錄堆疊的存放方式，還有pushState、replaceState 與一般點擊連結的差異，只要好好活用這些 API 方法的特性，就可以達成 主流框架 Router 如 React-Router 或 Vue-Router 那樣不發 Request 就能頁面的效果（其實推測一下的話這些 Router 函式庫裡面應該也是使用這些方法）。 那麼就寫到這邊，最近剛好有這樣的需求需要比較特別的解決方法，剛好看了一下以前沒有深究的部分，覺得蠻有趣的，就順便記錄跟整理下來，下次有不錯的東西再寫下來跟大家分享囉！","link":"/2020/02/04/browser-history-state-api/"},{"title":"Vue.js 實作 Canvas 畫板","text":"大家好，我在地下城七樓。在網頁互動上，Canvas的表現速度比起傳統用DOM元素操作的方式快上許多，因此常有某些互動的需求會採用Canvas來達成，這個專案會從基礎開始解說我如何實作Canvas畫板。 你可以在這裡看到我的實作成果，或是在此參考我的程式碼。 這個專案會盡量練習以我的角度寫出好讀的程式碼，什麼是好讀的程式碼？總該有個客觀定義，但以我目前所學來看，通常是有一定經驗的人，看夠別人寫的程式法，才能漸漸分辨好壞。不過俗話說取悅別人之前要先取悅自己，我想在這點上可以列一個最低限度的階段目標，就是先寫出讓自己好讀的程式碼。 畢竟如果自己都看得很吃力，那我想也絕對稱不上好讀。 P.S. 網路上應該可以找到不少討論這一點的文章。 Outline Canvas - 指定渲染環境 封裝畫線方法 鉛筆工具 橡皮擦工具 Canvas轉成圖片 空心矩形 復原與重做 多思考一些 - 使用者體驗 指定渲染環境 Canvas 會產生一個固定範圍的畫布，但開始繪製圖型之前， 由於canvas可以有很多種渲染環境，我們必須使用getContext()方法來指定想要的渲染方式，這邊畫布使用的是2d環境。 &lt;canvas ref=&quot;sketchpad&quot;&gt;&lt;/canvas&gt; methods:{ ... setCanvas(){ let canvas = this.$refs['sketchpad'] canvas.width = window.innerWidth canvas.height = window.innerHeight - 60 let ctx = canvas.getContext('2d') ctx.lineCap = &quot;round&quot; ctx.lineJoin = &quot;round&quot; this.canvasContext = ctx }, } 封裝畫線方法 基礎 canvas畫線之前要先呼叫beginPath方法告知開始畫線，最後用stroke()畫出邊線或是用fill()填滿，一個畫線的簡單例子： ctx.beginPath(); // Start a new path ctx.moveTo(30, 50); // Move the pen to (30, 50) ctx.lineTo(150, 100); // Draw a line to (150, 100) ctx.stroke(); // Render the path 這段程式是在告訴canvas從座標(30,50)開始畫線到(150,100)，不過從beginPath開始，直到stroke()被呼叫為止，才會將線段渲染到畫板上，詳細說明可參考官方文件。 簡化 每次要畫線段都要呼叫beginPath() 跟 stroke() 實在是太多餘了，我把每次都相同的部份用methods封裝起來，中間實際會改變的部分我用callback當作參數傳入這個method，這麼一來就可以減少重複的程式碼： methods:{ ... draw(action){ let canvasContext = this.canvasContext canvasContext.beginPath() canvasContext.lineWidth = this.currentSize*2 action(canvasContext) canvasContext.stroke() }, } 實際使用： this.draw((ctx)=&gt;{ ctx.strokeStyle = this.currentColor.code ctx.moveTo(this.tempPosition.x,this.tempPosition.y) ctx.lineTo(pos.x,pos.y) }) 如果你寫Js一段時間應該會發現常見的map或是filter也是類似的用法。 實作鉛筆工具 鉛筆工具實作上，基本上就是找出滑鼠按下的時候，滑鼠移動的軌跡，再將這些點用線段一個一個連起來，實作前有兩個問題要先想一下： 如何記錄移動軌跡，每個點都記錄？還是只記錄一個？要記錄什麼時間點的軌跡 如何得知滑鼠現在是否為按下的狀態 ? 我實作的方式是，在window新增mousemove監聽事件，事件被觸發時，記錄滑鼠移動到B點時的前一個點A點位置，然後因為在B點時的位置可以直接透過js api取得，這樣就能夠對照前後位置，以實作鉛筆功能。 window.addEventListener('mousemove',(event)=&gt;{ ... let currentPos = this.getCanvasMousePosition(event.clientX,event.clientY) ... ... this.setCanvasTempPosition(currentPos.x,currentPos.y) }) 取得鼠標位置的細節可參考我的Github。只看程式碼可能有點抽象，第一次移動的時候，tempPosition一定是空值，直到位置發生變化（從A到B)結束後，A點位置才會被記錄到tempPosition，完成前一軌跡記錄。 再來，如何確定滑鼠是否為按下狀態? 我在canvas元素上分別新增mousedown跟mouseup事件，並在Vue data新增一個布林值isCanvasMouseDown，以透過這兩個事件切換滑鼠狀態。 onCanvasMouseDown(){ this.isCanvasMouseDown = true ... } onCanvasMouseUp(){ this.isCanvasMouseDown = false } 最後，就剩下canvas畫圖的功夫了，在畫圖之前記得先確認滑鼠狀態以及是否已有軌跡記錄之後再執行動作，否則會出錯： In MouseMove Event ... if(this.isCanvasMouseDown &amp;&amp; this.tempPosition){ let pos = this.getCanvasMousePosition(event.clientX,event.clientY) switch(this.currentTool){ case 'paint-brush' : this.draw((ctx)=&gt;{ ctx.strokeStyle = this.currentColor.code ctx.moveTo(this.tempPosition.x,this.tempPosition.y) ctx.lineTo(pos.x,pos.y) }) break; ... 橡皮擦工具 橡皮擦工具只是把已經畫上的圖案消去，這邊我直接用前面實作的筆刷工具，搭配背景色，可以達成一樣的效果，比較特別的是，我將canvas背景色記錄在vue data裡面，這樣就可以確保橡皮擦工具的顏色跟背景色是相同的值，減少錯誤發生機率。 Canvas 轉成圖片 轉成圖片不是什麼大問題，Canvas元素本身有一個toDataUrl，可以回傳回傳含有圖像的Url，最後再產生一個a元素，將網址貼上去後觸發click事件，就可以模擬點擊，達成下載圖片的功能。 canvasToImage(){ let url = this.$refs['sketchpad'].toDataURL(&quot;image/png&quot;, 1.0).replace(&quot;image/png&quot;, &quot;image/octet-stream&quot;); const link = document.createElement('a') link.innerText = 'Download' link.href = url link.download = 'circle.png' link.click() }, 空心矩形 這個功能是我思考最久的一部分，canvas要單純畫上矩形的話只要呼叫rect()方法就行，方法說明如下： ctx.rect(起始位置x, 起始位置y, 長度, 寬度); 這格應該不難理解，最難的是如何達成「滑鼠按下時可一邊調整矩形的大小跟長寬」如果像實作鉛筆功能時，在每個軌跡都畫圖型的話，就會發生災難： 看到這裡你應該可以了解原因了，因為我在每次滑鼠改變位置時都畫了一次。這邊要思考的是： 使用矩形工具，滑鼠按下時要做什麼事情 什麼時候紀錄前一個移動軌跡，什麼時候不要 我的解法是，當使用矩形工具，且偵測到mousedown事件時，在畫圖之前先用getImageData做一個簡單的暫存： methods:{ ... setTempCanvas(){ let ctx = this.canvasContext let canvas = ctx.canvas let tempCanvas = ctx.getImageData(0, 0, canvas.width, canvas.height); this.tempCanvas = tempCanvas }, ... } 並且在每次滑鼠位置改變並且渲染矩形完成後，用putImageData() 把暫存復原，以上面災難圖為例，就是每次畫完之後，只會看到最為面那層。 復與原重做 我找到一篇描述利用window.history模擬瀏覽器上ㄧ頁下一頁功能的文章，實作步驟簡單來說就是在每次畫完圖型後將目前畫面暫存進history裡面，再去透過js操作瀏覽器上頁跟下頁來達成這個功能，蠻有趣的。 多思考一些 - 使用者體驗 有幾個細節是比較容易被忽略的，但是如果有這些小地方可以讓使用者操作或是開發上更順暢，這邊把想到的點列出： 畫筆畫到一半，滑過工具列時，能不能繼續畫 調整大小時，能不能用拖拉調整 1.畫筆畫到一半，滑過工具列時，能不能繼續畫 我原本是把Mousemove事件放在canvas上面，後來做到一半才發現當我畫到一半，滑鼠經過工具列，他不會繼續對canvas的滑鼠事件有動作，因此會中斷畫圖，後來我將Mousemove事件放在整個windows上，並判斷現在滑鼠狀態是否是按下(MouseDown)，才解決這個問題。 2.調整大小時，能不能直接用拖拉調整 會想到這個是因為很多繪圖軟體都有這個功能，這邊的雷點跟第一點一樣，必須將mouseMove事件放在window上面，否則拖拉到一半滑鼠離開input元素時，就會停止調整Size數值，反而很不好用。 Vue Method: checkSizeDrag(dragValue){ if(dragValue&lt;0){ this.currentSize = parseInt(this.currentSize)+1 }else if(dragValue&gt;0&amp;&amp;this.currentSize&gt;=1){ this.currentSize = parseInt(this.currentSize)-1 } }, In MouseMove Event window.addEventListener('mousemove',(event)=&gt;{ ... let currentPos = this.getCanvasMousePosition(event.clientX,event.clientY) if(this.isSizing &amp;&amp; this.tempPosition ){ let dragValue= currentPos.y- this.tempPosition.y this.checkSizeDrag(dragValue) } ... } 你可以在這裡看到我的實作成果，或是在此參考我的程式碼。 參考文章 canvas基礎： http://test.domojyun.net/MEMO/Canvas/ pushState 實作復原及重做： https://ithelp.ithome.com.tw/articles/10195793","link":"/2019/03/03/canvas-sketchpad/"},{"title":"製作 Base on Cookie 的購物車","text":"瀏覽器Cookie 為無狀態的Http協議帶來方便快速的解決方案，雖然太過依賴Cookie會產生潛在的風險，但用在一些不那麼需要注重安全的應用上還是非常適合，。 這篇文章會從認識cookie是什麼開始，到解說如何搭配cookie來製作商務網站常見的購物車。 大綱： - Cookie是什麼？ - Client 端設計流程 - 存取Cookie - 撰寫更友善的JS Cookie Setter/Getter Cookie是什麼？ Cookie是瀏覽器的預設機制，提供4MB的空間去給網站暫存後續還會用到的資料，讓資料在其他頁面也能夠被取得，如果我們開啟開發者工具來看，就可以看到目前client所有的cookie： Cookie預設在每次網站送出Request的時候，就會被跟著夾帶到Server，而Server回傳Response的時候，也會把Cookie一起帶下來到瀏覽器端，看一下瀏覽器發出Request時的Header就可以發現這件事情：（下圖是Facebooke發出請求時的內容） 也可以從server端設定cookie，方法是在Response裡面夾帶名為 Set-Cookie的Header: Client 端設計流程 可以想見購物車資料被修改的時機是在使用者將商品加入購物車的那一刻，這時候我們只要把商品數量跟id紀錄起來就可以了，因為使用者還有可能會購買其他商品，所以還不需要太詳細的商品資料： 直到使用者進入購物車準備結帳時，就會需要跟後端調用商品確切價錢、確認有無優惠等動作： 由於cookie是會隨著送出的request一起到後端Server，因此我在後端可以直接拿到設定的cookie內容，然後去資料庫找到我要的相關資料，包成物件後再回傳到客戶端。 而直到使用者離開購物車頁面進入結帳頁面的最後一刻，我才會把剛剛使用者儲存的購物車資料存到Session，給訂單頁面的controller處理，避免使用者在結帳時發生商品資料與購買金額不一致的情形。 存取Cookie cookie 文件： https://curl.haxx.se/rfc/cookie_spec.html 瀏覽器有提供api讓開發者使用js拿到cookie，直接使用document.cookie就可以拿到了: 拿到Cookie document.cookie 設定cookie 設定cookie的方式並不是像操作js物件的Key/Value那麼直觀，而是要使用一定格式的字串&quot;name=xxx&quot; 但是後面會講到，可以利用js來包裝程簡潔好用function讓我們去設定它。 document.cookie = &quot;name=thecontentIwanttosave; path=/; expires=Thu, 18 Feb 2019 12:00:00 GMT&quot;; 要注意設定cookie時一起設定的path值會影響你在該頁面可以存取的cookie。 那麼path又是什麼？path是cookie的選項設定之一，跟domain可以搭配，domain是告訴瀏覽器這個cookie只能在這個被設定的域名下面使用，以防止別的網站可以拿到我的機密資訊。 **Cookie path syntax : ** The path attribute is used to specify the subset of URLs in a domain for which the cookie is valid. If a cookie has already passed domain matching, then the pathname component of the URL is compared with the path attribute, and if there is a match, the cookie is considered valid and is sent along with the URL request. The path “/foo” would match “/foobar” and “/foo/bar.html”. The path “/” is the most general path. 撰寫更友善的JS Cookie Setter/Getter 當我跟瀏覽器拿到cookie的時候，可能拿到的東西是這樣一整個字串： 瀏覽器沒有提供key value存取，所以我們只能操作字串，既然cookie是用分號去分隔，那用js的split就可以解決： var value = &quot;; &quot; + document.cookie; var parts = value.split(&quot;; &quot; + name + &quot;=&quot;); parts.pop().split(&quot;;&quot;).shift(); 但也不可能每次要拿個cookie都要操作字串，所以為了讓開發上能夠更順暢，我們可以把這段code包成function，減少重複的code。 這裡還有兩件事要注意： 空白字元在每個瀏覽器跟cookie的版本的表現可能都不一樣，因此以防萬一我們會將它轉為其他字元代替。 為了避免編碼問題，我們統一將cookie轉為URI編碼。 Getter function setCookie(name,value){ value = encodeURIComponent(JSON.stringify(value).replaceAll(' ','+')) document.cookie=`${name}=${value}; path=/;` return getCookie(name) } Setter function getCookie(name) { var value = &quot;; &quot; + document.cookie; var parts = value.split(&quot;; &quot; + name + &quot;=&quot;); let res if (parts.length == 2){ res= parts.pop().split(&quot;;&quot;).shift(); return JSON.parse(decodeURIComponent(res).replaceAll('+',' ')) }else{ return undefined } } 做到這裡，就剩下畫面呈現跟功能操作了，你應該已經可以很順暢的開始開發購物車，如果有任何其他問題，非常樂意你聯絡我跟我討論： Gmail : moojitsai@gmail.comonproduct=>operation: 商品細節頁 clickadd=>operation: 點擊加入購物車 setcookie=>operation: 將資訊更新至cookie onproduct->clickadd->setcookie{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);oncart=>operation: 使用者前往購物車頁面 sendReqtoBackend=>operation: 送出Request至後端 setcookie=>operation: 後端根據夾帶的Cookie找出相對的商品資料並回傳 oncart->sendReqtoBackend->setcookie{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);","link":"/2019/02/12/cookie-base-cart/"},{"title":"Vue.js + Node.js + OpenAPI 帶你一次了解 CORS 跨域請求","text":"本篇文章是我在六角學院地下城活動5F關卡的實作紀錄，會描述如何架設簡單的Proxy Server去跟政府的公開API拉取資料回來給前端Vue.js介面做互動。 成果可參考這裏(heroku開機要一段時間如果拉不到資料請多重整幾次。) 使用技術及觀念： Vue.js （with vue-cli3) Node.js (express with express-generator) Heroku CORS Headers Jsonp (僅技術講解) Outline 同源政策 Node.js — express generator HTTP 的 CORS Request 修改 Response Header 允許跨域 部署到Heroku Vue-Cli dev 模式下的proxy 什麼是Jsonp 寫在最後 同源政策 一般開發網站的時候，如果是採前後端分離的架構，就會遇到跨域問題。就像今天這個專案，我的目標是抓取台灣空氣品質的開放API，回來做成介面給使用者搜尋，但是在利用axios直接打API的時候，遇到了下面的狀況： 這是因為網頁在傳遞資料的時候，不管是透過傳統XMLHttpRequest（常見的ajax方式） 或是Fetch，都會遵循同源政策(Same Origin Policy)，「同源」指的是同個域名底下的資源，因為只能存取相同來源的資料，所以那些跨域的請求就會被阻擋掉。 這是瀏覽器的安全機制，當然並非如此一來就無法跨域存取了，我想到的解決有以下兩種： Jsonp (Json with padding) 使用Proxy 代理伺服器存取該目標API 因為jsonp的相關知識文章應該有不少，且有安全性疑慮（最後面會說明）。本篇會以Node實做Proxy為主來講解。 Node.js — express generator 跟前端有vue-cli 、 react-create-app 等方便又快速的手腳架一樣，許多後端框架也有類似的功能，express-generator就是其中一個。安裝方式非常簡單，如果對接下來流程有任何疑問，可以參考官方文件，有很詳細的使用說明。 在terminal輸入以下指令以安裝 npm install express-generator -g 輸入 express [你的專案名稱] 就可以產生出以express為基底的專案架構： express proxy-server 接下來就可以進入專案去新增我們要的api了。 HTTP 的 CORS Request 就像前面說的，CORS Request並非完全不可行，只是在Server端必須要有一些設定。既然我們不可能修改OpenAPI的Server內容，又因為後端資料交互是不會碰到瀏覽器的（因此就不會因為跨域問題被阻擋），我們就自己架一個Proxy Server來修改Http相關的設定，讓前端可以順利拿到資料。 CORS Request / Response流程 你在 example.com.tw 送出request給某網站的時候，在request body裡面會夾帶一個Origin的header，內容是你網站的Domain名稱： Origin: http://www.foo.com 而在後端伺服器收到request並且回傳resonse到client的時候，瀏覽器會去看response裡面的header–***「Access-Control-Allow-Origin」***是不是包含剛剛發出request寫的Origin 域名，如果有，資料才會允許被回傳。 修改 Response Header 允許跨域 先到剛剛創造的express專案底下。 先找到我們的Open API URL，等等會用到: http://opendata.epa.gov.tw/webapi/api/rest/datastore/355000000I-000259 ###安裝所需套件 因為我們要利用後端去跟遠端Open API互動，所以這邊我們使用node-rest-client來達成這部分功能，node-rest-client官方文件： npm install node-rest-client 新增API路由 在剛剛創造的express專案底下的主程式routes資料夾新增 air.js : air.js var express = require('express'); var router = express.Router(); var Client = require('node-rest-client').Client; var client = new Client(); /* GET users listing. */ router.get('/', function(req, res, next) { let queries=req.query console.log('query: ', queries); let url='http://opendata.epa.gov.tw/webapi/api/rest/datastore/355000000I-000259' var options = { host: url, method: 'GET' }; client.get(url, function (data, response) { res.json({...data}) }); }); module.exports = router; router.get() 是express的router基本寫法，最後將這個包含自定義route的Router實體export出去，之後必須在主程式app.js引入才會有效，可以參考官方文件，可以看到在rest-client抓完資料的callback，我用json方式回傳了Open API 回傳的結果。 ... client.get(url, function (data, response) { res.json({...data}) }); ... 主程式app.js路由引入 接下來在app.js裡面將剛剛新增的router引入： var airRouter = require('./routes/air'); app.use('/air', airRouter); 記得在var app=express()之後才做app.use()這件事，否則會讀不到app這個變數。 關鍵步驟： Response header 設定 將設定用middle的方式寫入，Express內，如果你直接在app.use()裡面傳入一個 function(req, res, next) { next()d } 那是middleware的意思，即所有request都會經過你傳入的function，且直到呼叫next()之後才會繼續執行，我們在這裡面設定Response 的Header，如此一來所有的Request都會得到相同的Header設定值（也可以在單獨某隻router寫入設定，可視需求改變）。 let allowCrossDomain = function(req, res, next) { res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS'); next(); } app.use(allowCrossDomain) 我在Response Header裡面加入了 &quot;Access-Control-Allow-Methods&quot;代表允許讓設定的Http Method通過。 “Access-Control-Allow-Origin”，其值為’*’。 注意，剛剛說Response回傳到Client之前瀏覽器會先檢查這個Header有沒有跟來源Origin的值ㄧ樣，如果是一般前後端分離的sercer這部分的值一般會xxx.com.tw，不會公開。如果你這樣寫，代表大家都可以對你的Server做跨域請求，這邊因為是open API 且是示範性質所以才這樣做。 到這邊其實已經完成了，如果順利的話你的Server應該已經可以拿到遠端API的資料，你可以用 npm run start // then go to http://localhost:3000/air 在本地架起來用瀏覽器或Postman去測試看看。 部署到Heroku 想要在Heroku 架起一台node Server非常簡單，流程大致上是註冊帳號-&gt;安裝heroku cli-&gt; 登入-&gt; 到你的專案輸入幾個指令-&gt; 最後 git push heroku master，他自己就會幫你在heroku提供的空間下npm install安裝好需要的套件並且架起來。 這邊就不多做說明，可參考官方教學，相信我，不會花掉你太多時間的，可先用官方提供的專案做練習。需注意的是因為是免費的服務，所以只要半小時沒在使用，他會暫時關閉你的機器，所以有時候連線會比較慢，可不要以為壞掉了。 可參考我的實作成果。 Vue-Cli dev 模式下的proxy Vue-cli因為是基於webpack，其實有proxy的設定，你可以參考官方文件。但因為這樣只解決開發環境的問題，所以後來我才打算自己架設Proxy。 另外，前端的部分因為比較基礎，就沒有太詳細解說，你可以看看我的Repo，如果還是有不懂的地方，隨時可以聯絡我。 什麼是JSONP 因為傳統 Ajax無法跨域，早期工程師們找到了替代解決方案—&lt; script&gt; tag 的src引用是可以跨域的，於是利用這個原理的jsonp就這麼誕生了（想想你在引入一些js函式庫如lodash的時候是不是可以用cdn方式直接引入執行？) Jsonp會做什麼事情 創造一個 &lt; script &gt; tag 根據你指定的Jsonp位置，設定這個tag的src 把這個&lt; script &gt; 加到瀏覽器DOM的head 一但資料載入完畢，會將回傳的資料傳給設定的callback並執行這些內容 Jsonp的安全隱患 如果你使用JsonP，那你帶進來的這些內容，跟你自己寫的jsㄧ樣，可以去存取你的DOM等網頁內容，這種情況下如果無法保證server的安全性，將會是潛在的問題。 寫在最後 前端介面成果：http://underground-air.surge.sh/ Proxy Server成果： https://mu-air-proxy.herokuapp.com/air 到這邊，如果你可以很順的理解以上的內容，那你應該對CORS Request流程有一定的了解了。其實因為時間跟篇幅的關係，有些實作部分我並沒有講的很仔細，但是我都有提供相關文件在該段落的附近，因為我覺得寫程式常常需要的是閱讀文件的能力，希望各位可以學著找到自己所需的資源並補上。在「尋找資源-實作-找問題修Bug」的循環過程中其實也在訓練自己的理解跟整合能力，才會讓你慢慢進入學習的正向循環。 當然在這過程中有任何的不懂或是覺得有筆誤的話都可以隨時聯絡我，我很樂意跟你分享我所知道的知識。 參考文章 STOF上關於CORS的討論 CORS PROTOCAL how jsonp works? CORS流程圖","link":"/2019/02/13/cors-node-vue/"},{"title":"DroneCI 串接流程 (1) - CI 建置","text":"CI (Continuous Integration) / CD (Continuous Delivery) 這系列 Drone 的文章是我在公司中因為需要優化開發流程而寫的 CI / CD 工具架設過程紀錄，給有需要的人參考，其中很感謝我的架構師夥伴 Jackie-Cheng 的技術協助，幫我一起研究文件、做了許多嘗試，最後才有這系列的文章。 Outline 什麼是 CI / CD ? CI 流程 - 流程設計 CI 流程 - 與 Bitbucket 串接 CI 流程 - 執行程式碼測試 CI 流程 - 整合至 Docker Hub 什麼是 CI / CD ? 身為一個程式開發者，在產品開發完畢後多少都會碰到環境架設的工作，規模小一點的專案，其實我自己以前也都是手動連上主機去拉最新版本下來更新的。但是稍微有一點規模的專案，很可能同時是會需要不同環境（正式/測試/開發環境）來配合的，所以上述說的舊做法可能就不再適用。 為了節省時間，我們需要引入 CI / CD（持續整合 / 持續發佈 ）。 什麼是 CI 呢 ？ CI 存在的目的就是為了創造一系列能夠自動化建置、打包、或測試專案的方式，如此一來團隊在開發產品的時候就能夠更頻繁的提交進度，然後系統透過監測每次的變動，就能夠持續地自動測試並驗證以確保品質和穩定性。 在 CI 階段結束，整合完畢確定沒問題之後，就可以透過 CD 流程來把新釋出的版本推送到測試/正式環境上，讓相關專案人員可以直接瀏覽更新後的結果，而這中間從推送新版本、測試程式碼功能及可讀性、到環境測試及部署，完全都是可以持續進行且自動化的，這就是 CI / CD 現在這麼熱門的原因。 我自己比較常聽見的 CI / CD 工具有 Travis CI / Jekins / Drone CI 三套，而 Drone CI 因為架設快速，設定撰寫方便， 又是開源免費的，所以我最近也對這套工具產生興趣，在這系列文章裡面，我打算以Drone為例，把整個建置流程記錄下來與大家分享。 CI 流程 - 流程設計 先構想一下整個 CI 流程， 一個可能的CI 流程如下： 發送 Commit / Merge / PR 到 Git Remote Repo 該 Repo 偵測到改變，通知 Drone Server 根據 drone.yml 做出相對應的 Task 開始跑測試及建置 沒問題之後發佈到 Docker Registry (ex. Docker Hub) 上推出新版本 整合新版本到 Docker Hub 之後其實還可以讓 Docker Registry 偵測更變然後自動部署到串接好的機器上，就像 Bitbucket 偵測程式碼的改變然後做動作一樣，不過這應該屬於 CD 的部分，先不深究，附上流程圖： CI 流程圖 CI 流程 - 與 Bitbucket 串接 CI 通常會跟版本控制的流程綁在一起，而版控則有許多雲端服務，例如 Github / Gitlab / Gitlab 等幾個，透過這些 Git 服務，就能夠讓開發者可以把自己的專案源碼存放在第三方（較安全），這些服務基本上都是免費的，除非有需要使用到比較進階的功能。在這裡我們會用 Bitbucet 為例子來跟自己架設的 Drone Server 做串接來做到第一階段的 CI 部分。 Step 1. Bitbucket OAuth Setting 首先要在Bitbucket個人設定頁面新增一組 OAuth 的 Secret-Key Pair 來讓之後架設的 Drone CI 能夠得到對本人帳戶拉取 Git Repo 的權限。 進入新增頁面之後把Name / Description / Callback Url 寫一寫，記得 Callback Url 要填寫之後預計要架設 Drone Server 的位置後面加上 ‘/login’，才能讓 Drone Server 的 UI 正常運作！填好之後就可以送出了，會拿到一組 Key 跟 Secret，記得記下來。 Step 2. Drone Server 安裝及部署 之後可以連到你預計要跑 CI 測試的機器上，先把 Drone 的 Image 拉下來： docker pull drone/drone:1.0.0-rc.1 之後就可以把 Drone 的 Container 起起來了，用docker run 搭配對應的參數來啟動 Drone Server ： docker run \\ --volume=/var/run/docker.sock:/var/run/docker.sock \\ --volume=/var/lib/drone:/data \\ --env=DRONE_BITBUCKET_CLIENT_ID={% your-bitbucket-key %} \\ --env=DRONE_BITBUCKET_CLIENT_SECRET={% your-bitbucket-secret %} \\ --env=DRONE_RUNNER_CAPACITY=2 \\ --env=DRONE_SERVER_HOST={% your-drone-server-host %} \\ --env=DRONE_SERVER_PROTO={% your-drone-server-protocol %} \\ --env=DRONE_AGENTS_DISABLED=true \\ --env=DRONE_TLS_AUTOCERT=false \\ --env=DRONE_USER_CREATE=username:{% your-repo-host-user%},admin:true \\ --publish=80:80 \\ --publish=443:443 \\ --restart=always \\ --detach=true \\ --name=drone \\ drone/drone:1 上述參數說明 : your-bitbucket-key / secret ： 在第一步驟時 Bitbucket OAuth 設定完成後取得的 Key Pair your-drone-server-host : 在 Bitbucket OAuth 設定時所輸入的 Redirect Url 的 Host，如果使用 IP 位址的話可以把 Port 帶進來 your-drone-server-protocol : 你的 Drone Server 所使用的傳輸協定，輸入 http 或 https your-repo-host-user : 對你的 repository 有控制權的使用者名稱，以這個專案為例，就是 Bitbucket 的使用者名 ，這行等於是讓自己對 Drone Server 有最高的存取權限，使用 GUI 時才能看到完整設定。 順利啟動之後，應該就可以在你所設定的位置看到 Drone 的操作介面了，第一次進入時會跳出跟 Bitbucket 要求權限的確認視窗，之後就不會有了。示意圖： CI 流程 - 執行程式碼測試 把基本設定做完之後，Drone 在被觸發時，會自己找專案根目錄裡面的 .drone.yml 去做相對應的 Pipeline 動作，一個最基本 Drone Pipeline 的範例如下： kind: pipeline name: default steps: - name: frontend image: node commands: - npm install - npm test ... steps 是一個 list ，用來描述你要做哪些事情。 你可以寫好幾個 step 分別執行不同的動作，每個 step 都會根據你 image 的設定，啟動一個包含你 Repo 的新 container ，然後根據 commands 執行你想做的事情，範例中的 step 就會安裝完專案所需的 module 之後，執行測試，然後結束。 CI 流程 - 自動發布到 Docker Hub 當 Drone Server 上面跑完測試，並且確認沒問題之後，我還希望 Drone 可以幫我自動推到 Ducker Hub 上發出新版本的 Image ，這一樣可以透過 drone.yml 設定檔完成。 加上一個新的 step 並且搭配 drone 的 Docker plugin ，然後把你 Docker Hub 帳號密碼 跟 Repo 名稱填入之後即可。 steps: ... - name: docker image: plugins/docker settings: repo: your-dockerhub-name / repo-name target: production username: herocat password: 123456 tags: latest 這樣設定好以後每次有新的更動，我就能夠自動地 docker build 然後推新的 image 到我給的位置，這邊的帳號密碼如果沒有搭配其他工具，就只能用明碼寫入，非常不安全，不過這邊只是為了說明所以這樣做。後面我們會講到如何搭配 Drone 內建的機密資訊管理工具來確保專案資訊的隱密性（讓密碼或token這類資訊在 drone.yml 內可以不用明碼紀錄）。 補充一下，如果不想要每次推上新的 Commit 都跑 Docker 相關 task，則可以用 when 關鍵字來限定某些 branch 才會觸發。 steps: ... - name: docker image: plugins/docker settings: repo: your-dockerhub-name / repo-name target: production username: herocat password: 123456 tags: latest when: branch: - master - feature/* OK，目前已經完成我們設計的 CI 流程，在下一章節我會繼續往下補充如何完成 CD 的流程讓專案的新版本能夠自動部署到另外一台 Server 上。 下一篇： DroneCI 串接流程 (2) - CD 建置 參考文章： 什麼是 CI / CD ? What is CI/CD? Continuous integration and continuous delivery explained Drone CI Document","link":"/2019/08/06/drone-deployment-1/"},{"title":"DroneCI 串接流程 (2) - CD 建置","text":"上一篇： DroneCI 串接流程 (1) - CI 建置 在上一篇，我介紹了如何在自己的 Server 上架設 Drone 的主機，並與 Bitbucket 串接，從測試到專案建置、再到 Docker 的整合。到這裡我們已經完成了 CI 的部分，在第二個章節，我會跟大家分享如何繼續搭配 Drone 建置後續的 CD 流程。 Outline CD 流程設想 Drone Agent 架設 Drone Secret 管理 使用 drone-ssh plugin 部署新版本 CD 流程設想 (Continuous Delivery ) 目前我們已經有了第一台 Drone Server ，後續其實可以再多架 Agent Server，而在跑 CI 測試流程的時候，可以把不同的 Pipeline 交給不同的主機去跑。指定 Pipeline 的設定一樣可以單單只由 drone.yml 完成。 在後面的章節中我們也會講到如何透過 Drone 來管理機密資訊，讓這些 Service 用到的密碼可以被隱蔽。而在所有的測試通過並跑完之後，我打算搭配 drone-ssh 這個套件來讓我能夠登入另一台 Server 並從 Docker Hub 上拉下最新版本的 Image 並完成部署： 以下是預計的架構裡面會需要的部分： Drone (Master) Server : 最一開始架設，最主要專門 跑 Drone Pipeline 的 Server。 Drone Agent Server : 當 Pineline 需要做的事情比較多時用來幫忙分擔 Loading 的Server。 Secret 管理工具 ： 有一些功能需要登入第三方服務的話，這個時候如果將密碼直些寫在 .drone.yml 檔案裡面（明文），那其實是非常不安全的行為，因此我們會需要工具來讓我們安全的在設定檔裡面使用這些密碼。 plugins/docker : Drone 裡面的 docker 插件， 使專案能夠快速推送新版至遠端 Docker Registry drone-ssh : Drone 搭配的 ssh 工具，使專案能夠登入遠端另外一台主機執行寫好的指令 Agent Server 架設 ( 以Docker Compose 為例 ) Agent 的架設整體上可以分為幾個步驟： Agent Server 架設 設定 Agent Server 的 label 名稱 ，用以辨識 專案內 .drone.yml 檔案指定 跑 pipeline 的 Agent Server 補充：由於 Drone 的 Master 跟 Agent 之間是透過 RPC 溝通的，所以在啟動 Master 及 Agent 的 Container 時，記得要加上 RPC Token 相關的設定，這點可以參考 官方文件 。 Agent Server 架設- Docker Compose File : 基本上 Drone Agent 的架設跟第一章節提到的 Master Server 的設定相去不遠，差別只在使用的 Image 不同，其他部分 Drone 都幫我們做好了，我們只要提供相關的 RPC Token 再設定好 Server 的 Label ，以方便後面指定即可。 version: &quot;2.0&quot; services: drone-agent: image: drone/agent restart: always volumes: - /var/run/docker.sock:/var/run/docker.sock environment: DRONE_RPC_PROTO: http DRONE_RPC_HOST: 125.227.167.242:5999 DRONE_RPC_SECRET: c5b06c767123123ddd763b8e8 DRONE_RUNNER_CAPACITY: 2 DRONE_RUNNER_NAME: drone-agent-130 DRONE_RUNNER_LABELS: hostname:drone-agent-130 重要參數說明 : DRONE_RPC_HOST : Drone Master Server 的位置，Agent才知道要聽誰的話 DRONE_RUNNER_LABELS ： 用來指定 Pipeline 的識別名稱，預設是主機名。 DRONE_RPC_SECRET： 與 Drone Master Server 溝通的 Token ，用來讓兩邊互相溝通，Master 端也會有相同的設定，可以用以下指令來產生 Token : openssl rand -hex 16 其他 Agent 相關參數說明可以參考官方文件。 寫好相關設定之後就可以透過 docker-compose 啟動 container 囉！ docker-compose up -d ./docker-compose.yml Drone Secret 管理 Drone 內建就有 Secret 管理功能，你也可以自己架第三方的工具，如 Vault 或是 AWS Secret Manager 等…來管理，在每個 Drone 管理介面上 Repository 的 Setting 點進去之後，就可以很快找到 Secret 管理的區塊，只要輸入對應的 Secret ，後續就可以直接在 drone.yml 檔案裡面引用囉。 在 drone.yml 裡面使用 from_secret 關鍵字引用剛剛設定好的密碼： 使用 Drone SSH Plugin 部署新版本至遠端 Server 在所有流程的最後，我想要把測試完畢沒有問題的版本部署到正式環境上，我找到了一個適合的套件讓我能夠直接登入 Production 環境的主機並且執行寫好的指令，所以我只要直接從 Docker Registry 上拉下最新版並重新啟動，就完成了最後部署的部分！ 到這邊我們已經從 CI 測試流程，推到 Docker 儲存庫，並且全程搭配 Drone 的 Secret Management ，所以我在寫 drone.yml 的設定時，如果有些插件必須使用密碼登入，這些資訊就能夠安全的被使用，不會輕易外流。最後使用 drone-ssh 插件，直接在 Production 環境上部署，完成 最簡單的一個 CI/CD 流程。 完整的 CI/CD 流程應該會隨著團隊專案規模而改變，例如中大型專案常常搭配 Git Flow 或是 Github Flow ，然後會搭配 PR 觸發測試，通過以後才推送到 Dev 環境，減少錯誤機率，不過把基本功能跟流程理過一次後，後面怎麼變化就看使用者的需求了，非常感謝大家看到最後，以後有發現有興趣或有需要的工具再上來跟大家分享囉！ 參考文章 https://www.slideshare.net/Robert_McDermott/anatomy-of-a-continuous-integration-and-delivery-cicd-pipeline","link":"/2019/08/06/drone-deployment-2/"},{"title":"前端工程師後端之旅(序) - 原來30天可以走這麼遠","text":"一個月可以做很多事：可以讀一本書、可以出國旅遊、可以養成一個你想要的好習慣，我用一個月從零開始學習後端知識並獨立打造出一個購物車網站。 我是一名熱愛技術的網站工程師，最近參加了 Luka 的饅頭計畫，我給自己三十天的時間，用拆分網站的方式理解商業邏輯，自己思考使用者流程以及資料關係，從網站的前台介面，反推頁面流程設計，反推資料庫設計，最後做出整個網站前台與後台。後台甚至可以實際地使用「所見及所得編輯器」新增與編輯商品資料。 筆者實作前技術狀況 進入Web領域一年，目前是Vue.js前端工程師，對前端HTML、CSS、JS較熟，後端邏輯、MVC架構以及資料庫則是只有基本的了解。 專案目標 學習新的後端知識，完整重現目標網站功能，利用分析現有網站的方式，讓自己更容易理解，也增加實作跟規劃能力。 網站成果 你可以在這裡看到我的實作成果，以下筆記是這三十天內實作過程紀錄： 前端工程師後端之旅(1) - 原來30天可以走這麼遠 前端工程師後端之旅(2) - 從畫面看出User Story 前端工程師後端之旅(3) - 前路由設計以及Slug SEO優化 前端工程師後端之旅(4) - 前端體驗優化 前端工程師後端之旅(5) - 資料庫關係設計 前端工程師後端之旅(6) - 利用爬蟲取得網站原始商品資料 前端工程師後端之旅(7) - 爬上穹頂的最後一哩路：部署 Javascript - 製作 Base on Cookie 的購物車 Javascript - 初探Regex 正規表達式 Javascript - Shrine + Summernote 所見即所得編輯器達成圖片上傳 Javascript - JS What’s this? this的四種繫結 為什麼要進行這個練習 身為前端工程師，我覺得有必要說明做件事的理由。先說結論：我仍然想要繼續我的前端之路。 但我希望身為一位網站工程師我能夠有規劃出符合需求網站的能力，而一個網站的核心基礎大多與後端脫不了關係。而且我認為網站概念本不分前後端，因為現今網站技術跟需要處理的細節越來越多，才讓前後端界線越來越明顯，但如果要能夠讓自己規劃以及實作的能力更得心應手，多少還是必須同時跨足兩個領域。 再加上我個人在學習上比較不喜歡一知半解，前端工程師常常以API跟後端互動，卻不會知道資料怎麼來的，怎麼放進去的，放在哪裡？對於這些疑問我無法置之不理，所以也算是今天做這個練習的主要動機之一。 觀念的轉變 一眨眼一個月就過去了，在這段時間內我利用所學新知完成完整的網站作品。在這過程中我從一開始的不知所措到最後學會可以專注完成每個階段性目標。其實一開始也沒想到可以做到這個程度，不過我我也是藉由改變一些原本的觀念來達到這個成果，我可以跟各位分享我的一些反思跟我是怎樣調整心態來看待遇到的困難跟問題。 從這中間我學到幾個觀念來維持自己的成長： 對任何資訊保持警覺 維持紀錄所學的習慣 慎選平時吸收的學習資源／環境 學會建立心態 對新資訊保持警覺 記得這段時間我每天睡醒就是開電腦看新文章，但是我有一個習慣，就是容易對眼前的疑惑追根究底，進而太過鑽牛角尖。在這次練習經驗裡，這個習慣就造成我不少困擾。不過也多虧我的mentor（Luka)在這中間給了我不少提醒，適時的調整心態，最有效的一個建議就是： 不管看了多少新的東西，記得專注解決眼前的問題 在實作期間，花在研究新技術的時間，最好都是為了解決問題，否則容易太發散，到最後根本忘了自己一開始要做什麼，而你必須有能力判斷目前正在接收的資訊是否適合現階段的學習。相信不少人在學習路上也遇到過跟我類似的問題吧，基本上只要能夠抓住這個原則，就能避免走進迷失方向的惡性循環。 維持紀錄所學的習慣 這段日子裡我不斷重複一種學習-&gt;吸收－&gt;紀錄的循環。一開始看到新的東西，腦子未必能夠馬上吸收，但是可以對這個技術有一定的了解，而透過實作來學習最大的好處就是可以得到即時的回饋。最後透過寫下筆記整理思維，也可以更確立自己的了解程度。 看文章學習- &gt; 導入實做 -&gt; 試著把學到的東西記錄下來寫成文章 很多人一聽到要另外花時間寫筆記就覺得很麻煩，我的建議是，不管紀錄的詳不詳細，都盡量練習把理解到的東西寫下來，可以訓練對知識的熟悉度，更重要的也同時在訓練表達能力。 慎選平時吸收的學習資源／環境 我覺得工程師這個職業就像一把刀子，就算沒有使用時也要常打磨，讓自己隨時準備好。所以對每個工程師來說，平常如何吸收新知與選擇接觸的資源就非常重要。 一個資深的開發者大多已經掌握自我學習的方法，但對於初學者來說，他最常接觸的可能是書、可能是線上課程或文章，不過與其說慎選資源不如說： 要非常慎選學習對象（導師）。 不論是文章還是課程影片的挑選，最終會影響你的還是教授這些事情的人。教學者的觀念、所做的行為會深深影響你處理事情的方式，包括學習。但一開始並不是每個人都有如此透徹的判斷力，在你還不知道教學者的好壞以前，我建議你保持自己的獨立思考，任何事自己先思考過一遍。 大家在剛進入職場學習時一定會遇到比較資深的前輩，盡情跟他學習吧！但記得對任何接收的訊息保持警惕，不要照單全收。 學會建立心態 說到學習新知識這件事情，就讓我想到一句話：「身子要軟，骨子要硬」。 有任何學習機會就儘管接受，但同時也要學會過濾那些看起來很充實但是對學習沒有幫助的事情，這裡講的不只有工作而已。同樣的時間，可以花在更有前瞻性的研究，也可以用在重複造輪子，時間是你的，一但你意識到自我價值，自然就會開始認真看待每件事情所花費的時間。 寫在最後 這個階段的目標結束了，接下來我也會繼續像這樣前進，設立短期階段性目標的學習讓我很有成就感，也讓我更了解自己在這條路上走了多遠。 同時我剛好正在尋找下一份工作，如果有興趣的可以參考我的履歷。 我的下一個目標是前端框架React，jsx的寫法很引起我的興趣，我會直接用專案開始練習，如果有人也正好要學這個框架，可以追蹤或聯絡我，也許有機會可以一起學習。 謝謝你的閱讀，希望以後我能以分享的方式繼續影響更多人，如果我的文章有幫助到你，請你幫我拍個手，讓我有動力繼續分享這類文章！ 有興趣往下看的人，讓我們繼續吧！可以先看看我是怎麼從外觀了解網站的架構的。","link":"/2019/02/11/front-backend-travel-1/"},{"title":"前端工程師後端之旅(2) - 從畫面拆解，到整理User Story","text":"在這個章節，我會說明我如何理解整個網站，並將其拆成很多一小部分功能，並整理出User Story。若對網站實作成果有興趣可參考： http://mujingtsai.site/ 文章大綱： 什麼是User Story 用sketch整理網站的Flow 根據這些畫面列出 User Story 什麼是 User Story? 我們的階段性目標是寫出一套好理解且容易閱讀的功能需求，這個情況就非常適合User Story，User Story 通常是一段簡短但明確的功能描述，大多是這種句型開頭的： （在XXX 頁面 ）身為一個 XXX 我可以做 XXX ，以達到XXX 目的。 由於User Story 是以使用者角度為出發點，去描述網站需求，以及某個動作可以為使用者帶來的價值，除了可以避免商業上自我感覺良好的盲點，也非常利於工程部門跟其他非開發人員（如業務、PM、老闆、設計師）等角色的溝通，在這邊整理出來是為了讓自己在之後的階段可以隨時回來確認，確保功能跟需求的一致性。 Step1. 用sketch整理網站的Flow 網頁截圖進Sketch ，Sketch裡有link功能， 可以記錄頁面點擊事件的先後順序，以此模擬網站的行為， 此處用已經完成的網頁做練習，如果是在開發階段，則使用Wireframe即可（WireFlow）。 目標網站： https://www.leisurecosmetics.com/ 我從首頁開始，試著去點擊每個按鈕，看會導向哪一個頁面， 並拆解成一張一張截圖放進Sketch，做成User Flow ![](https://i.imgur.com/TnbcQWb.png =400x250) ![](https://i.imgur.com/n1hwrHE.png =400x250) .col-6{ width:48%; margin: 0 5px; } .dib{ display:inline-block; } Step2. 列出 User Story 目標網站是標準的購物網站，先分出頁面在一個一個列出可能的情境利用User Story 來描述以下的功能： 商品 &amp; 商品分類 文章 &amp; 文章分類 購物車 聯絡我們（留言） 後台商品（類別）管理 後台文章（類別）管理 後台圖片上傳 + HTML編輯器 1. 商品 &amp; 商品類別 ： 使用者可以進到類別列表 使用者可以進入商品資訊頁並將商品加入購物車 使用者將商品加入購物車之後會有Flash Message回饋 ![](https://i.imgur.com/dnurv04.png =400x250) ![](https://i.imgur.com/YuAGv2c.png =400x250) 2. 文章 &amp; 文章類別 : 使用者可以瀏覽某類別的文章列表 使用者可以瀏覽文章詳細內容 ![](https://i.imgur.com/frtkAx6.png =400x250) ![](https://i.imgur.com/uTHcND1.png =400x250) 3. 購物車 使用者可以新增/刪減商品 使用者可以結帳 ![](https://i.imgur.com/u7zMk6X.png =400x250) ![](https://i.imgur.com/H4DbNVW.png =400x250) 4. 聯絡我們表單 使用者可以留下資料跟訊息並送出 ![](https://i.imgur.com/u5EEz8P.png =400x250) ![](https://i.imgur.com/HksOBzR.png =400x200) 5. 前台登入 使用者可以登入前台 使用者可以登入後台 6. 後台商品（類別）管理 使用者可以新增商品 使用者可以刪除商品 使用者可以瀏覽商品細節 使用者可以瀏覽所有商品 7. 文章及文章類別管理 使用者可以新增文章 使用者可以刪除文章 使用者可以瀏覽文章內容 使用者可以瀏覽所有文章 8. 後台圖片上傳 + HTML編輯器 使用者可以在編輯器內上傳圖片 檔案上傳是蠻常見的後台需求，但也是比較複雜的一項功能，要同時顧及到檔案類型限制、大小限制，以及如何讓上架流程更順暢，要讓使用者在編輯器內圖片上傳則需要javascript輔助。 （技術細節請見這裏) 在理解畫面，且整理好User Story之後，接下來我會說明如何進行下一步： 根據這些畫面去設計出網站路由並且做SEO優化處理","link":"/2019/02/11/front-backend-travel-2/"},{"title":"前端工程師後端之旅(3) - 路由設計以及Slug SEO優化","text":"路由的設計也是開發網站時的重點之一，不同的功能及頁面，甚至資料存取方式，都會收到Route規劃的影響。 我們得先知道，網站總共有哪些頁面，才能整理出頁面和頁面之間的關係，進而設計出合適的路由，下面是根據畫面整理出來的網站架構，如果對於網站畫面拆解有興趣的，可以參考上一篇： 從畫面拆解，到整理User Story 或可參考網站成果： http://mujingtsai.site/ 文章大綱： 網站 Sitemap 路由設計 Slug SEO 優化 網站 Sitemap 根據該所有可到網站頁面可整理出如下面這樣的網站頁面圖， 這對確認需求有蠻大程度的幫助，討論需求時也比較不會東漏西漏： 前台Sitemap 後台Sitemap 路由設計： 原本的Route方式比較雜亂，雖然設計上算是Restful， 但route還要index.php還是不太美觀，甚至有可能影響SEO， 因此我想要設計成直觀一點的路由。 商品類別路由 /product/category/:category_id 商品路由 /product/:product_id 新聞類別&amp;&amp;新聞路由 仿照product，一樣的方式，把product改為news: /post/category/:category_id /post/:post_id 購物車路由 原來的購物車路由跟結帳路由被放在同一個層級下，容易令人疑惑，因此如果能夠拆開比較好： /cart 結帳頁面 /checkout 登入頁面 /user/login 會員資料頁： /user/edit Slug SEO 優化： Slug(別名) 是在URL裡面，藉由給每一個頁面一個不重複具有識別性的資料，達到以更語意化的方式存取資料，藉此提升SEO友善度。 很多時候在某個頁面有很多相同類型的資料要存取，比如商品列表內某一筆商品資料、某一筆文章資料…，我們會透過在路由內搭配變數，利用商品id去存取，例如： /products/:id 而在使用上我們就可以透過「/products/12」去找到第12筆商品內容頁面。基本上只要能夠確保每個:id變數是獨一無二具有識別性的，就能透過這個路由一次性處理多筆資料。 但是這樣子的用法對SEO來說並不夠友善，要針對路由優化SEO，有一個大原則是讓URL簡短、清楚、語意化，其實在這個情況下，可以與路由搭配的識別性資料，也不一定只有id。 我們可以一筆一筆商品自己給定不重複的slug， 但不難想到，以商品來說，通常商品名稱也是不會重複的識別性資料。 所以我們可以直接用拿來搭配使用，而且這樣子一看就知道是對應到哪個頁面了。 例如: products/categories/限時優惠 當然我們還是得做一些防止slug重複的方法，以免意外性的名稱重複導致網站無法運作，由於使用Slug通常是在資料庫商品資料表的欄位內多插入一個Slug欄位，所以必須指定資料欄位為unique，防止相同的資料被寫入第二次，以rails 來說就是在migration寫入類似： add_column :posts , :slug , :string , :index =&gt; { :unique =&gt; true } 以指定唯一的索引，你可以透過 http://mujingtsai.site/products/categories/新品上架 來看到我的實作成果。","link":"/2019/02/11/front-backend-travel-3/"},{"title":"前端工程師後端之旅(4) - 前端體驗優化","text":"Outline 這個專案著重於後端資料規劃，不過在前端部分我還是有幾個覺得可以優化的地方，分別是 訊息提示 表單檢查 購物車實現方式。 訊息提示 不管是成功或是失敗，訊息回饋我們不希望用跳頁的方式，以減少server的負擔，不過以MVC框架的話用server端解決對工程師來說是比較明確。我想也許這邊可以用重要性來分，如網站底下的聯絡我們表單，就很適合用ajax送出資料，然後給予使用者提示。 像是使用者註冊跟個人資料修改這種比較重要的資料，就可以用傳統跳頁的方式，使得回饋感比較重。 頁尾聯絡表單 不跳頁的即時回饋： 結帳頁面Coupon彈跳訊息 結帳頁面的coupon因為是用ajax去確認coupon合法性，所以訊息不採用跳頁的方式。 表單錯誤檢查 表單檢查最好是前後端都做，但由前端處理可以減少server負擔，也確保資料送到server時的完整度， 這邊示範前端表單檢查： 結帳頁面 頁尾聯絡表單 購物車實現方式 原本的購物車是做在Server Side， 所以每加入一次購物車，甚至在購物車頁面增加或減少商品數量都是一次Request，使用者每點擊一下都要等待將近一秒鐘的延遲，對使用者比較不友善。 所以我將體驗改為，直到使用者結帳之前，都是使用瀏覽器Cookie記錄使用者加入購物車的商品資料；而使用者進入結帳頁面之後，我才是使用session來傳遞購物車資訊，避免商品資料被竄改，產生使用者購買錯誤商品的悲劇。 你可以在這裡看到相關的技術細節。","link":"/2019/02/11/front-backend-travel-4/"},{"title":"前端工程師後端之旅(6) - 利用爬蟲取得網站原始商品資料","text":"為了盡可能重現目標網站，我們會需要原來的商品資料，但總不可能一筆一筆複製貼上，這時候我們就會需要爬蟲，爬蟲就是一隻去造訪網站並且分析網站回傳的資料，我們就可以只拿出我們需要部分的資料，透過爬蟲我們可以做很多數據統計的分析，比如：分析某某競爭對手電商的產品趨勢、分析PTT八卦版最常出現的用詞…等。 Python是最常見用於撰寫爬蟲的語言之一，但其實大多數語言都可以用來撰寫爬蟲，因為目前正在學習Rails，而且Ruby還能夠透過’active-record’使用ORM跟資料庫溝通，非常方便，所以今天我會用ruby來示範如何撰寫一隻爬蟲。 Outline - 流程 爬蟲從獲取資料到分析完資料之間可細分為幾個步驟： 觀察url規律 模擬送出HTTP Request 取得網站Response 分析html內容結構 取出需要的部分並整理 與資料庫取得連線 整理後存入資料庫 使用工具 要進行以上幾個動作，我們會需要幾個套件，分別是： nokogiri：可以讓我們使用與jquery選擇器一樣的方式去選出html內容 rest-client： 可以模擬並發出http請求 active-record ：讓我們可以使用ORM與資料庫溝通 pry ：讓我可以下中斷並且觀察資料 觀察Url規律 既然是要拿到所有相同類型的資料，只要觀察不同筆資料間url的相異之處就可以了，如 https://www.leisurecosmetics.com/index.php?route=product/product&amp;product_id=75 https://www.leisurecosmetics.com/index.php?route=product/product&amp;product_id=77 可看出改網站用product_id來識別商品。 模擬送出HTTP Request並取回html網頁結構 寫過前端ajax的人，一定常用axios.get(‘http://example.com/api/xxx’) 去送出get請求拿回資料，其實一般我們進入瀏覽器時，就是在對該網站的server送出Http的get請求，只不過跟ajax不同的是，拿回來的不是api資料，而是網站的畫面，這就是常聽到的Server Side Rendering，圖為進入youtube時所送出的Get請求。 接下來利用rest-client去模擬http get請求到該目標網站： html = RestClient.get('https://www.leisurecosmetics.com/index.php?route=product/product&amp;product_id=75') binding.pry 下中斷並觀察取回的資料 我們已經把網頁的html拿到手了。 分析Html結構 透過RestClient取回資料後，接下來我們需要Nokigiri去讓我們可以很方便找到我們要的資料，他的使用方式其實就很跟jquery選擇元素的時候一樣，例如，想要選到商品title，我先觀察，商品title上面是否有唯一且具有識別性的元素？ &lt;h2 class=&quot;text-primary&quot;&gt;BS03 輕透底光 - 面部化妝刷具套裝&lt;/h2&gt; 觀察到商品名是用h2包起來並且有 .text-primary 這個class， 我可以先用瀏覽器確認是不是用h2.text-primary可以只選到標題： 取出需要的部分並整理 太棒了！上面正好是我要的，之後我們只要用Nokogiri以同樣的方式選出該元素就行： html = RestClient.get('https://www.leisurecosmetics.com/index.php?route=product/product&amp;product_id=75') doc = Nokogiri::HTML(html) doc.css('h2.text-primary').text //===&gt; get product title 用gsub方法把空白字元去掉，ruby的gsub就跟js的replace一樣都是用來代換字串： doc.css('h2.text-primary').first.text() .gsub(&quot;\\n&quot;,&quot;&quot;) .gsub(&quot;\\t&quot;,&quot;&quot;) 拿到我要的資料。 也可以用正規表達式來匹配資料： doc.css('.price h2').first().text.match(/(\\w+)\\$([\\d,]+)/)[2] //get product price 與資料庫取得連線 Ruby 的active record 其實不一定只能跟著Rails 搭配使用，反過來說，Rails也不一定要使用這套ORM（也有其他的）。這裡我們就把active record單獨拿出來使用，作為與資料庫溝通的橋樑。因為我們上面已經有require了，這邊只要直接使用他的class就可以： ActiveRecord::Base.establish_connection({ adapter: 'mysql2', encoding: 'utf8', database: 'leisure_development', username: 'your_db_username', password: 'your_db_password', }) 記得資料庫的資訊要設好，否則會連不上。 存入資料庫 這邊用的資料庫要是跟Rails專案同樣的資料庫，才能夠直接讓專案使用。 最後就是依照資料表格式整理成Hash然後把需要的資料包成Hash，我把整段程式碼包成method，這個method 直接回傳商品資料： def parse_page(doc) product_name = doc.css('h2.text-primary').first.text() .gsub(&quot;\\n&quot;,&quot;&quot;) .gsub(&quot;\\t&quot;,&quot;&quot;) price = doc.css('.price h2').first().text.match(/(\\w+)\\$([\\d,]+)/)[2] price_origin = doc.css('.price .strike').first().text.match(/(\\w+)\\$([\\d,]+)/)[2] discount_value = price_origin.to_i - price.to_i tab_content = doc.css('.tab-content') sku = doc.css('.condition li').first.text .gsub(&quot;\\t&quot;,&quot;&quot;) .gsub(&quot;\\n&quot;,&quot;&quot;).match(/：(\\w+)/)[1] return { :name =&gt; product_name, :price =&gt; price, :content=&gt;tab_content, :discount_value=&gt;discount_value, :sku=&gt;sku, :stock=&gt; 100 , } end 接下來我只要用迴圈一筆一筆去送出request拿回html並且找到我要的商品訊息，就可以放進資料庫了，這裡因為不確定商品有幾筆，所以試試看從第一筆到第一百筆抓抓看，記得嘗試抓資料時在迴圈裡面要做例外處理，避免沒有資料而發生錯誤： def run (1..100).each do |product_id| puts &quot;Parsing product id : #{product_id} \\n&quot; product_url = &quot;#{BASE_URL}?route=product/product&amp;product_id=#{product_id}&quot; begin html = RestClient.get(product_url) doc = Nokogiri::HTML(html) product_data = parse_page(doc) Product.create!(product_data) rescue =&gt; exception puts &quot;#{exception.message}&quot; end sleep 0.1 end end 你可以在這裡看到我的網站實作成果。","link":"/2019/02/11/front-backend-travel-6/"},{"title":"前端工程師後端之旅(5) - 資料庫關係設計","text":"為了讓設計時更容易溝通，常常會使用ERD來整理，ERD用圖像化的方式來規劃資料與資料之間的關係，讓開發人員可以對系統架構一目瞭然，如一對多、多對一、多對多等等常見的關係。 Outline ERD類別圖基本介紹 產品資料表 文章資料表 訂單及優惠券資料表 前後台使用者資料表 ERD 基本介紹 ERD 意思是 實體-關聯圖，Entity是用物件導向的class表示一個生活中的實體，關聯則是指資料庫的關聯。因為Ruby本來就是物件導向語言，而Rails又是用ORM對應資料表，所以用ERD可以很清楚的表示資料關係， 我們用一張表格表示一個Class，會長的像下面這樣： ![](https://i.imgur.com/4XYvaIh.png =230x200) 修飾子 表裡面裝的是在class裡面的property，前面使用符號來表示物件屬性的修飾子，分別是： 符號 屬性 + public - private # protected 關係表示 關係 表示 一對多 1-------------1…* ( or * ) 一對一 1-------------1 多對多 需要中介表 產品資料 因為可能會有想讓商品同時出現在兩個或更多個類別清單的情況，所以這邊我採用多對多關聯設計，資料表要實現多對多的話，則要藉由中間一張轉介表來串連： 文章資料 文章跟類別的就比較單純，一個類別可能有多個文章: 訂單資料 由於使用者在結帳時有可能會使用優惠券，所以Coupon跟訂單、以及訂單其他資訊之間必須有一對一關聯： 前台 / 後台 使用者 為了安全性考量，前後台的會員資料表應該要分開，如果共用同一張資料表，後台管理員有機會看到其他管理人的機密資料：","link":"/2019/02/11/front-backend-travel-5/"},{"title":"前端工程師後端之旅(7) - 爬上穹頂的最後一哩路：部署","text":"什麼是部署 所有功能實作完之後，為了讓網站可以被一般使用者看到，我們必須要將程式碼放到一台有網路連接的電腦，只要有跟網路連接，就可以透過IP位址找到網站的所在位置，以前要做到這件事情還必須購買硬體主機等等昂貴的設備。 不過現在已經有許多網路主機商提供雲端虛擬主機的服務，只要花一點相對非常便宜的費用就可以連線到該主機去設定系統並且安裝需要的套件跟程式碼，這個複雜且充滿未知挑戰的最後一步我們稱為「部署」。 Outline 雲端Server 選擇 新增使用者 更新資源庫 安裝mysql 安裝rvm 使用rvm 安裝 並使用ruby 安裝Rails Clone 要部署的專案 安裝 Passenger 跟 nginx Nginx Server設定 參考教學 雲端Server 選擇 基本上這類服務都差不多，最基本就是用價錢跟使用時間來做考量，在這裡我使用的是Google的GCP服務，在GCP剛註冊的會員會給予300塊美金，並且在一年內可以使用，非常適合拿來做練習，而且我記得Google每個人最多可以開五個左右的帳號，一組用不夠…可以開兩個啊 對於怎麼建立一台主機，網路上應該有很多類似的教學，看一下教學應該半小時內可以完成，在此不多做說明。裝完主機後，透過GCP介面提供的指令，應該可以很快讓你從電腦連到該機器。 新增使用者 我們通常不會一直用root去操作跟安裝，而是會新增一個使用者後，在給予最高權限，因為每個帳號有自己個別的資料夾，如此一來可以讓系統比較好維護，而最高權限意味著可以做任何事情，當然包括把自己刪掉，所以在使用上要非常小心。 sudo adduser mujing sudo adduser mujing sudo 切換帳號 su mujing 更新資源庫 我使用的是ubuntu系統，因此新系統安裝完時，最好更新一下系統內預設的套件管理器： sudo apt-get update 安裝mysql 這個Rails專案是搭配mysql資料庫開發的，因此必須安裝： sudo apt install mysql-server 如果是在unbuntu上使用mysql 的話記得多裝個mysql client : sudo apt-get install libmysqlclient-dev 安裝rvm rvm 是Ruby 語言版本的管理套件，可以讓你在不同版本之間快速切換，方便管理： curl -L https://get.rvm.io | bash 使用rvm 安裝 並使用ruby 使用的ruby是2.4.1 ，可以根據需求安裝不同版本 rvm install 2.2.3 設成預設 rvm use 2.4.1 --default 安裝Rails 走了那麼多步驟，終於可以安裝Rails啦 gem install rails --no-ri --no-rdoc Clone 要部署的專案 把程式碼從git server 下載到這台主機上，一般會放在github， 如這個專案的程式碼位置 https://github.com/moojing/rails-cart 下載完之後記得進入專案資料夾下 bundle install 指令，安裝專案所需要的套件，並透過rails指令把資料表產出來，記得專案裡面database.yml的資料庫使用者帳號密碼要設定對，否則會連不上Sql Server： bundle install rake db:create rake db:migrate 安裝 Passenger 跟 nginx Nginx 是一套http Server，可以讓管理者設定許多網頁相關的功能，我們這裡只需要最簡單的監聽某個port，可以讓資料跟外面溝通就行。 Passenger可以想成是Nginx的擴充模組，透過設定，讓你再啟動Nginx時一起把Rails 開起來，透過Nginx監聽某port，來與外界傳送資料跟溝通。 安裝以上兩個工具基本上不會很複雜，Passenger已經寫好教學等你去看了，只要照著操作就能安裝完Nginx跟Passenger: https://www.phusionpassenger.com/library/install/nginx/install/oss/xenial Nginx Server設定 安裝完之後開啟nginx 設定檔 sudo nano /etc/nginx/nginx.conf 應該可以看到passenger幫你加入這兩行，把註解打開就行： # passenger_root /usr/lib/ruby/vendor_ruby/phusion_passenger/locations.ini; # passenger_ruby /usr/bin/ruby; 由於nginx預設監聽80port，所有Server都是預設80port，平常你上網直接打網址的時候其實就是對到80port， 而且Server的port同時只能被一個程序佔用，所以如果想讓80port空下來，我們必須改掉他預設的設定： 打開下列的檔案，這裡是nginx預設的設定檔 sudo vim /etc/nginx/sites-available/default 把 listen 80 default_server;相關的設定註解掉: ＃ listen 80 default_server; ＃ listen [::]:80 default_server ipv6only=on; 在同樣的資料夾新增一個屬於你網站的設定檔： sudo vim /etc/nginx/sites-available/mysite 放入相關設定: server { listen 80 default_server; server_name http://34.80.215.175; //如果沒有domain 就放網址 passenger_enabled on; //passenger 設定，要有才能串連rails passenger_app_env development; // 環境變數 root /home/rails/rails-cart/public; // 你的rails專案資料夾的public } 設定軟連結， sudo ln -s /etc/nginx/sites-available/mysite /etc/nginx/sites-enabled/mysite 然後再重啟Nginx Server 就大功告成： sudo service nginx start 終於成功了！系統部署一般屬於DevOps的工作，當然以上都只用到非常基礎的知識而已，DevOps領域可說是博大精深，學也學不完，這只能算是淺嘗輒止，總之你可以在這裡看到我的實作成果。 參考教學 Luka’s notes - Deploy Redmine to VPS by Rails way in Ubuntu 14.04 How To Deploy a Rails App with Passenger and Nginx on Ubuntu 14.04","link":"/2019/02/11/front-backend-travel-7/"},{"title":"JS 原力覺醒 Day01  - 開始修行之前","text":"從開始學習 JS 到現在的約莫一年內，我陸陸續續看了許多相關書籍，也在需要特定知識的時候參考有關的文章，但是我認為自己還沒有對這些知識做系統性地整理過，所以我決定開啟這個系列的撰寫並藉由鐵人賽推動自己完成它，內容涵蓋變數提升、 this 、Class 語法糖、圓形鍊、記憶體運作、閉包…等我覺得 JS 學習者必須要會的東西，這個系列不會從如何撰寫基本語法開始說明，你讀完也不會變成大師，但是如果你是想更深入學習的初學者，希望這個系列能夠帶給你一些啟發，並知道要從哪些概念開始學習起。這個系列適合：介於 Junior 與 Senior 中間的 JS 開發者 、以及閒閒沒事想複習一下的 JS 工程師們。 我們在使用 JS 的時候最常感到頭痛的應該就是那些充滿疑雲的奇怪現象（想想那個「為什麼不能動 / 疑？為什麼可以動？ 」的笑話 ），然而我想這些無法依照常理來理解的現象也正是讓這個語言變得有趣的主要原因。其實理解 JS 底層運作方式以後，這些魔法也就沒那麼可怕了，希望能夠藉由這個系列讓自己對 Javascript 了解得更透徹，也帶給往後想要深入鑽研 JS 的初學者一個比較具體的認知。 在內容的選擇上，我會根據最近找到的 33 Concept Github Repo裡面提供的一系列資源，挑選我認為想要靈活運用 JS 的話一定要會的基礎知識，並且搭配像是、Udemy 知名的 「 理解奇怪的部分 」、六角學院的 「 JS 深入核心 」系列等含金量比較高的線上課程內容來做補充或是輔助說明。 詳細的大綱會根據本人的撰寫速度來做調整，因此會等全系列完成之後再行整理上來，敬請讀者們見諒，但大致上可以分為三個部分： 階段一 - To See The Force （ Day02 ~ Day 10 ）： 在這個階段我會提一些 JS 比較常見的預設行為和專有名詞如自動轉型、提升、純值…等，可能也是最常讓人產生疑惑的部分，有的開發者可能常常碰到，但如果沒有特別深究，就容易被忽略或遺忘。 階段二 - To Feel It （ Day11 ~ Day21 ）： 這部分會有比較深入的概念解說，我認為像是 Class、原形鍊、Event Loop 、Closure…這些也是 JS 最為核心的概念部分。 階段三 - Bring Everything Together ( Day22 ~ Day30 之後)： 前兩階段對於我來說都是有使用過並且大概了解，但是無法完整描述的知識，剛好藉由鐵人賽來做一個整理。在最後一個部分的內容會比較偏向整合性內容，我想要運用前面所學，組合之後昇華，去接觸以前比較沒有機會思考或是使用到的知識。 接下來就讓我慢慢帶領各位前進吧，在一些比較抽象的概念上，我會盡量以圖文的方式來解說，不過你可能要還是要有點心理準備，就算是這樣，這還會是一趟漫長的旅程。畢竟不管是哪一門程式語言，在學習之路上都沒有迅速的捷徑，端靠慢慢累積經驗跟不段的促進自己思考，一起加油吧。最後僅此獻給各位讀者： If you choose the quick and easy path , as Vader did. You will become agent of evil. &quot; - Yoda","link":"/2020/01/01/iron30-1/"},{"title":"JS 原力覺醒 Day010 - 自動轉型 （Coercion）","text":"當 JS 想要對兩個不同型別的數值做運算時， 這兩個數值必須都是同一種類型。這時有兩種方式來達成轉型，一種是使用 JS 內建的方法，像是 toString() 方法來達成；另外一種方法是，如果開發者沒有主動使用 JS 的轉型方法，那麼 JS 就會「貼心」地自動幫你轉型。上述提到的兩種方法，前者稱為「明確的」轉型、後者則是「隱含的」轉型。 Outline 強制轉型 ： 明確？不明確？ 轉為字串的轉型 轉為布林的轉型 轉為數字的轉型 物件的強制轉型 強制轉型 ： 明確？不明確？ 當開發者明確的告訴 JS 要轉型的意圖時，例如使用 Number(‘2’)，這個動作就稱為「明確的」強制轉型。而也因為 JS 是弱型別的語言，所以數值型別本來就能夠自由地轉換，因此有了「隱含」的轉型的現象出現。雖然「隱含的」轉型聽起來，可以交給 JS 處理就好，什麼事都不用做。不過很可惜，這件事情在後人看來，似乎反倒造成許多不必要的困擾與誤解，因此通常不建議使用。 強制轉型只有三種類型： 轉為字串 轉為布林值 轉為數字 另外，提醒一下純值（ Primitive ）與 物件型別的強制轉型的運作邏輯不太一樣，（細節後面會提到），不過不管是哪一種類別都能夠執行上面的三種轉型方式，接下來會分別對上述幾種轉型方式做說明。 轉為字串的轉型 明確強制轉型：要將字串明確的轉型，可以使用 String (‘2’) 。 隱含強制轉型： 當使用到 ‘+’ 運算子的時候就會觸發隱含的轉型。 String(123) // 明確地 123 + '' // 隱含地 而所有的其他類型純值的轉型，你應該都能夠正確預測出來 ： String(111) // ---&gt; '111' String(-12.3) // ---&gt; '-12.3' String(null) // ---&gt; 'null' String(undefined) // ---&gt; 'undefined' String(true) // ---&gt; 'true' String(false) // ---&gt; 'false' Symbol 的部分目前有點怪異，只能夠通過明確的轉型來執行，如果你企圖使用 ‘+’ 運算子想要達成隱含的轉型，就會失敗： String(Symbol('my symbol')) // 'Symbol(my symbol)' '' + Symbol('my symbol') // Cannot convert a Symbol value to a string 轉為布林的轉型 明確強制轉型：布林數值的強制轉型跟字串很像，也是使用 Boolean() 方法來轉型。 隱含強制轉型：則是透過邏輯運算子以及像是 if 判斷式內的條件區塊來觸發： Boolean(2) // 明確轉型 if ('yeah') { ... } // if 或 while 等陳述式條件區塊 2 || 'hello' // 邏輯運算子觸發 !!2 // 邏輯運算子觸發 Boolean 值不管再怎麼轉型，最後都只會有兩種結果，其中有一些值一定會被轉型為 false ，JS 裡面用 falsy value 來描述那些必定會被轉型為 false 的數值，這部分在下一章節會有額外說明： Boolean('') // false Boolean(0) // false Boolean(-0) // false Boolean(NaN) // false Boolean(null) // false Boolean(undefined) // false Boolean(false) // false 那麼我們要怎麼判斷哪些值會被轉型為 true 呢？ 很簡單：除了 falsy value 以外的值就會被轉為 true ，所以只要搞清楚上述幾種情況即可，以下舉例被轉型為 ture 的情況（ Trusy Value ）: Boolean({}) // 空物件也是 true ! Boolean(function() {}) // function 也是物件喔！ Boolean([]) // 空陣列也是物件喔! Boolean(Symbol()) // true !!Symbol() // true 盡量使用「全等於」 ( ‘===’) 這邊提醒一下，在比較兩個數值時，盡量使用三個等號來判斷，而不是兩個。當你使用三個等號來判斷時，除非兩邊的型別與值都完全相同，否則結果一定會是 false ，這時候因為不會有需要轉型的情況發生，減少了許多誤判與產生 bug 的機會。 轉為數字的轉型 明確強制轉型： 數字的明確轉型也跟布林以及字串的轉型差不多，使用 Number(‘12’) 就能將其他類型轉為數字。 隱含強制轉型： 數字的隱含轉型也是透過運算子觸發，不過因為常常牽扯到運算，因此會有比較多種情況需要說明： 比較運算子 ( &gt;, &lt;, &lt;=,&gt;= ) 移位運算子 （ bitwise operators : | &amp; ^ ~ ) 算數運算子 (- + * / % )，這邊要記得，當使用 ‘+’ 來計算結果的時候，只要其中一個數值是字串，那麼就不會觸發數字類型的隱含轉型（ 會轉為字串，這是 JS 的規則 ） 單純使用 + 來做數字轉型（ ex. 在任一其他類型最前面加上 ‘+’ ） 寬鬆的數值比較（ == 及 ==） Number(‘123’) // 明確的 +‘123’ // 隱含的 4 &gt; ‘5’ // 隱含的 1+null // 隱含的 123 != ‘456’ // 寬鬆的數值比較 來看一下各種純值類型是怎麼被轉成數值的： Number(123) // 123 Number(&quot; 12 &quot;) // 12 Number(&quot;-12.34&quot;) // -12.34 Number(true) // 1 Number(null) // 0 Number(false) // 0 Number(&quot;\\n&quot;) // 0 Number(&quot; 12s &quot;) // NaN Number(undefined) // NaN 可以看到上面當我們想將含有空白的字串 ’ 12 ‘ 做強制轉型，卻沒有失敗。這是因為 JS 在做轉型之前，會先幫我們把字串的頭尾空白都消除掉（ trim ），所以不會報錯。但是如果這個處理過的字串還是無法被轉為數字，那麼 JS 就會回傳錯誤而中止。 比較特別的部分還有，null 會被轉型為 0 而 undefined 會被轉成 NaN （ Not a Number ) ，這是 JS 的規則，我覺得知道就好沒必要特別背起來。Symbol 類型，則不管透過哪一種方式，都無法被轉為數字，所以都會報錯。 物件的強制轉型 當你把物件與運算子一起使用時，JS 必須先把物件都轉為純值，才有辦法做運算，得出最後結果，這時就需要探討物件轉型的規則了。 物件轉布林值 最簡單易懂的部分是物件轉為布林值的邏輯，對物件轉型為布林來說，任何非純值類型的數值，都會被轉為 true。 物件轉字串與數字 對於物件被轉為數字與字串的部分，JS 使用一個叫做 ToPrimitive 的演算流程，這個流程分別使用 toString() 與 valueOf() 搭配整個物件當作此方法的輸入值來判斷結果。由於這兩個都存在於 Object 原型鏈上，所以所有是物件類型的值 ( Object 的後代 ) 都可以呼叫，也可以透過複寫來自定。 通常物件都會有預設的 toString 方法 ，但沒有預設的 valueOf 方法。例如你如果宣告一個物件變數，然後直接呼叫其上面的 toString() 方法，就會得到 「 [object Object] 」，的結果，這是因為，物件預設是以 typeof 的結果來當作回傳值。 let a = {} a.toString() // [object Object] 詳細說明可以參考 MDN 官方文件 簡單介紹一下 ToPrimitive 運作流程 如果輸入值已經是純值，那麼直接回傳這個值。 試試呼叫這個數入數值 （這個物件／陣列）上的 toString 方法，如果結果是純值，則回傳。 試試呼叫這個數入數值 （這個物件／陣列）上的 valueOf 方法，如果結果是純值，則回傳。 如果執行前兩個方法都沒辦法得到純值的型別，就會報錯 （TypeError）。 上面有提到執行 toString() 與 valueOf() 的部分，若 JS 判斷需要轉為數字，則優先執行 valueOf 方法，若失敗才轉為執行 toString ，反之若需要轉為字串則相反，依照上述原來的順序。 //會使用到陣列內建的 toString 方法，將所有陣列值都轉為字串 [1]+[2,3] // &quot;12,3&quot; 結論 好，經過這麼多複雜跟瑣碎的說明，恭喜你看到這裡，現在你知道： 轉型有幾種類別：分別是轉為字串、數值跟布林 轉型可以透過兩種方式：明確的 ( explicit ) 以及隱含的（ Implicit ） 必要時物件也會被強制轉型，且是透過 ToPrimitive 演算流程來判斷結果 判斷兩值是否相等時，盡量使用（全等於）三個等號來判斷 判斷布林值的轉型時，只要不是 Falsy 的值，就會被轉型為 true 雖然強制轉型很複雜而且繁瑣，而且我覺得只要只用全等於就能夠過減少一半的錯誤發生機率，但只要寫程式夠久，總會有需要看髒 Code 的時候。知道有轉型這件事情以及為什麼會發生，對之後要 debug 一定會有幫助。謝謝你看到這裡，那麼，在下一章節，我會針對 Trusy ，跟 Falsy 做一個比較詳細的整理。","link":"/2020/01/02/iron30-10/"},{"title":"個人技術站一把罩！部落格建置大全（二）- 將 Github Page 串上自己的域名","text":"上週提到了使用 Hexo 這個工具來架設個人部落格，並放到自己 Github Page 上的方法。這次我們要來看看怎麼把架好部落格的 Github Page ，串上自己擁有的域名( ex. blabla.com ) ，所以在這篇文章內將會對 DNS 與相關設定有一定部分的講解跟介紹。有興趣的人可以先用 https://www.cowboybebop.space/ 來觀看設定完成的結果，這個域名應該還會保留 1~2 個月左右。 Outline 域名購買與域名商介紹 什麼是 DNS ? A Record 與 CNAME A Record 與 CNAME 設定 Github Page 的域名設定 總結 參考資料 域名購買與域名商介紹 首先在開始進行串接之前，你要先有域名，而域名可以透過域名商來做購買，這些域名商有很多，相同域名在不同商家的價格也會不太ㄧ樣，或是某些域名只能在某些域名商買得到，這邊推薦幾個我自己用過的：Gandi、網路中文、Google Domains 。這篇文章會用 Gandi 來做示範，但其實這些網站上購買的流程都差不多。 在網站上購買完域名之後，就可以在 Domains 頁面看到自己擁有的域名。點擊進入各個域名就可以前往個別的設定頁面，今天會以我之前買的多出來的域名 cowboybebop.space 為例。 找到 「 DNS Records 」的分頁，會看到很多，會看到一堆很像神秘魔法咒語的設定值，今天不會逐一介紹，但這邊我們有必要先了解一下什麼是 DNS。 什麼是 DNS ? DNS (Domain Name Server) ，直翻成中文是網域名稱伺服器，可以理解為「負責處理域名的伺服器」，為什麼域名還會需要處理呢？我們在使用網際網路瀏覽網頁時所看到的內容，其實是從你使用的裝置（手機、電腦或平板）連出去對另外一台裝置（也就是伺服器）索取回來的。而兩者之間的溝通，則是以 IP 位址來找到正確的伺服器，IP 位置就像現實世界的門牌地址ㄧ樣，讓其他人可以順利找到對應的位置。 但是我們每天經常使用的網站這麼多，像是 Facebook 、Gmail 、Dcard、Slack，如果世界上所有的網站，都使用 IP 位置來做位置的辨別，那麼你可以想像，我們可能要熟記好幾種數字組合才能夠維持正常的生活。 DNS 的出現就是為了解決這個問題，如同我們現在在生活中所經歷的，只要在搜尋列上輸入 facebook.com 就能夠快速前往臉書的網站，這是因為 DNS 透過給每個 IP 位置取個名字，把這些原本只有電腦能夠理解的位置數據，變成人類也很好記憶、理解的名稱，讓各種網站應用能夠更加融入我們的生活中。 A Record 與 CNAME DNS 相關的設定其實有很多，我們就是透過這些設定來告訴 DNS 如何將域名配對到正確的 IP 位址。今天會介紹其中最常會碰到的兩個設定值： A Record : A 代表 Address ，也就是紀錄 IP Address 與網域名稱的配對，這個紀錄是在設定 Domain Name 時最重要的項目。 CNAME ： CNAME 是網域名稱的別名，用來將子域名指向另外一個主機的域名，最常見的就是將 www.abc.com (子域名） 指向 abd.com（購買的主域名） ，避免使用者因為意外而找不到網站（夠買主域名後，就可以從域名商的設定後台，新增子域名，是不需要另外付費的）。 ALIAS : 與 CNAME 記錄很相像，差別在 CNAME 別名只能用於子域名，而 ALIAS 記錄能夠用在主域名，但這麼做會影響對主域名的域名解析，所以不能與 A 紀錄同時使用。 在了解什麼是 A Record 與 CNAME 與 ALIAS 之後，就讓我們繼續往下設定。要達到串接域名的效果其實不只有一種方式，為了幫助理解以下提供兩種可能的方案。 方案一：直接透過 A Record 設定 因為今天的目標是要將自己的域名可以接到 Github Page。如果只是單純的想要把主域名 ( cowboybebop.space ) 串到 Github Page 上，只要將它指向 Github 伺服器 的 IP ，也就是： 185.199.108.153 就可以讓域名順利解析為 Github 主機的位址了，這部分的相關資訊可以在 Github 官方說明文件內找到。而因為我們不只要找到 github.io 還要找到我們的個人頁面 moojitsai.github.io ，這部分必須在 Github Page 的 Repo 內做對應的設定，會在接下來的內容中提到。 方案二：CNAME 搭配 ALIAS 設定 設定 CNAME 的目的是因為有時候我們希望使用者是透過加上 www 前綴（www.cowboybebop.space ) 的網站域名進入我們的網站，在這種情況下只要用戶不記得或不知道要輸入 www. 前綴，就會沒辦法順利找到我們的網站應用，所以我們必須要將這些用戶重新導向到我們想要的域名。 通常會在域名前面加上 www. 當作網站位置是為了提醒用戶，這是一個公開的網站，藉此提升體驗。但其實加或不加，並不影響網站的功能性，只要有對應正確的設定即可，因為加上了 www. 前綴的域名，相對於主域名來說只是子域名而已，只是站在 SEO 或是追蹤流量的角度，一般還是建議兩種方式選一種（要不要加上 www.) 並且統一使用，否則 Google 爬蟲會將這兩種域名視為兩個不同的網站。 在方案二中，我想要以將原來沒有 www. 前綴的主域名統一導向到有 www. 前綴的子域名的方式來完成： cowboybebop.space/ -----自動導向到-------&gt; www.cowboybebop.space/ 就像上面提到的，ALIAS 記錄可以用在主域名的別名設定，這個設定剛好可以達成上面提到的導向到具有 www. 前綴域名的效果。因此我們要這麼做： 將主域名的 ALIAS 設為加上 www. 前綴的子域名 將加上 www. 前綴的子域名， CNAME 設為 Github Page 的 URL 提供下圖做為參考，只要看第一跟最後一筆紀錄就可以了，其他是系統預設的設定。 透過這樣的方式，我們就能夠完美的將有 www. 與沒有 www. 前綴的域名都導向到 Github Page 頁面囉！而且統一使用的會是 www.cowboybebop.space，也符合前面提到的建議使用方式！ Github Page 設定 在 Github Page 對應 Repo 內的 Setting 頁面裡的 「 GitHub Pages 區塊」，可以看到 Custom Domain 欄位，在這邊我們必需告訴 Github 我們想要將自己的 Github Page 與哪一個域名串接，才能夠讓我們自己的域名，正確對應到原來個人的 Github Page Url。 設定完之後，記得把 「Enforce Http」的設定打勾，這樣一來，我們的域名就自動有了 https 憑證，不需要在自己簽發，因為 Github 幫你做掉了，這個功能超方便！ 設定完成後應該可以在 https://www.cowboybebop.space/ 看到頁面了！ 總結 域名相關的設定對於網頁相關工作者來說，初期並不是那麼容易了解，因為其中還有許多細節跟環節，像是 DNS 相關的設定也不只有今天介紹的三種，還有其他適用於特殊使用情境的設定，只不過比較特定。像是 ALIAS 紀錄我也是在寫這篇文章的期間才發現，並知道怎麼設定的。 而因為每次 DNS 設定更新之後，必須等待 DNS 伺服器解析後才會生效，因此來來回回也失敗了好幾次才終於達成目標，這部分是我覺得最麻煩的。也感謝我的顧問團隊 Max 的幫助。那麼這個 Github Page 的部落格系列就暫時到這邊，希望大家都能夠有記錄自己成長過程的專屬頁面囉，那麼就下次見，有發現什麼有趣的東西再來跟大家分享！ 參考資料 Managing a custom domain for your GitHub Pages site CNAME 紀錄 為什麼越來越多的網站域名不加「www」前綴？ 我室友 Max","link":"/2020/02/23/hexo-github-page-2/"},{"title":"JS 原力覺醒 Day11 - Falsy / Truthy","text":"上一章節的強制轉型，在布林值轉換的部分有提到 Truthy 與 Falsy ，這個特性我們應該常常碰到，至於背後的運作邏輯如何，今天就讓我們來看看吧： Outline 使用布林值自動轉型的情境 Falsy Truthy 嚴格比較與寬鬆比較 布林值自動轉型的情境 再有多重條件的情況下，那我們寫程式的時候常常用到這樣子的寫法： if(isTrue) { // if isTrue is equal to true } else { isTrue) { // if isTrue is equal to false } while(isTrue){ // if isTrue is equal to true } isTrue ? true : false 邏輯判斷是大概是 JS 裡面最常用到的語法了，而因為 JS 是這個寬鬆靈活的語言，甚至我們寫在判斷式括號內的數值都不一定要是布林值，也可以是物件或字串。因為裡面的值會被 JS 自動轉型，這有點像是用兩個等號來做的寬鬆比較： if(isTrue) //is like isTrue == true 至於邏輯區塊裡面的數值是依照怎麼樣的規則被轉型成為布林值，那就是我們需要探討的部分。 Falsy 在 JavaScript 裡面，每個數值都有其對應的布林值，也因而形成了接下來要提到的轉型邏輯，其在轉型的情況下，ㄧ定會被判斷為 false ，也就是說，與 false 等價，讓我們先來認識一下： 0 NaN '' (空字串) false null undefined Truthy 至於 truthy ，情況就比較多了，到底有多多呢？可以用一句話來解釋：「 除了 falsy 以外的值都是 truthy 」，也就是說只要知道上面 falsy 的值有哪些，就可以知道 truthy 的值有哪些囉！ 下面都是 truthy 的狀況： '0' ( 一個內容為 0 的字串 ) 'false' ( 一個內容為 false 的字串 ) [] ( 空陣列 ) {} (空物件) function(){} (空函式) 嚴格比較與寬鬆比較 上一章節為什麼說要盡量使用全等於，這邊說明一下，因為使用兩個等號 == 來比較的時候會觸發自動轉型，而其中就會有比較複雜的轉型邏輯，所以你會比較難以判斷比較的結果。我的建議是，盡量在你需要比較某數值的時候使用全等於（===），也就是嚴格比較，而只在需要判斷某物件是否存在時，才依賴自動轉型。 附上使用兩種判斷方式，分別會產生的結果值，你就會知道為什麼 (圖片來自這個 Repo)： == === 可以看出如果使用全等於，除非等號兩邊的數值完全相同，不然不可能得到 true","link":"/2020/01/05/iron30-11/"},{"title":"JS 原力覺醒 Day12-   傳值呼叫、傳址呼叫","text":"今天要談的是另一個 JS 裡面很重要的特性，我們在做變數宣告與赴值時， JS 引擎是如何為我們保留記憶體位置的？還記得前面有提到 JS 裡面概括可以分為兩大類別：「物件型別」、「原始型別」嗎？這兩種型別，在變數操作時，記憶體位置的運作方式各有不同。 Outline 原始型別的傳值呼叫 ( Call By Value ) 物件型別的傳參考呼叫 ( Call By Reference ) 補充：Call By Sharing 原始型別的傳值呼叫 ( Call By Value ) 原始型別的記憶體位置是透過「傳值呼叫（ Call by Value ）」的方式來傳遞。那具體來說是怎麼運作呢？我們都知道變數在被宣告的時候，引擎會為我們預留記憶體空間（還記得什麼是「創造階段」嗎？忘記可以往前看），接著這個變數就會被赴值成為我們預期的變數內容。我們姑且稱一個被指派純值的變數為純值變數。 上面我們透過宣告，產生一個變數， var a = 12 ，接著再把 a 指派給另外一個變數 b ，所以現在 b 的值應該與 a 相同。但是 JavaScript 引擎知道這是一個純值之後，就會幫我們另外創造記憶體空間，而就算我們修改 b 的內容，a 也不會受到影響，兩者之間是完全沒有關聯的。 b = 21 console.log(a) //12 console.log(b) //21 物件型別的傳參考呼叫 ( Call By Reference ) 當一個變數被賦予物件型別時候，這個物件實際上並非存在該變數裡面，而是被存在某個位置，既然是「位置」當然有地址，就稱為該物件存放的記憶體位置，而存在這個變數內的就是這個「記憶體位置」。因此這個「以記憶體位置為參考」而在變數間傳遞的存取行為，就稱為「傳參考呼叫」。 現在我們「傳值」所傳遞的是「數值的複製」，而「傳參考」所傳的則是「記憶體的參考位置（ 我要去哪裡找這個物件？ ）」。那傳參考呼叫跟剛開始提到的傳值，在行為上會有什麼不一樣呢？ 當我們像剛才那樣新增了一個 a 物件變數，然後再把 a 的值傳給另外一個變數 b ，這時候有一個很重要的問題：「 a 裡面存的值是什麼？ 」還記得剛剛提到，是記憶體位置嗎？所以我傳給 b的時候，傳的正是記憶體位置。 因此如果後面我修改了 b 內容的值， a 理所當然的也會被改變，因為他們指的，是同一個物件。 補充：Call By Sharing 如果你多讀幾篇文章，可能會發現有的文章會說「JavaScript 是 Call By Sharing 」。「 Call By Sharing 」這個詞因為定義曖昧，模糊不清的關係，並不被廣泛地使用。「Call By Sharing」也有「 Call By Object-Sharing 」之稱，看到這個詞有沒有覺得跟「 Call By Reference 」意義很像？事實上，還真的有點像，但這個詞的定義更模糊。什麼意思呢？我們先來看看一個與 function 有關的經典例子： let jediList = ['Anakin' , 'Luke' , 'Ahsoka'] function addFellow(list){ list.push('Yoda') } addFellow(jediList) console.log('jediList',jediList) 我在這個裡面做了幾件事情： 在全域宣告陣列以及一個函式 把這個陣列傳入函式裡面 修改這個函式被傳入的陣列 回到全域執行環境，發現剛剛宣告的陣列在函式執行後也一併被修改 為什麼會這樣呢？這就要先提到函式的參數，其實在參數被傳遞進函式的時候，會重新創造一個變數，然後把參數的值丟進這個變數裡面。不過 因為 Call By Reference 傳參考的特性，如果傳入的值是物件，那麼雖然函式試圖創造新的變數與外部環境做區隔，但是指派給這個新變數的值仍然會是「記憶體位置」！因此在這個情況下，函式內對 argument 做的修改，是對傳入物件參考的修改，連帶也會影響到全域環境下的 list 陣列值。 上面是當傳入函式參數是物件型別的情況，但是如果這個參數是原始型別，那麼情況又不同了，還記得原始型別在不同變數之間傳遞時的行為是「傳值」嗎？也就是「數值的拷貝」，所以就不會有上述修改到物件參考的奇怪情況： 好，上面兩種情況正好運用到今天的兩個重點「傳值呼叫」與「傳參考呼叫」，我們回到剛剛的程式碼，現在，為了討論 Call By Sharing 與 Call By Reference 的差異，我稍微修改一下程式碼，你可以思考一下結果回有怎樣的不同： let jediList = ['Anakin' , 'Luke' , 'Ahsoka'] function addFellow(list){ //somebody bad wants to change the result. list = ['nobody'] } addFellow(jediList) console.log('jediList',jediList) // ['Anakin' , 'Luke' , 'Ahsoka'] 如何？ 根據剛剛的原則，傳入參數是物件，那麼我對這個物件作修改，就會影響到全域環境傳進參數的陣列內容，所以最後 console 出來的結果就是 ['nobody'] 囉？並不是！答案是維持原來的 ['Anakin' , 'Luke' , 'Ahsoka'] ，也就是說在函式內的修改並沒有影響到這個全域變數。 這裡有一個關鍵差別是在做 list = ['nobody'] 的時候，是指派一個全新的陣列物件給 list 變數，JS 知道這點之後就會為這個變數創造一個新的記憶體空間，然後把新指派的陣列存進去，而不會直接修改到外部傳進來的變數，造成連帶影響，這個創造新空間的行為，其實有點像是 Call By Value。 也就是說，雖然透過記憶體位置參考，函式內被傳入的參數，有能力影響 / 修改到外部環境傳進來的變數，但是已經被宣告的物件無論如何都不會因為對這個變數的修改而被消滅。 在看完 wiki 以及數篇文章的說明後，我認為上面的描述就是 Call By Sharing 與 Call By Reference 最大的不同，我相信看到這裡的你應該已經能夠了解它與「記憶體位置」脫不了關係。而 Call By Sharing 則在 Call By Value 與 Call By Reference 兩者之間有著曖昧模糊的地位 - 已經不單純取決於型別，而端看你對變數操作的行為。 結論 今天我們了解了基本的 Call By Value 與 Call By Reference 兩種行為，兩者在 JS 環境內所發生的時間點，Call By Value 發生在當指派給變數的值是純值時，而 Call By Reference 則發生在物件型別。最後，我用一個函式的範例，針對一個比較特殊的名詞 Call By Sharing 做了解說。 你在別的語言可能也會看到以上這些名詞，甚至，在某些語言裡面相同的名詞的意義也完全不同（ 如 Call By Reference ) 。但那不重要，在這個篇幅內，我希望看到最後的你，能夠了解 JS 變數與記憶體的關係與運作方式就好。","link":"/2020/01/05/iron30-12/"},{"title":"JS 原力覺醒 Day13 -  Event Queue & Event Loop 、Event Table","text":"我們越來越深入 JS 運作方式的重要部份了，今天要提到 「 Event Loop 」的概念，這是 JS 最獨特的地方，幾乎沒有其他語言有這個特性。 Outline Parts Of JavaScript Engine Event Queue Event Queue 運行流程 Event Table Event Loop Parts Of JavaScript Engine 之前提到過「 執行環境堆疊 」，函式呼叫時會產生執行環境，若在這個函式執行環境內還有其他函式被呼叫，就會在之上產生另一個執行環境，形成堆疊。而在上層的執行環境結束之前，下層部分的其他程式碼是無法被執行的 — 包含全域執行環境。 因此，只要在這之中某個堆疊執行過久，就算只有一個函式執行環境的堆疊，都有可能影響整個主程式（ 全域執行環境 ）的運行。不過應用程式裡面總是會有某些功能需要時間來提取 / 運算，這時候為了不讓整個主程式停下來等待太久，我們可以而且其實我們很常把這些比較耗時的工作放到主程式以外的另外一個部分去執行。 而在進入正題之前，必須先複習一下，前幾章節我們提到， JS 引擎底下有三個部分： 「 記憶體堆疊」 「全域執行環境」 「執行環境堆疊」。 然而瀏覽器內可不只有 JS 引擎，接下來我們要提到一個很重要的概念 — 「 Queue 」（又稱 Message / Event / Callback Queue ）。 整個瀏覽器的運行環境並非只由 JS 引擎組成。因為 JS 語言特性屬於單執行緒，同時又為了讓網頁具有像「監聽事件」、「計時」、「 拉第三方API 」這些類似「背景作業」的功能，瀏覽器提供了另外一些部分來達成，分別是： Event Queue Web API Event Table Event Loop 整個由上述部分，包含 JS 引擎所組成的環境，也稱為 JS Runtime Environment ( JRE ) Event Queue Queue （儲列）是什麼樣的概念呢？ 我們先來看一下，在寫網頁程式的時候，有一些所謂「內建的」API 如 SetTimeout / setInterval ，這些 API 不存在於 JavaScript 原始碼內，但你仍然可以在開發時直接使用。因為這些 API 是屬於瀏覽器提供的 Web API 。Web API 並非 JS 引擎的一部分，但他屬於瀏覽器運行流程的一環。 關於 Web API ，舉一些例子： 操作 DOM 節點的 API 如 ：document.getElementById AJAX 相關 API 像是：XMLHttpRequest 計時類型的 API ，就像剛剛提到的 setTimeout 這類 Web API 在與 JS 原始碼一起執行的時候，並不會直接影響 JS 主執行環境的運行，否則的話網頁在執行像是拉取第三方 API 資料的動作時，就只能乾等，無法執行任何其他事情了！ 所以瀏覽器將這些必須等待執行結果的動作，丟給其他部分去執行，然後讓 JS 引擎可以繼續做他應該做的事情，上述提到要等待執行結果的行為，其實也就是「非同步」的行為。（因為不會一次直接從頭跑到尾做完） 這就是 Event Queue （ 事件儲列 ）的工作了， 事件儲列專門用來存放這些非同步的函式，然後等到整個主執行環境運行結束以後，才開始依序執行事件儲列裡面的函式。而所謂 Queue 是一種「先進先出」的資料結構，與 Stack 的「後進先出」相反，所以先被推送到 Queue 裡面的函式會相對於其他函式優先被執行。 Event Queue 運行流程 下面會以 setTimeout 為例，解說 Event Queue的運行流程。 setTimeout(callbackFunction, timeToDelay) 像是 setTimeout 與 setInterval 這些計時的 API ，是在給定的時間到了之後，執行對應的函式內容。 function executeAfterDelay() { console.log(&quot;I will be printed after 1000 milliseconds&quot;) } setTimeout(executeAfterDelay, 1000) console.log(&quot;I will be executed first&quot;) 但在給定時間到達之後，確切來說也並非是直接執行，而是會等待整個 JS 的執行環境結束， Call Stack 清空了之後，才開始執行。像上面的程式碼，會在一秒後印出對應的 console 內容，但是 JS 引擎在看到 setTimeout 這個函式的時候，並不會停下來等一秒過後才繼續往下，而是會直接往下執行。 而在 JS 引擎繼續往下執行的時候，剛才我們呼叫setTimeout所造成的計時的動作依然在進行，直到一秒到了以後，瀏覽器會把給定的對應的函式推送到 Event Queue 裡面，然後等待主程式運行完畢。 整個流程看起來像這樣： JS 引擎執行到瀏覽器提供的 setTimeout 函式 JS 引擎繼續運行，同時瀏覽器開始根據給定的秒數計時 等待計時完成後，把剛才給定的函式推送到 Event Queue 內 等待 JS 引擎運行完畢，主執行環境結束後，將 Event Queue 內的函式推送到 JS 主執行環境，產生堆疊（執行該函式）。 Event Table Event Table 與 Event Queue 互相搭配的資料集合，他負責記錄在非同步目的達成後，有哪些函式或者事件要被執行，這裡指的非同步目的指的是像計時完畢、API資料獲取完畢、事件被觸發。當我們執行 setTimeout 這個函式時，JS 會把給定的函式與像是倒數的秒數之類的附帶資訊 ( meta data )推送到 Event Table裡面，等到一秒過後（目的達成）該函式就會被正式推送到Event Queue 等待執行。 Event Loop 那麼，什麼又是 Event Loop 呢？可以把 Event Loop 想成是另外一個幾乎無時無刻、每一毫秒都在執行的程式，他負責檢查現在主執行環境堆疊是否是空的？如果是空的，再去檢查 Event Queue ，若 Event Queue 有函式待執行，則將這些函式從 Event Queue 依序推出，並執行。 總結 在這個章節，其實你只要能夠了解 JS 內 Event Queue 的概念，知道setTimeout 內的函式是何時被執行、以及怎麼運作的，就可以抓住我想提的非同步運行方式的重點了，其他像是 Event Loop 、Event Table 都只是概念性的名詞解釋，如果你原本對 JS 的非同步特性不是很了解，希望上面的概念模型圖可以幫助到你。 這邊文章同時也會在 Medium 上的 Publication 分享，上面未來會有囊括 前端 / 後端 / DevOps / 資訊安全等相關的技術文章，如果有興趣歡迎追蹤。","link":"/2020/01/05/iron30-13/"},{"title":"JS 原力覺醒 Day14 - 一生懸命的約定：Promise","text":"上一章節我們提到有一些 JS 的 Web API 會需要在「背景執行」，同時又不影響整個網頁主程式的運行，這些 API 利用瀏覽器 Event Queue 的機制來達成這個目的，也就是所謂非同步的動作。不過難道只有在使用 這些 Web API 的時候，才能使用到非同步的行為嗎？我們有沒有可能讓自己寫的功能，也具有非同步的行為呢？ 答案是，可以的，只是方式不太一樣，如果想要讓自己寫的功能也具有非同步的行為，我們會需要用到今天要討論的主角 — Promise 。 Outline Promise 簡介 Promise : 成敗之間 成功的 Promise : Succeed and then 失敗的 Promise : Catch with an error Promise 概念圖 Promise : 一個生活化的例子 Promise 簡介 Promise 是什麼呢？以語法字面上的意義來看，用比較白話的方式解釋的話有一種：「我承諾幫你做某件事情，能不能成功還不一定，但是我做完之後會把結果告訴你」的意思。 那麼來看看比較技術層面的定義，在官方文件中的定義則是： Promise 是一個代表非同步運作的最終狀態的物件 （成功或失敗） A Promise is an object representing the eventual completion or failure of an asynchronous operation. （MDN) 雖然技術文件的解釋就顯得比較抽象，不過從上面看得出來 Promise 在 JS 裡面是以物件的方式存在，那麼接下來我們就來看看要怎麼使用 Promise 吧，基本的 Primise 宣告方式如下： let promise = new Promise((resolve, reject) =&gt; { // executor code }) 我們以 Callback 的方式來告訴 Promise ，接下來我們定義的非同步函式要做什麼事情，而且也必須跟 Promise 說，做完想做的事情，得到結果後，怎樣的結果算是成功，怎樣的結果算是失敗？這些都會被記錄在這個 Promise 物件裡面，Promise 物件裡面有幾個相關屬性： state （狀態） ：一個 Promise 裡一共會有三種狀態： fulfilled ：成功的狀態 rejected：失敗的狀態 pending ：還在執行中的狀態 result : 執行完 Promise 後的結果值 Promise : 成敗之間 那要定義 Promise 的運行結果？ 你可以看到在 Callback 函式內有兩個引數，分別是 resolve 跟 reject ，就是由 JS 提供、用來決定 Promise 結果狀態時使用的兩個函式 ： resolve 用在 Promise 成功且結果如預期時，呼叫這個函式會把 Promise 的 state 設為 fulfilled ，將執行結果數值傳入這個函式會讓上述提到的 Promise 的 result 設為給定的值。 什麼意思呢？下面的程式碼就是一個 Promise 成功，並且把 result 設為 'Success' 的範例： let promise = new Promise((resolve, reject) =&gt; { resolve(' Success ') }) reject 則與 resolve ，呼叫 reject 會將 state 設為 rejected ，意即失敗。 let promise = new Promise((resolve, reject) =&gt; { if(someValueIwant){ //do other things and resolve }else{ reject(‘Failure’) } }) 成功的 Promise : Succeed and then 寫到這邊有個要注意的重點是，上述提到 Promise 的兩個值 state 跟 result 是沒有辦法直接被取用的，他們只能透過某種方式被取用。所以這邊要講的是 then 函式，then 是指在 Promise 順利執行完成後，要取得結果值的方法。 在前面我們提到，Promise 的 callback 內，我們可以將取得的結果值丟給 resolve 函式，之後我們就可以夠過 .then 來取得這個結果，然後做其他事情。then 函式 一樣接收的是一個 callback ，並且帶有一個參數，這個參數就是 Promise 剛剛計算完的結果，以上述例子為例的話就像這樣： let promise = new Promise((resovlve,reject)=&gt;{ //after some calculation let result = 'value from some where' resolve(result) }) promise.then(result =&gt; { //use result to do something }) 而為什麼要使用 .then 與 callback 的方式呢？因為這樣一來，JS 可以保證這個 callback 在 Promise 執行完之後才被呼叫。 失敗的 Promise : Catch with an error 如果一個 Promise 因為某些原因而被 reject ，那麼上面提到的 .then 裡的 calback 就不會被執行，相反的，他會執行另外一個 callback — 在 .catch 函式內被傳入的 callback。這裡提到的 catch 的用途有點像是在捕捉錯誤時的語法：try &amp; catch 裡的 catch 部分，都是用在錯誤發生時。 let promise = new Promise((resovlve,reject)=&gt;{ //after some calculation let error = 'some error happended!!' if (!result){ reject( error ) } }) promise.catch(error =&gt; { // log the error }) Promise 概念圖 「狀態」的概念對使用 Promise 來說是很重要的事情，那麼讓我用一張簡單的狀態圖來表示運行的順序吧，首先 Promise 會有一段執行的時間，所以直到剛剛說的 resolve 函式被執行之前，狀態都會是 pending ，而在這之後如果 resolve 被順利呼叫，Promise 的狀態就會變成 fulfilled ，否則就會是 rejected： Promise : 一個生活化的例子 前面提到，一個 Promise 會有三種狀態：fulfilled 、reject 與 pending 。其實在我們生活中就常常遇到這樣的例子，那就是提款機啦！回想一下剛才提到的「狀態」，提款機其實剛好就有剛剛說的三種狀態可以類比到 Promise 上面！ 使用提款機送出提款的要求時，會需要等待一段時間，這時候可以看成 Promise 的執行時間，也就是 pending ，那麼在執行完畢後，可能會發生兩種結果：一種是沒什麼問題 ( fulfilled 的狀態 )，提款機就直接吐錢出來 ( then )；另一種是你的餘額不夠，那麼 ATM 直接進入 rejected 拒絕讓你提款，並解顯示錯誤訊息（ catch ）。","link":"/2020/01/05/iron30-14/"},{"title":"JS 原力覺醒 Day15 - Macrotask 與 MicroTask","text":"上一篇針對 Promise 的語法做了一個基本的解說，但其實今天的內容才是我想講的，Promise 的運作邏輯不難理解，但若是 Promise 在整個 JS 以及瀏覽器裡的流程可能就比較複雜了，現在我們都知道幾件事情： 一個 Promise 最終會有兩種狀態 對應 Promise 的不同狀態，會各自觸發 .then 與 .catch 兩個函式 利用 Promise 可以達成非同步行為，而且內容可以自訂 而雖然在上一章節一直提到非同步，但是對於 Promise 裡所謂非同步執行的部分，目前我們還是沒有很明確的解釋，到底是哪一部分會以非同步的方式被執行？以及什麼時候會執行？這是這篇文章想要探討跟說明的。 Outline Tasks Micro Tasks Microtask 與 Macrotask 同時發生的例子 Macrotasks 我們在 Event Queue 章節裡面所提到 Web API 有些具有非同步的行為，而在非同步的目的達成之後，瀏覽器會把給定的對應的函式推送到 Event Queue 裡面，這些一個一個函式正好代表每一件要做的事情，因此在 JS 裡面，以「 Task 」或 「Macrotask 」來稱呼，為了避免混淆，以下將用 Macrotask Queue 來指稱之前提到的 Event Queue 。 關於 Task 有兩個細節可以注意： 以瀏覽器的角度來看，在每一個 Task 結束之前，不會有任何瀏覽器的 rending 產生 如果一個 Task 執行所花的時間過長，那麼瀏覽器就無法執行其他的 Task ，所以過一段時間之後會提出「頁面沒有回應」的警告，建議你關閉這個分頁，這種情況你應該有遇過。 Microtasks Microtask 通常由 Promise 產生，Promise 裡用到的 .then / .catch 函式會以非同步的方式來被執行，回想下 Queue 的概念，所以的非同步行為指的是，會在全域執行環境執行完之後才被執行，因此一但 Promise 的 callback 內容執行完成，狀態再也不是 pending 時，.then 或 .catch 的函式內容就會被推送到 Queue 裡面等待執行，這個被推送到 Queue 的函式就是 Microtask。 相對於管理 Web API 所屬事件的 Macrotask Queue ，Promise 產生的 Microtask 也有自己的 Queue ，在 JS 內被稱為 Job Queue 或 Microtask Queue，而 Job Queue 與 Event Queue 運作方式上有一點不一樣。 差在哪裡呢？在 Queue 裡面的每個 Macrotask 執行完畢後 ，就算 Event Queue 裡面還有其他的 Task，JS 引擎依舊會優先執行 Microtask Queue 裡面的所有 Task ，在這個同時也不會重新渲染網頁，換句話說，Microtask 的執行是穿插在每個 Macrotask 之間，兩者的差異也就在執行順序的不同而已。 Microtask 與 Macrotask 同時發生的例子 如果還是覺得很抽象，下面我會帶個例子，直接用程式碼來比較 Ｍacrotask 與 Microtask 執行順序的不同，應該比較能夠讓你了解，看看下面的程式碼： setTimeout(() =&gt; alert(&quot;timeout&quot;)); Promise.resolve() .then(() =&gt; alert(&quot;promise&quot;)); alert(&quot;global ex. context&quot;); 這段程式碼剛好同時用到 Web API 與 Promise ，各自在呼叫後會產生一個 Macrotask 以及 Microtask ，不過在順序上是哪個會先被執行呢？稍微分析一下： 所有的 Queue 都會等待執行環境堆疊被清空，alert 肯定會先執行 setTimeout 對應的函式會被當作一個 Macrotask ，等待時間到之後被送入 Macrotask Queue Promise 對應的 .then 或 .catch 的函式會被當作一個 Microtask 送入 Microtask Ｑueue 在執行環境堆疊清空之後，通常網頁會先做一次 Render，Render 的動作同時也算是一個 Macrotask 因此推測 alert 的順序應該會像是這樣： &quot;global ex. contenxt&quot; &quot;timeout&quot; &quot;promise&quot; 但是並不是！結果會是 &quot;promise&quot; 比 &quot;timeout&quot; 還要更先被 log 出來： &quot;global ex. contenxt&quot; &quot;promise&quot; &quot;timeout&quot; 這是為什麼呢？這邊可能會有點抽象，前面我們在分析 JS 語法與運作模式的時候，大多是從 JS 引擎的角度出發。而前面也有提到， Queue 的概念並不屬於 JS 引擎的一部分，相對的歸屬於瀏覽器。對於瀏覽器來說，在網頁頁面開啟時，載入對應的 JS 檔並且執行這件事情，也是一個 Macrotask 。 而剛剛提到 Macrotask 執行完畢後，會優先執行 Microtask ，因此你會看到 &quot;promise&quot; 出現的順序先於 &quot;timeout&quot; 。","link":"/2020/01/05/iron30-15/"},{"title":"JS 原力覺醒 Day16 -  Async / Await：Promise 語法糖","text":"Promise 讓我們有一個可以很方便寫出非同步函式的方法，不過像這樣非同步的程式碼對於我們在閱讀或是 Debug 要判斷執行的先後順序上可能會比較不值觀，今天要來介紹一組讓 Promise 程式碼的可讀性大大提升的語法糖：Async / Await。 Promise 語法的問題 Async Await Promise 語法的問題 常常我們在拉 API 的時候會以 Promise 的方式來實作（例如 axios ），而在這個 Promise 裡的 Callback ，如果又想拉取另外一支 API ，就會需要執行另外一個 Promise ， 結果就寫出了難以閱讀的程式碼： let promise = new Promise (( resolve, reject)⇒{ resolve('some value') }) promise.then((value)⇒{ let promise2 = new Promise((resolve,reject)=&gt;{ resolve('value2') }) promise2.then((value2)=&gt;{ ... }) }) 這樣子的寫法可能少少幾行還沒事，但當專案變大之後，如果充滿了這樣子的程式碼，那肯定讓你眼花撩亂，所以我們需要 async / await 來做簡化。 Async async 語法必須寫在函式宣告前面，用來告訴 JS 這個函式是一個非同步的函式，就像這樣： async function asyncFunc() { return &quot;Hey!&quot;; } asyncFunc() // will get a resolved promise. 而用 async 語法所宣告的函式，被呼叫時永遠都會回傳一個 Promise，雖然從上述程式碼看不出來，但是 JS 程式碼會幫你用 Promise 然後包起來回傳給你，就像這樣： function asyncFunc (){ return new Promise((resolve,reject)=&gt;{ resolve(&quot;Hey!&quot;) }) } Await await 只能使用在 async 函式內部，在這之外的地方使用的話就會報錯。在 async 函式內部，如果還有其他非同步的程式碼，例如在裡面寫 Promise ，我們就可以用 await ，去告訴 JS 引擎要停下來等待這個非同步程式碼執行完畢，並且等到 Promise 被 resolve 之後才會繼續往下執行。 async function asyncFunc() { let data = await new Promise((resolve,reject)=&gt;{ // do some calculation resolve('api data') }) console.log(data) //'api data' } 有了 await 之後我們就可以寫出非常容易閱讀的程式碼， async 關鍵字也很明確告訴你這個韓式內有非同步的程式碼，而如果沒有 await 我們原本還需要透過 .then 函式才能拿到 Promise 執行完畢 resolve 之後的值。 更棒的是，如果你的函式內本來有不只一個 Promise 想要依序執行，使用 await 就可以讓你的邏輯以很清楚的方式表現： async function asyncFunc() { let promise1 = await new Promise((resolve,reject)=&gt;{ // do some calculation resolve('api data') }) let promise2 = await new Promise((resolve,reject)=&gt;{ // get res data of promise1 and do some thing resolve('success!') }) console.log(promise2) //'success' } 不過有一個小缺點是因為使用 await 的話，因為 JS 引擎會一直等待 Promise 執行完畢，所以如果過度濫用的話，那就失去非同步的意義了，這點在使用時要多多注意，自己斟酌。 Error Handling 使用 async / await 這個語法糖時，為了讓錯誤處理也變得更簡潔，可以搭配 try / catch 使用： async function asyncFunc() { try{ let data = await new Promise((resolve,reject)=&gt;{ // do some calculation resolve('api data') }) console.log(data) //'api data' }catch(e){ console.log('error',e) } } 結論 async / await 只是一個 Promise 的語法糖，讓你可以更方便寫出非同步程式碼 async 函式一定會回傳一個 Promise await 只能在 async 函式內使用 await 語法會讓 JS 引擎等待 Promise 執行完畢後才會繼續往下","link":"/2020/01/05/iron30-16/"},{"title":"JS 原力覺醒 Day18 - Functional Programming","text":"今天要介紹 Functional Programming （ 簡稱FP ) ，FP 是一種程式設計的思考方式，寫程式寫過一段時間的人幾乎都會聽過這個概念，對某些人來說，想要進入資深階段的話，學習 Functional Programming 是一件不可或缺的事情。 Outline Functional Programming 為什麼要使用 FP 純函式 （ Pure functions ） 複合函式（ Function composition ） 共享的狀態 （ Shared State ) 不變性( Immutability ) 避免副作用（ Side Effect ) Functional Programming Functional programming （ 簡稱FP ） 用比較嚴謹的說法，是一種程式設計方法 ( Programming Paradigm )，意味著他是一種根據某些基本原則來進行開發的軟體架構，聽名字應該可以了解他是以函式為主的開發方式，與之相對的是物件導向程式設計，指的是以 物件（Class）為主的軟體架構。 為什麼要使用 Functional Programming 使用 FP 可以讓程式碼看起來更簡潔，且對功能的描述更精準、所以也就更好進行測試，對開發來說有不少好處，但是如果你對 FP 以及相關的概念還沒有很熟悉，FP 的程式碼也可能讓你需要更多時間來閱讀。 Functional Programming 對初學者來說聽起來可能會有點嚇人，不過如果你是一個有一點經驗的開發者，那麼你可能其實已經使用過 FP 的概念了，只是你不知道而已。在你能夠真正了解什麼是 Functional Programming 之前，有幾個相關的概念必須先理解： 純函式 （ Pure functions ） 複合函式（ Function composition ） 共享的狀態 （ Shared State ) 可修改性 ( Immutability ) 避免副作用（ Side Effect ) 也就是說，如果想要知道 FP 具體來說是什麼的話，就必須了解上述幾個基本概念，在今天的介紹裡面，我會把這些概念依序做簡單的介紹，下面就讓我們一個一個來看看吧。 Pure Function 純函式有很多對 Functional Programming 非常重要的特性，後面有許多進階概念都是基於純函式的概念演變出來的，純函式的特性包含： 同一個輸入純函式的參數，永遠都會回傳相同的結果。 純函式永遠都不會有造成 Side Effect 的操作出現，如 API 拉取、裝置的I/O、或者對函式外部資料的修改。 Functional Composition 複合函式的概念來自數學，是指如何組合兩個以上的函式並依照組合的順序去產生另外一個新的函式，或是做些運算。在數學裡面，我們常常用 f(g(x)) 來表示複合函式，意思就是把 g(x) 運算產生的結果值，傳入 f() 函式裡面 。 JS 之所以也能做到類似的行為，是基於 JS 被稱為「一級函式」的概念。（把函式當作參數傳入另外一個函式） 舉例來說，我們想要表現 1 + 2 * 3 的話，可以用兩個函式來表示並組合： const add = (a, b) =&gt; a + b; const mult = (a, b) =&gt; a * b; add(1, mult(2, 3)) 我們寫了加法跟乘法的函式，並將兩個函式組合，就能夠表現出「先乘後加」的行為，這就是複合函式的基本概念。 Shared State 共享的狀態 （ Shared State ）是指任何存在被數個分離的範疇。像是像全域範疇或是前面提到的閉包 ( Closure ) 所共享的這類狀態， 通常就是共享的狀態，在 Funtional Progaramming 裡面，共享的狀態應該避免，因為一但函式內有與其他範疇共享的狀態出現，那麼這個函式就不再是純函式了。 一個共享狀態的例子看起來就像這樣： let age = 15 function setUserAgeByInfo( info ) { age = info.age return age } setUserAgeByInfo({age:100}) 根據上面的程式碼，一但我們執行上面的函式之後，全域變數 userInfo 就會受到影響，這就是因為該變數（狀態）同時與全域範疇跟函式範疇共享的結果。這還只是比較小規模的例子，想想看，如果同時有十個函式都這樣使用全域變數，那麼會出現開發者無法避免的情況，也就不奇怪了，所以在使用狀態時，越是全域的狀態，就要越小心使用。 Immutability 當我們說一個物件是 Immutable ，那就表示這個物件在被產生之後，就無法再被修改了；反過來說，一個 Ｍutable 的物件，就是指在物件被產生後，還可以被修改，在 JS 內，用一般的方式產生的物件，就是這類 Mutable 的物件。不變性是 Functional Programming 的核心概念，因為如果沒有不變性的存在，我們在寫 FP 時就難以追蹤到狀態的歷史變化，奇怪的、無法理解的 Bug 就越有可能出現。 在 JS 的 ES6 版本後出現了使用 const 的宣告方式，const 很容易被跟不變性產生聯想，但其實是兩個不同的概念，const 是產生一個無法再被重新指派的變數而已，但是他並非產生一個 Immutable 的物件，不相信的話你可以試試看下面的程式碼： const user = { name:'Yoda' } user.name = 'Luke' 真正的 Immutable Object 可以用 Object.freeze 這個函式被產生出來： const a = Object.freeze({ foo: 'Hello', bar: 'world', baz: '!' }); a.foo = 'Goodbye'; // Error: Cannot assign to read only property 'foo' of object Object 在 JS 裡面，也有一些函式庫可以用來幫助你以完全 Immutable 的方式來開發，例如 Immutable.js 。 Side Effects 副作用（Side Effects）是指在被呼叫的函式外部，任何可以被看到的狀態改變，剛剛我們提到的狀態共享，就是有可能造成 Side Effect 的原因，Side Effect 的幾個例子如下： 使用consoie.log 印出值 寫入檔案 拉取第三方 API 呼叫其他任何有副作用的函式 副作用在 FP 內必須極力避免，因為如此一來，才能讓函式變得更簡潔，而且更好測試。 我們看了這麼多概念，其實有幾個概念幾乎是重複的，例如避免副作用、減少狀態共享、使用純函式，在我看來，這些概念都著重於「減少依賴」這件事情，也就是兩個不同部分的程式碼，他們所使用到的資訊應該要是完全獨立的，如此一來，也才能夠讓程式碼更乾淨好閱讀。 參考文章 Master the JavaScript Interview: What is Functional Programming? Functional JS #3: State JavaScript: What Are Pure Functions And Why Use Them?","link":"/2020/01/05/iron30-18/"},{"title":"JS 原力覺醒 Day17 - this 的四種繫結","text":"今天要談到的是 JS 裡面最常被提出來討論的部分，也就是 this 的指向，前面有提到當全域執行環境被產生出來之後，除了全域物件 window ，一個指向這個 window 物件的 this 也會跟著被產生。所以接下來你就可以用 this 來指稱 window 物件，除此之外， this 並不永遠都指向 window 物件，根據不同的呼叫方式，this 所指向的值也會不一樣，所以，你「如何呼叫」這件事情就會很大一部分影響 this 的指向。 Outline Javascript 裡面的 this 預設繫結 (Default Binding) 隱含的繫結 明確的繫結（Explicit Binding new 繫結 this 繫結的優先順序 參考書目 Javascript 裡面的 this 在正式進入 this 解說之前，我們先來了解一下為什麼 this 這麼重要， this 讓我們可以很方便地從執行環境內部取得外部物件，用另一個方式說就是，this 可以讓我們在呼叫函式時們決定要指向哪一個物件。 不過如果沒有好好使用的話，就會出現 this 指向錯誤的物件之類的不如預期的情況出現，所以我們在使用之前，一定要先了解 this 檯面下的運作方式。 四種繫結 （ Binding ） 所謂 this 的繫結指的是指向哪一個物件， this 大致上一共有四種繫結，讓我們一個一個來看看： 1. 預設繫結 ( Default Binding ) 預設繫結：foo 的 this 被 bind 到全域物件Window底下，這是最常見也最好理解的繫結。 function foo(){ console.log(this.a); } var a=2; foo() //2; 2. 隱含的繫結 隱含繫結：隱含的指出 this 綁定的對象，使用 . 可以取用到物件底下的屬性，同時也在告訴 JS this 的指向： var foo = { a:'I am in foo', bar:function(){ console.log(this.a); }, } foo.bar() //I am in foo; 繫結的失去 （ 繫結在賦值時會失效 ） 當你用隱含的繫結去呼叫物件內的函式時， this 會正確的指向該物件，但是一但你將這個函式指派給另外一個變數時，這個變數就只會參考到該函式，而不是擁有該函式的整個物件，這個時候再去執行的時候， this 就會因為找不到該物件而指向全域，這個現象就稱為隱含繫結的失去： var obj = { a:'obj a', foo: function foo(){ console.log(this.a); }, } var bar = obj.foo; var a = ' global a'; //Something Happened. bar(); // global a 3. 明確的繫結（Explicit Binding） 在JS 裡面，函是可以使用 call()、apply()，來指定綁定物件的 this，call 與 apply 在使用上兩個還蠻相像的，只差在參數傳入的方式，第一個參數都是指定 this 指向的物件， 而第二個以後的參數則是要傳入該函式的參數，apply 是以陣列的方式來決定傳入函式的參數順序，而 call 則是直接以第二個參數後的數量及順序來決定： function foo(arg1,arg2){ console.log(this.a); } var obj ={ a:2, } foo() // undefined foo.call(obj , arg1 , arg2);//2 foo.apply(obj,[arg1,arg2]);//2 //call 跟 apply 基本上行為相同，只差在參數傳入的方式不同 硬繫結 - ( Hard binding ) Hard Bind 是明確繫結的一種變化．可以確保某個 function 的 this 每次被呼叫的時候都與目標物件綁定，可以看到因為多包一層function的關係，即時bar在怎麼用call指定this環境，裡面的主要function :foo.call(obj)依然不會受到影響。 function foo(){ console.log(this.a); } var obj = { a:2 } var bar = function(){ console.log('this= '+this); foo.call(obj); } bar(); //this= [object Window] //2 bar.call(window); //this= [object Window] //2 4. new 繫結 當一個函式被以 new 的方式呼叫時，神奇的事情發生了： 會有一個全新的物件被創造出來 這個新建構的物件帶有 prototype 連結 (先不討論) 這個新建構的物件會被設為那個函示呼叫的 this 除非該函式提供了自己的替代物件，不然這個以new調用的函式呼叫會自動回傳這個新建構的物件。 函式搭配 new 關鍵字來創造物件的方式，也是早期物件導向宣告新物件的方式，而後來 class 關鍵字的出現，也讓我們用更直觀的方式宣告物件，因此像這樣使用 function 創造物件的方式也就比較不常見了。 function foo(){ this.a=2; } var bar = new foo(); //{} //this = {} //this.a=2 //{a:2} //return {a:2} //bar.a=2 console.log(bar.a); //2 this 繫結的優先順序 當 this 的繫結重複的時候，會以下面的優先順序決定採用哪一種繫結： 預設 &lt; 隱含 &lt; 明確繫結 &lt; new 繫節 參考書目 本篇文章參考 You Dont Know JS 系列的 Scope &amp; Closure","link":"/2020/01/05/iron30-17/"},{"title":"個人技術站一把罩！部落格建置大全（一）- 使用 Hexo 搭配 Github Page 建置自己的部落格","text":"這是我參加六角全馬鐵人挑戰的第二週，在比賽的一開始，就讓我來分享如何在 Github Page 上面架設自己的個人頁面，並串上自己購買的網域名稱（如果有的話）。相信各位工程師們多少都會聽過或看過其他工程師們使用 Medium 當作自己的部落格，對其他人分享自己經歷及技術，或是成長過程中領悟到的見解。 但如果你想對這個屬於自己的空間有更高的掌握度，或是想做一些比較客製化的排版視覺，那麼架設個人專屬的部落會是一個不錯的選擇。因此這邊推薦使用 Hexo ，作為今天介紹的主角。當然，方法沒有絕對，你也可以選擇自己從零開始開發，但我認為工程師的職涯如此漫長，有很多問題等我們解決，因此在適當的時機使用適合的工具，有時候是必要的。 Outline Hexo 介紹及專案建置 Hexo 專案架構 Github Page 將 Hexo 專案部署到 Github Page 上 總結 Hexo 介紹及專案建置 Hexo 是一套可以快速幫你建置個人部落格的工具，在官方提供的頁面你可以找到很多別人做好的部落格模板，並直接套用到自己的專案。 首先讓我們先把 hexo 的建置工具裝到系統內，使用以下指令： npm install -g hexo-cli 之後就可以利用 hexo 指令創造一個新的部落格專案。 npm init &lt;要創造的 Hexo 專案資料夾名稱&gt; 接下來進入剛剛建好的專案資料夾再用這個指令把 hexo 本地測試 server 架起來。 hexo server 或 hexo s 沒錯，這樣一來在本地就可以看見即時的變更囉，很方便吧！ Hexo 專案結構 這邊先介紹一下 Hexo 的資料夾分佈，以及功能。首先在根目錄可以看到幾個比較重要資料夾： public : 存放編譯後的靜態 html 檔案，基本上不會需要改動裡面的內容 scaffolds：存放文章模板的地方，新增文章的時候可以選擇要用哪一種模板，以我為例，在寫 JS 文章跟後端 Ruby on Rails 文章的時候就可以用不同模板來產生不同分類與不同標籤的文章，不用每次都另外再改。使用模板來新增文章的參考指令： hexo new &lt;&lt;Scaffold Name&gt;&gt; &lt;&lt;Article Name&gt;&gt; source : 存放部落格文章原始檔案， Hexo 內的文章通常以 Markdonw 來表示內容，而 Markdown 在很多地方都通用，非常方便。 themes : Hexo 官網可以選擇許多別人做好的主題，在官網找到喜歡的主題後，就可以下載並放到這個資料夾，然後記得在根目錄的 _config.yml 檔案裡的 theme 設定改為對應的主題名（資料夾名稱） ，以這個範例來說就是 landscape ，而對應的主題資料夾裡面則包含了外觀相關的原始碼（如 HTML / CSS / JS)，建議在必要的時候再去修改這些原始碼，否則盡量修改對應主題資料夾裡面的 _config.yml 檔案（與根目錄的同名設定檔不同）會比較好。 Github Page 什麼是 Github Page ？ 在對 Hexo 專案內容有了基本的了解後，讓我們繼續往下看。 Github Page 是 Github 提供的、能讓開發者利用 git 的形式直接配置好靜態頁面的功能，非常好用，許多實驗性的作品或專案也都會透過這樣的方式來呈現，而今天我們就會嘗試將 Hexo 用 Github Page 的方式來作部署。 首先在 Github 上創建一個新的 Repository ，Repository的名字依照官方說明，必須遵循以下規則 ( 記得 username 是你自己的 Github 帳號，不要輸入錯了 )： &lt;username&gt;.github.io 然後就會得的一個新的 Repository ，待會我們 Github Page 就會是以這個 Repository 的內容為主來做對外顯示。 其實剛剛輸入的 Repository 名稱 &lt;username&gt;.gtihub.io 就會是你個人Github Page 的網址，可以直接透過瀏覽器輸入網址找到，但因為目前還是空的，所以還不會有東西，我們先在電腦本地將這份 Repository clone 下來 : https://github.com/moojitsai/moojitsai.github.io.git 並新增 index.html 檔案做個測試，因為 Github 預設會去尋找這個檔名的檔案作為進入點。 新增完成後只要再用 git push 推回剛剛的 Repository 上，就會有 index.html 檔案，應該就可以從你的個人 Gtihub Page網址看到了（如果沒有看到再來問我）。 將 Hexo 專案部署到 Github Page 上 建立完新 Gtihub Page 後，我們來看看怎麼把這整個部落格專案放到 Github Page 上面，其實不難， Hexo 大多幫你做好了，只要設定檔配置正確就沒問題。 首先找到 _config.yml 這個檔案，然後在 deploy 這個設定下輸入你對應的 Github Page 的 Repo 位置，並把 type 寫為 git ，就完成基本設置了： 然後在部落格專案目錄底下裝上官方提供的 Git 部署套件 hexo-deployer-git： npm install hexo-deployer-git --save 最後因為我們文章內容並不是網頁可以直接看得懂的格式，像文章內容就是用 Markdown 來撰寫，所以在部署上 Github 之前我們要先產生部落格專案所需要的靜態檔，使用以下指令來產生： hexo generate 或是 hexo g 完成後就可以部署了： hexo deploy 或 hexo d 總結 \b今天的內容主要是紀錄部落格架設的過程，因為當初在使用 Hexo 的某些設定及功能時，某些官網寫的資料並不是那麼明確，還是要自己實驗過或是去看原始碼才比較會知道怎麼做，因此還是寫了一篇文章記錄下來，順便分享給有興趣的各位，下一篇要分享的是如何把今天設置完放到 Github Page 的網頁與自己購買的域名做串接，應該會蠻有趣的！可以先看看我最近串好的域名： https://www.muji.dev 參考文章 Hexo 官網 Managing a custom domain for your GitHub Pages site Github Page 說明","link":"/2020/02/16/hexo-github-page/"},{"title":"JS 原力覺醒 Day19 - 一級函式與高階函式","text":"今天要提到的是讓 JS 很適合用來撰寫 Functional Programming 的兩個特性的名詞解釋：「 一級函式」與「高階函式」，如果你寫 JS 一段時間，一定會聽過他，高階函式與一級函式可能聽起來有點複雜，其實並不會，只是字面上意思比較不好理解而已。這兩個特性，讓 JS 可以把函式在其他函式之間互傳，所以也是為什麼有人說 JS 很適合用來寫 Functional Programming 的原因。 Outline 一級函式 高階函式 一級函式 （ First-class functions ） 當我們說一個語言具有一級函式的特性時，代表這個語言把函式當作其他物件一樣看待，也因此可以將函式當作參數一樣傳入另外一個函式裡面。在 Functional Programming 裡面，也是因為這個特性，才有辦法做到複合函式 （Function Composition）， 而在 JS 內，函式本身也是一個特殊的物件（就是 Function 物件），在一些使用到 callback 概念的程式碼中，你就會看到這個概念是如何被應用的： function doSomething(fn, data) { return fn(data); } 我們可以試試下面的程式碼來確認上面的描述 ： function hello (){ console.log('hello') } hello.a = 'a' console.log(hello.a) //'a' 雖然上面的程式碼完全是合法的，因為函式本來就也是物件，但是在實務上請不要這麼做，否則同事或是跟你一起合作的人可能會崩潰，請使用一般的物件。 而既然將函式當作物件一樣看待，那就代表也可以把這個函式指派給變數，這就是我們之前提到的「函式表達式」 （ Function Expression ) 。 let hello = function (){ //do some thing } 高階函式 （ High Order Function ) 只要是可以接收函式作為參數，或是回傳函式作為輸出的函式，我們就稱為高階函式，例如，JS 裡面很常用的一些對陣列操作的內建API： Array.map( ()⇒{…} ) Array.filter( ()⇒{…} ) Array.reduce( ()⇒{…} ) 也可以被稱為是高階函式，因為他們能夠接收函式作為他們的參數。雖然上述幾個 API 的使用方式乍看之下可能會讓人覺得難以理解，但我們可以試著思考看看他們是怎麼被實作的，其實並沒有那麼複雜，下面就以 Array.map 為例，邊實作、邊思考他的運作方式吧！ 由於 Arrray.map 是對陣列元素做巡訪，然後做某些操作之後回傳，所以可能的步驟如下： 將函式傳入 map 內 執行一個以陣列長度為執行次數的迴圈 每次帶入不同的 array id 以表示目前尋訪的進度 取得陣列元素、逐個進行修改 逐個放入新的陣列並回傳 自己實際實作 map function 的話看起來會像是這樣： function arrayMap(fn,array){ let length = array.length let newArray = [] for(let i=0 ; i&lt;length ; i++){ newArray.push(fn(array[i])) } return newArray } 透過上面的程式碼我們自己就實作了高階函式 arrayMap ，可以看到我們自己做的 arrayMap 會在陣列傳入之後，逐個訪問每個元素並傳入我們自己寫的函式 fn ，這個 fn 會根據我們寫的內容將該值做處理之後回傳，然後會直接透過 Array.push 將結果推入新的函式（ 看到了嗎？這裡我們用到複合函式的概念 ） arrayMap((item)=&gt;{ return item * 2 },[1,2,3,4]) 結論 透過今天對兩個名詞的說明我們知道了一級函式與高階函式這兩個名詞的意義，然後我們也自己試著實作了自己的高階函式： 一級函式是指在一個語言內，函式本身也是物件，因此能夠將函式當成參數傳給另一函式 高階函式則是指一個函式能不能接收函式當作參數，或是回傳函式作為回傳值","link":"/2020/01/05/iron30-19/"},{"title":"JS 原力覺醒 Day02 - JavaScript  V8 引擎","text":"在進入 JavaScript 語法的範疇之前，我們要先來看看在這個語言的背後是怎麼運作的，不管是讓你之後能夠更有效率的找出問題，或是想要優化程式碼的運行效能，我想在這個階段好好了解背後的運作模式跟解析流程是非常重要的。 Outline 編譯語言、直譯語言 JavaScript V8 Engine 簡介 JavaScript V8 Engine 運行流程 編譯語言、直譯語言 程式語言經由運行模式可以分為兩大類，一種是編譯語言，另一種是直譯語言。JavaScript 屬於後者。這兩種類型語言的共通點在於，都必須將我們人類寫的程式碼（高階語言），轉換成電腦看得懂的機器碼（低階語言）。 而兩者最大的不同就在程式碼的編譯時機。編譯語言在開發者寫完一段程式碼之後就會預先編譯，之後就能夠獨立執行，直接與電腦溝通，直譯語言則是在即將要執行時才會透過直譯器，直接動態進行編譯後執行產生的機器碼（一邊解讀、一邊執行），也就是因為要經過直譯器，直譯語言在執行速度上通常會比編譯語言來的慢許多。另外，直譯語言無法獨立執行，必須仰賴一個能夠編譯並且執行產生結果的環境，這也是我們今天的主角 V8 引擎的工作。 JavaScript V8 Engine 簡介 V8 引擎是 Google 做出來讓 JS 跟瀏覽器溝通的的開源專案，這個引擎被使用的非常廣泛，在 Chrome 瀏覽器跟 Node.js ，以及桌面應用程式框架 Electron 之中都有他的身影。而在 V8 出現前，最早最早的 JavaScript 引擎，叫做 SpiderMonkey ，同時也是另一個知名瀏覽器 FireFox 的渲染引擎。 JavaScript V8 Engine 運行流程 V8 引擎的運作流程最重要就是以JavaScript 原始碼將一個一個關鍵字解析成為抽象語法樹，交給直譯器後編譯並執行，大致上可以分為三個階段來描述： 解析階段： 解析器會先分析 JavaScript 的原始碼，然後分別將變數、關鍵字、語法符號轉成一個特定的格式來表示詞彙關係。這個關係的集合稱為抽象語法樹（ AST ），在語法樹裡面每個節點都對應你的程式碼中的各種語法片段，使用 AST 的好處是對電腦底層來說能夠有一個可以辨識的結構。 直譯 &amp; 執行階段：直譯器會將上個階段的語法樹轉換成特殊的機器代碼稱為 ByteCode ，ByteCode 已經是能夠被執行的機器碼，使用 ByteCode的優勢是可以很快的被編譯成更底層機器碼。 優化階段：直譯器產生出來的機器碼，執行時會產生相關數據，並被傳給優化編譯器根據數據做出來的假設再次進行編譯，產生優化過的機器碼，如果最後發現優化結果跟前面做出的假設條件不符，則將該次優化拔除，重回上一個階段使用原來的ByteCode 來執行程式（ 這個動作稱為De-Optimizing ）。 今天我們了解了直譯、編譯語言運作方式的不同以及 JavaScript 如何轉為機器碼與電腦溝同的流程，其實有很多地方可以再深入探討，如語法解析、直譯器與優化編譯，不過為了避免偏離主軸太遠，這邊就請大家先了解每個元件跟階段要達成的目的就可以了。下一個章節要開始正式進入 JS 語言的範圍了，我會針對V8 引擎在啟動時所產生給 JavaScript 專屬的特定環境，稱為「執行環境」去做說明。","link":"/2020/01/02/iron30-2/"},{"title":"JS 原力覺醒 Day20 -  物件","text":"今天要提到 JS 裡面物件的概念，「物件」的概念在 JS 裡面是非常重要的，也是 JS 的基本元素。但是相對於物件導向語言的物件，意義上又有一點不一樣。就像前面提到在 JS 裡面函式也是屬於物件，這樣子的行為在一般物件導向的語言裡面是沒有的。 Outline JS 的物件 創造物件的方式 取用物件的方式 物件原型導向 JS 的物件 在 JS 裡，物件代表一連串「屬性名稱」與「數值」的組合 ( name-value pair )。這些組合湊在一起就形成了對某件事情的描述，就像一本書有許多資訊像是書名、作者、出版日期ㄧ樣，你可以用 JS 物件輕鬆的表示現實世界的許多物品： { title: 'Le Petit Prince', author:'Antoine de Saint-Exupery', pages: '331', ... } 創造物件的方式 最基本的用來創造物件的方式有幾種： 物件實字 （ Object Literal ） 函式建構子 物件實字 （ Object Literal ） 物件實字應該是你最長用到的創造物件方式，使用物件實字創造物件的寫法，跟在 API 傳遞、溝通的時候會用到的 JSON 格式長得很像，都是使用大括號逗號來區分屬性，其實我在文章的開頭就已經使用過了： let object = { propertyName : 'value', ...} 函式建構子 （ Function Constructor ） 在許多物件導向語言裡面，因為以類別為主的語言特性，通常是以 class 創造物件藍圖，並搭配使用 new 關鍵字來產生新的物件，這也是物件導向的基本概念。雖然 JS 並不是物件導向的語言，但早期為了吸引那些習慣使用物件導向語言的工程師來使用，也創造了使用 new 關鍵字，屬於自己獨特的產生物件的方式，稱為「函式建構子」，也就是把函式內容視為其他物件導向語言的建構子（ constructor ) 來使用： function book (name,price) { this.name = name; this.price = price } let starWar = new book('star war', 500) console.log(starWar) // book {name: &quot;star war&quot;, price: 500} 如果你要產生一個空物件，那麼除了物件實字，你也可以透過下面的方式： let obj = new Object(); 這是什麼意思？我們都知道 JS 裡面有一個物件叫做 Object，裡面有很多好用的 API 例如 Object.keys 可以取得物件的所有屬性名，但是根據上面的說明，new 應該要搭配函式來使用才對啊？難道 Object 是函式不成？ 是的！ 在 JS 裡面 Object 就是一個函式，你可以對他使用 typeof 來驗證這個說法： typeof Object // function 既然 Object 本身也是函數，那麼這個說法就合理了，至於為什麼 typeof Object 結果不是 Object ，我想那又是另外一個層面的問題了。 取用物件屬性的方式 取用物件有兩種方式： 最常見的.運算子 使用中括號 [] 使用中括號取用物件來取用屬性，因為能夠使用字串的關係，在取用屬性的時候可以比較有彈性： let user = { name:'Yoda' } user.name // Yoda user['name'] //Yoda 物件原型導向 雖然許多人在 JavaScript 撰寫物件導向風格的程式碼，但 JS 並不是像 JAVA 或是 C# 那樣物件導向的語言，而相對的，JS 是物件原型導向（ Object-Prototype Oriented ）的語言，在 JS 裡面的每個物件都有一個可以用來與其他物件共用屬性跟方法，或是進行複製的隱藏屬性 : [[ Prototype ]]。 這種繼承的行為也稱為原型繼承 ( prototypical inheritance )，相對於其他像是 PHP、JAVA、Python 這種以類別 ( class ) 為基礎的物件導向語言，這算是比較特別的，在後面的章節我會繼續說明 JS 的物件是如何透過原型來共用屬性的。","link":"/2020/01/05/iron30-20/"},{"title":"JS 原力覺醒 Day22 -  原型共享與原型繼承","text":"前一天我們提到 JS 的原型，以及為什麼會有原型的出現 ：為了模擬物件導向的行為。 那麼原型實際上帶來什麼好處？又是透過什麼方式達到繼承的目的？ Outline 原型共享：原型的運作方式 原型鍊 原型繼承 原型共享：原型的運作方式 __proto__ 屬性會在物件產生的時候被加到這個物件上，這個 __proto__ 就是透過參考的方式，將「被生成物件」與函式的「原型物件」做連結 ( 看到 proto 前後的「＿」有沒有把他跟「連結」做聯想，是不是覺得這個變數取的很好？ )。這個自動產生 __proto__ 參考的行為是 JS 預設的動作，有一點像是這樣： let user1 = new User() user1.__proto__ = User.prototype 當然因為這件事情是自動發生的，所以我們不需要手動去做這件事情，在開發上也不建議操作 __proro__ 這個變數，請讓他自由，所以整理一下提到的兩個名詞。 proto ：會在物件被生成時一起被指派到物件上的屬性，他決定這個物件的原型物件是誰。 prototype ：會一直存在於建構函式上的屬性，所有透過該函式產生的物件都有能力存取。 當我們想要取用物件中的某個屬性時，JS 會先去物件中尋找該屬性，如果沒有，就會轉而透過__proto__ 往原型物件屬性，也就是 prototype 原型物件，去尋找這個屬性。由於原型物件 prototype 本身也是物件，所以我們在這個物件內也可以另外新增屬性，而透過前面的說明我們也可以知道原型物件是在被生成物件之間被共享的，所以我們就可以把一些共用的變數或是方法，放到這個共用的物件之內。 let defaultName = 'Darth Vader' User.prototype.name = defaultName let user1 = new User() let user2 = new User() user1.name // 'Darth Vader' user2.name // 'Darth Vader' 這麼做有什麼好處？ 把共用函式放在函式建構子裡面的話，每個被生成物件還是會有一樣的函式阿？是這樣沒錯，但是這樣等於是把同樣的數值或函式複製好幾次，生成幾個物件，JS 就會需要幾個記憶體空間；而要同樣的目的，其實只要放在 prototype 原型物件內就可以用較低成本的方式達成。 原型鍊 剛剛說到當 JS 引擎在物件內找不到某個屬性時會透過 __proto__ 去往 prototype 原型物件去搜尋這個屬性，如果原型物件裡還是找不到，這個原型物件上也還會有一個 __proto__，指向他所屬前代類別的原型物件，例如 JS 內 Array 其實也是物件，所以可以說他的前代就是 Object 物件： Array.prototype.__proto__ === Object.prototype // true 因此 JS 引擎會再透過原型物件裡的 __proto__ 屬性往上一個原型物件尋找，直到真的找不到為止 ( 會找到 JS 內 Object 物件的原型物件為止，你可以再透過 __proto__ 往上找找，最後會發現他是 null )。這個行為跟當初我們講到範圍鍊 ( Scope Chain ) 的行為類似，所以也稱為「原型鍊 ( Prototype Chain )」。 原型繼承 最後這個部分就讓我實際的程式碼範例來實作繼承，順便藉此說明原型鍊概念的實用性，在繼承的行為裡，透過被繼承的「後代類別」，所產生出來的物件，一開始就應該要直接具有「前代類別」的屬性跟方法，我們來嘗試看看有沒有辦法透過 JS 達到這個目的。 現在假設： 我們有一個 Human 類別跟 User 類別 在 Human 類別的物件上有一個 getRace 方法 在 User 類別的物件上有一個 getUserName 方法 我們的目標是：透過原型鍊實現 Human 與 User 兩者的繼承關係。 function Human (action, height,race){ this.action = action this.height = height this.race = race } function User(fisrtname,lastname){ this.fisrtname = fisrtname this.lastname = lastname } Human.prototype.getHumanRace = function(){ return this.race } User.prototype.getFullName = function(){ return this.firstname + this.lastname } 在正式開始之前我們要先思考一下有哪些部分要處理，才能夠讓要繼承的函式建構子與被繼承的函式建構子共享屬性跟方法，主要有兩個方向： 1. 前後代類別原型物件繼承 因為透過 new 運算子生成物件的時候，這兩個建構函式上都會各有一個 protorype 物件，一般情況下他們各自為政 ，但是在處理繼承的時候我們必須同時考慮兩者之間的連結。 前面提到物件在找不到屬性時，就會往原型物件找，如果原型物件裡還是找不到，就會再透過原型物件裡的 __proto__ 屬性往上一個原型物件尋找，形成原型鍊。原型物件之間要做到繼承就代表了： 透過「後代類別」產生的物件，其上有屬性不管在物件內還是在原型物件上都無法找到時，會轉而往「前代類別」的原型物件尋找 能夠做到這樣子的行為，我們才能說我們透過建立原型屬性的原型鍊，而做到繼承的效果。為了達到這樣子的效果，很顯見的我們必須修改物件上的 __proto__ 連結，但是前面也有提過再開發上不建議直接修改__proto__ 的參考，因為會破壞物件的預設行為，儘管如此，我們還是可以用比較曖昧的方式來修改這個連結： User.prototype = Object.create(Human.prototype) 我只用一個之前沒看過的 JS 內建方法 Object.create 修改了繼承物件 User 的 prototype ，Object.create 可以用來創在一個全新的物件，而且他把第一個參數傳入的物件拿來當作這個新物件的 prototype ，之後我們就可以發現 User 的原型物件，被我們修改成一個新的空物件，而這個物件的原型，正是指向 Human ， 透過這樣的方式 ，我們就把兩者之間繼承的原型鍊串起來了。 但是如果你有注意到的話，原本在原型物件上都會有個指回建構函式的prototype.constructor 已經不見了，因此我們需要手動把他加回來，JS 才能夠查找到正確的建構函式。 User.prototype.constructor = User 2. 前後代建構函式內容繼承 透過原型物件確實可以達成共享，但如果透過這個方法來共享某些特定屬性，因為屬性的記憶體空間只有一個，這麼一來如果是像「姓名」、「年齡」這種每個人（實體）都會有不同數值的資料，就不適合放在原型物件內，所以我們要想辦法讓我們在「後代」建構函式內可以直接取得「前代」建構函式內容。 簡單來說就是讓前代類別的內容出現在透過後代類別的建構函式所產生的物件上，這裡有一個很經典的辦法，那就是在後代 ( 繼承類別 ) 建構函式裡面執行前代( 被繼承類別 ) 建構函式： function Human (height,race){ this.height = height this.race = race } function User(fisrtname,lastname,race,height){ this.fisrtname = fisrtname this.lastname = lastname Human(height,race) // This is not totally correct } 這麼一來當 User 透過 new 被呼叫的時候，除了會將 User 內的 this 繫結綁到新生成物件上，還會有另外一個充滿使用 this 繫結來設定物件屬性的 Human 方法被執行，如此一來，前代類別的屬性設置就能夠與後代共用，而前兩行定義的 firstname 與 lastname ，也正好是 User 專屬，Human 不會有的資料屬性，當然我們也可以直接把 Human內定義的屬性搬到 User 內，不過這樣就會變成是重新定義一整個物件屬性，就失去繼承的意義了： // dont do this if you want to make an inheritance. //THIS IS AN ANTI-PATERN function User(fisrtname,lastname,race,height){ this.fisrtname = fisrtname this.lastname = lastname this.height = height this.race = race } 但是還沒有完，這邊有一個前面提過很重要的觀念，那就是當我們 執行 Human 方法時，裡面的 this 繫結並非透過 new 被觸發，所以並不是指向剛剛透過 User 函式建構子被生成的新物件，這個時候我們要透過「明確的繫結」來修改 this 的指向，來把 User 內的 this 連結到 Human 函式的 this 上，這樣子我們就達成了所有物件屬性的繼承： function Human (height,race){ this.height = height this.race = race } function User(fisrtname,lastname,race,height){ this.fisrtname = fisrtname this.lastname = lastname Human.call(this,height,race) } Human.prototype.getHumanRace = function(){ return this.race } User.prototype.getFullName = function(){ return this.firstname + this.lastname } User.prototype = new Human() let user1 = new User('John','Kai','black','179')","link":"/2020/01/05/iron30-22/"},{"title":"JS 原力覺醒 Day21 -  原型","text":"上一篇提到 JS 是物件原型導向，而非物件導向的語言，如果想要像物件導向那樣達成物件之間屬性的共用，就需要借助原型的幫忙，所以了解「原型」的概念，對於我們後續想要活用 JS 的物件，或是在 JS 裡面撰寫物件導向風格的程式碼的話是非常重要的。 Outline 物件導向：類別與物件 物件導向：繼承的概念 函式上的原型物件屬性 透過函式建構子產生的物件 總結：原型物件屬性 物件導向：類別與物件 在物件導向語言裡面，類別定義了描述某件事或某個功能的基本概念，就像一件商品或是建築物的設計圖ㄧ樣；而物件則是透過類別裡所描述的的概念實現出來的東西，對比於建築設計圖，就是建築物： 類別 ←→ 建築設計圖 物件 ←→ 建築物 當然上面的比喻只能說是非常非常粗淺的描述，完整的物件導向概念是非常博大精深的。這邊是想讓各位讀者了解它的原理，以及從什麼出發點被創造出來的，知道物件導向的根本概念後，後面我們解說 JS 原型的時候，就不會那麼不知所以然。 物件導向：繼承的概念 前面也提過原型存在的目的是為了達到繼承，那麼我們先來看看繼承是怎樣的概念，在物件導向裡的繼承是指類別可以以另一個類別為基礎，再往上進行擴充、或是修改，這樣一來就可以用很方便且較低成本的方式創造新的類別，因此，姑且說繼承的目的是為了讓「某些屬性可以共用」且可以減少重複。 用生活化的方式比喻的話繼承與被繼承物件之間的關係，有點像圖片內的「動物」這個總稱與「鳥」這樣更明確的稱呼，鳥也是動物的一種，所有動物都有特定共用的行為例如呼吸，但是有些行為可能只有鳥類做得出來例如飛行，因此可以知道，繼承可以讓物件同時具有共用的部分與較為特定的部分。 函式上的原型物件屬性 在物件導向裡面有類別的概念讓物件得以用很快速清楚的方式擴充，而 JS 裡面只有「物件」，所以只能用模擬的方式來達成類似的效果 — 那就要透過原型的幫忙。 前面在講繫結的時候我們提到，函式可以搭配 new 運算子成為「函式建構子」來產生物件，我們先來討論函式建構子的概念是什麼。在 JS 裡面，函式建構子其實與一般函式呼叫沒有差別，只是前面多了 new 這個關鍵字而已。 而在 JS 裡面，一個函式被創造出來的時候，JS 引擎會新增一個 prototype 屬性到這個函式上面，這個 prototype 是一個物件，我們姑且稱之為「原型物件」，在原型物件裡面我們可以找到一個指回該函式的constructor 屬性。 我們用下面的程式碼來當作例子： function User(firstName, lastName) { this.firstName = firstName, this.lastName = lastName, this.fullName = function() { return this.firstName + &quot; &quot; + this.lastName; } } var user1 = new User(&quot;Gin&quot;, &quot;Tsai&quot;); console.log(user1) 我們用 User 函式當作函式建構子來產生物件，這個函式上面會有一個 prototype 屬性，且他是一個物件，裡面有另外兩個屬性： 剛剛提到的 constructor 屬性，指向回該建構函式 ( User ) ＿proto__ 屬性 ，裡面又是另外一個物件，這一點後面會再詳談 透過函式建構子產生的物件 那麼，當物件透過這個函式建構子被產生之後，會不會有什麼特別的地方呢？相對於 JS 引擎在 function 上面加上 prototype 屬性，在這個新生成的物件上則是會被加上一個 __proto__ 屬性，這個屬性恰好是指向剛剛函式建構子的 prototype 物件。 User.prototype === user1.__proto__ //true 因此我們透過上面的例子可以得出這樣子一個結論：透過函式建構子生成的物件，其上面會有一個指向該物件所屬函式建構子 prototype 屬性的 __proto__ 屬性，也就是該新生成物件的「原型」。 現在讓我們用同樣的方式創造第二個使用者 user2 ，因為一樣都是透過函式建構子所產生的物件，因此在這個物件上照理說也會有一個 __proto__ 屬性並指向產生這個物件的函式建構子上的原型物件，所以我們可以知道只要是透過函式建構子被生成的物件，他們之間都有一個共享的原型物件（ prototype ），先知道這一點很重要。 總結：原型物件屬性 現在我們知道了被生成物件與建構函式之間的關係： 所有透過函式建構子生成的物件，都透過 __proto__ 屬性與函式建構子上的 prototype 屬性做連結，或是說共享這個屬性。 但是光知道這些還沒有辦法知道實際的應用，下一章節我們會介紹這個部分，就讓我們往下看看 JS 是怎麼透過原型來達到繼承以及減少相同函式宣告的重複性的。 參考資源 Prototypes in JavaScript","link":"/2020/01/05/iron30-21/"},{"title":"JS 原力覺醒 Day23 - Class 語法糖","text":"講完了原型鍊，現在我們知道如何透過建構函式去做到類似類別的效果，也透過設定物件的 prototype 屬性達到物件的繼承效果， ES6 之後，甚至出現了 class 關鍵字，讓我們可以用更物件導向的方式去撰寫 JS。 Outline Class 基本用法 class 宣告式的防呆機制 透過 class 宣告來達成類別繼承 原型物件方法 static 靜態方法 類別建構子內的 super Class 基本用法 原本我們必須要透過建構函式來來模擬類別產生物件，但是因為函式子實在太像是函式了，所以很容易被搞混。在 ES6 後出現了 class 宣告的方式，讓相關功能的程式碼整體變得更物件導向且直觀、更好閱讀許多。使用 class 宣告類別的寫法會要使用比較多一點語法，但與建構函式不會相差太多： 建構函式： function User(name){ this.name = name } let user1 = new User(name) User.prototype.getName = function (){ return this.name } class 宣告式 class User{ constructor (name){ this.name = name } getName(){ return this.name } } 可以看出使用了 class 宣告以後，原本建構函式的內容還是一樣，只是被移動到 constructor 函式內而已。而原本我們要取用 prototype 才能達成方法的共享，現在也只要直接在 class 內直接宣告就可以了( 是不是真的乾淨很多 ），注意在 class 內的方法宣吿方式跟一般物件屬性的宣告不太一樣，那是 ES6 後出現、用來宣告函式屬性的縮寫，且方法與方法之間不需要以逗號相隔。 class 宣告式的防呆機制 為什麼前面說使用函式宣告式很容易讓開發者把他跟一般函式搞混呢？因為使用 new 運算子搭配函式來創造實體 ( instance ) 的時候，基本上也是一種函式呼叫，而且就算沒有加上 new 運算子，函式呼叫還是有效， JS 不會有提示**，**因此就算真的寫錯了也不容易找到錯誤。而使用 class 來宣告的時候，則只有在使用 new 呼叫的時候，才會有效。 透過建構函式來達成類別繼承 還記得前面提過，想要用建構函式來達成繼承的話，有幾個步驟我們必須自己進行： 建構函式的繼承： 為了繼承「前代」建構函式的內容，所以我們必須自己在「後代」建構函式內呼叫前代建構函式 ： function Human(race){ this.race = race } function User(name,race){ this.name = name Human.call(this,race) } 原型物件的繼承 修改「後代」建構函式的原型物件使原本存在其中的 proto，屬性從參考 Object 改為參考到前代物件，然後再把原型物件內的函式建構子指回「後代」建構函式，完成原型鍊的串接： let User.prototype = Object.create(Human.prototype) User.prototype.constructor = Human 透過 class 宣告來達成類別繼承 class 是 ES6 後出現的語法糖，語法糖簡化了整個類別宣告的過程，透過 class 宣告類別，讓這一切複雜的設定都變得簡單許多！我們不需要再去修改原型物件，也能直接完成繼承的效果了。使用 class 來實現繼承，會需要搭配另外一個關鍵字 extends ，步驟如下： 創造要被繼承的類別 Human： class Human{ constructor (race){ this.race = race } getRace(){ return this.race } } 創造後代類別 User ，並搭配 extends 指向 Human ，代表 User 繼承 Human ： class User extends Human{ constructor (name, race) { // invoke our parent constructor function. super(race); this.name = name } } 類別建構子constructor 的內容就是原本建構函式的內容；而還記得前面有提到我們必須自己在「後代」建構函式內呼叫「前代」建構函式嗎？現在也不需要這麼麻煩， constructor 內的 super 函式就代表了 被 extends 的 Human 建構函式，所以我只要直接呼叫 super 就可以了。 原型物件方法 使用建構函式，我們可以在原型物件上新增共享的方法，在 class 宣告中當然也做得到，其實就是在 constructor 外定義的方法，其實前面已經有提過了： class Human{ constructor (race){ this.race = race } getRace(){ // will be set on the prototype object return this.race } } static 靜態方法 靜態方法是物件導向裡面的概念。靜態方法只能由類別本身取得的方法，在產生出來的實例 ( instance ）中是無法取得的。static 和 class ㄧ樣是語法糖，使用 static 關鍵字定義的方法，會直接被指派到該 class 上，所以就只能從該類別上直接取得，像是這樣： class User { constructor(name){ this.name = name } static getUserType (){ return 'technical' } } User.getUsertype() //'techical' 對應前面的建構函式，就有一點像是這樣： function User (name){ this.name = name } User.getUserType = function(){ return 'technical' } 如果從建構函式來看靜態方法的話可能會稍微有一點奇怪，不過畢竟函式本身也是物件嘛，要在之上新增屬性本來就是合法的。 類別建構子內的 super 剛剛說到類別建構子與建構函式內容相同，而裡面的 super 又代表了被繼承類別（或稱前代類別），所以在「後代」類別建構子內一定要呼叫 super 才能有效完成屬性繼承，而在 class 內定義的其他方法則會被定義到原型物件內，所以如果想要取得「前代」建構函式原型物件內的函式，可以直接用 super 來取用，以前面 Human 類別為例子，在 User 類別內就可以這樣做： class User { constructor(name){ super() this.name = name } getRace(){ return super.getRace() } } 總結 在我們了解了 JS 內，原型的運作方式之後，我們利用原型達成了繼承的效果，了解了什麼是原型鍊，之後在今天的這篇文章裡面我們又結合了上述提到的所有知識了解了 class 語法糖的使用方式，還有跟舊版建構函式寫法的對應。儘管一切很複雜，相信讀到這裡的你一定有不少收穫。 雖然快結束了，不過如果你對我寫的系列文有興趣，歡迎訂閱，已經訂閱我的人，也非常感謝你們，你們的閱讀就是我寫下去的最大動力，希望我可以把 30 天都撐完！","link":"/2020/01/05/iron30-23/"},{"title":"JS 原力覺醒 Day24 -  DOM","text":"今天要講的是瀏覽器的 DOM 的概念，內容雖然跟 JS 語言比較沒有關係，但是除非你只寫後端 node.js ，否則只要跟介面相關一定會碰到需要處理 DOM 元素的情況出現，今天就讓我們學著好好跟 DOM 相處。 Outline DOM 是什麼？ 畫面是如何透過 DOM 被產生的？ DOM Tree 與 DOM 互動 總結 DOM 是什麼？ 在我們漫長的前端職涯中，每位前端開發者心中都一定曾經出現過、或是被問過這個問題，那就是到底什麼什麼是 DOM 呢？我們都知道 HTML 是透過標籤式的語法來描述網頁中元素與元素的關係，一對標籤通常就代表一個元素，而且標籤又可以放在另外一個標籤之內，因此元素之間是會有上下層級的，而 DOM 呢，就是透過把這樣子的層級結構轉換為對應的「物件」而成的關係模型。 DOM 並不是只能透過 HTML 產生，其他類似的語法像是 SVG、XML 這裡的物件並不一定要是 JS 的物件，因為，但是在瀏覽器裡面，是的，這裡我們討論的物件就是 JS 裡的物件，例如我們在操作 DOM 元素時最常用到的 document 物件。 document.createElement('div') 所以，我認為DOM 是： 將HTML文本的複雜層級關係，轉換成以物件結構的方式來表現 ，讓程式語言得以與之溝通。 畫面是如何透過 DOM 被產生的？ 因為 HTML 語法大部分都是是成雙成對且有層級關係的標籤，而在使用者透過瀏覽器進入網頁，瀏覽器開始讀取 html 檔案，就會開始把開發者寫的 HTML 程式碼（即指 Document ) 內容轉成對應的層級關係結構，所以這種結構才會被稱為 Document Object Model （文件-物件模型）。從使用者進入網頁，到顯示最後使用者的畫面之前，會經歷許多步驟，不過大致上可分為兩個階段： 第一階段：瀏覽器會先讀取 HTML 程式碼，並決定最後要渲染在網頁上的內容 第二階段：瀏覽器實際開始渲染，形成最後看得見的畫面 第一階段執行玩後的結果稱為「渲染樹 ( Render Tree )」，渲染樹就是用來表現會被渲染到最終畫面上的 HTML 元素，還有他們的關係與 CSS 樣式，要完成渲染樹，瀏覽器會需要兩樣東西： DOM ：用來表現 HTML 元素的層級關係 CSSOM： 整個網頁內HTML 元素對應樣式的關聯 DOM Tree DOM 裡面用來表現元素層級關係的物件又稱為「 節點樹 ( Node Tree) 」，他會有這樣子的名稱是因為結構都是從最上層的某個元素，例如 &lt;body&gt; ，往下慢慢延伸、長出許多的分支，整個結構就像是樹一樣，透過這樣子的關係表現形式，程式語言（JS) 與畫面表現 (HTML) ，才得以互相溝通。以下面這個 html 內容為例： &lt;html&gt; &lt;head&gt; &lt;title&gt;DOM Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; It's All About DOM &lt;/h1&gt; &lt;p&gt;Hello World!!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; HTML 中，在另外一個元素標籤裡面的元素就是該元素的子元素，如 &lt;html&gt; 元素在最上層，所以其他包含在這個元素裡面的都是他的子元素，而這些元素內又會有其他包含的元素，如此重複、不斷往下堆疊，**而把每個元素都看成一個節點的話，就會形成 DOM 的結構樹 ( DOM Tree) 。而每個樹的節點在也都對應為一個物件，**如此一來 JS 才能透過 瀏覽器的 API 如 document. querySelector 跟每個元素互動或溝通。 與 DOM 互動 透過 JS 我們可以跟 DOM 互動來改變畫面的呈現，或是新增一些互動的功能，像是： 改變或刪除 DOM 元素 修改元素的 CSS 樣式 讀取及修改 DOM 元素上的屬性 ( id 、 class 、 src 這些標記性的內容） 創造新的 HTML 元素到 DOM 裡面 在 DOM 元素上新增監聽事件（如：點擊） ## 總結 今天我們了解了什麼是 DOM ，DOM 是從開發者寫的 HTML 程式碼轉換而來，但 HTML 語法本身並不是 DOM ，而瀏覽器就是因為透過 DOM ，才能讓 JS 跟畫面的元素溝通。下一篇，我會講解從使用者進入畫面後，瀏覽器是怎麼從生成 DOM ，然後透過一連串的處理，最後才顯示畫面的。 參考資源 JavaScript DOM Tutorial #1 - Introduction MDN官方說明 DOM Nodes","link":"/2020/01/05/iron30-24/"},{"title":"JS 原力覺醒 Day25 - CRP : 關鍵渲染路徑","text":"當使用者進入頁面、瀏覽器收到請求並回傳前端相關檔案後，到最後使用者看到的畫面呈現之前，還有很多步驟會被執行，這一連串步驟的總和就稱為 Critical Rendering Path ( 中譯：關鍵渲染路徑），了解關鍵渲染路徑，在網站前端頁面需要做效能優化時，就可以比較容易知道，要從哪裡下手。 關鍵渲染路徑（以下簡稱 CRP ) 大致上會執行以下六個步驟： 建構 DOM Tree 建構 CSSOM Tree 執行 JavaScript 創造渲染樹 產生畫面佈局 繪製、產生畫面 下面就讓我們一個步驟一個步驟詳細來看： Step1. 建構 DOM Tree 前一章節有講到網頁的 DOM 是根據 HTML 內容而來，這個轉換的過程有點像這個系列一開頭我們討論 JS 語法解析那段，瀏覽器會根據 HTML Tag 將內容轉為一個一個 Token （標記） 之後會根據這些 Token 將對應的標籤轉換成節點，之後根據 Token 的前後關係產生出 DOM Tree 。 Step2. 建構 CSSOM Tree CSSOM ( CSS Object Model ) 是代表跟 DOM 元素對應樣式的物件。他的表現形式跟 DOM 很像，只是 CSSOM 是依附著每個節點，各個節點都會有對應的樣式 ( Style )，所以基本上 CSSOM Tree 跟 DOM Tree 長的會很像。 這邊要注意的是，CSS 在頁面載入行為裡，是屬於鎖定渲染的資源( Render Blocking Resource ），意思是，在頁面仔入時，只要還沒有拿到所有的 CSS 檔案並成功載入，那瀏覽器就會等到完成載入為止，這意味著，每個網頁上的 CSS 檔案，都會拖到載入速度。 除了 Render Blocking ，也有人說 CSS 是 「Script Blocking 」，因為在瀏覽器載入所有的 CSS 檔案之後，瀏覽器才會進入的我們的下一步「執行 JS」。 在產生 CSSOM 時，越多層的選擇器，在元素與樣式的匹配上會需要更多時間來進行。以下面這兩個 CSS 類別為例： A : p { color:red; } B : div h1 { font-size:22px;} 第二種 B 情況的 CSS 會需要更多時間來做匹配，首先瀏覽器會先找到頁面上所有的 h1 元素，而後在看這個元素的父類別是不是一個 div 元素 ，因此瀏覽器在匹配樣式時其實是以「從右邊到左邊」的順序來進行的，所以現在你就了解，如果你有加速前端渲染速度的請求，就要減少 CSS 選擇器層級的長度，在這方面，BEM 的 CSS 命名撰寫風格就把層級關係透過命名的方式來表達，同時也大幅度的減少選擇器的少用次數，建議對 CSS 有興趣鑽研的人一定要看一下。 類似的命名風格或規範，除了 BEM 之外還有 OOCSS 跟 SMACSS ，這些規範都是透過一些原則，來達到最大程度的減少重複，除了好維護之外，其實也能提升畫面渲染的效率，這也是為什麼這些規範常常被資深前端人員提起、並視為圭臬的原因。 Step3. 執行 JS JS 則是鎖定轉譯，在 JS 執行完之前，瀏覽器都不會繼續做 HTML 文件的轉譯跟建構。當瀏覽器轉譯時碰到 &lt;script&gt; ，他會停下來等到 JS 執行完成之後才會再往下。這也是為什麼我們常常說要把 &lt;script&gt; 標籤放到整個網頁最後面的原因。 Step4. 創造渲染樹 渲染樹 (Rendering Tree) 其實就是 DOM 搭配 CSSOM 的結果，在用白話一點的方式來說，就是「最後會被渲染在畫面上」的結構樹，所以如果 CSS 樣式導致某個 Node 沒辦法顯示，（ 如display:none )，那麼他就不會出現在渲染樹上。 Step.5 產生畫面編排 ( Layout ) 我們已經取得代表元素層級關係的 DOM 樹結構，也匹配了個元素對應的樣式，最終搭配兩者產生出了渲染樹，現在我們離最後產生可視畫面的階段已經不遠了，但是還差一個步驟，我們還必須弄清楚所有元素的實際位置，以及元素該如何呈現，那就是產生畫面編排 ( Layout ) 的步驟。 Layout 產生的方式，會跟 meta tag 裡面的 viewpoint 屬性有很大的關係： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; viewpoint 的 meta tag 用來告訴瀏覽器，頁面要怎麼縮放，還有維度，就是指畫面像素（瀏覽器畫面）跟螢幕像素（硬體）的比例，content 之中，width 用來設定瀏覽器畫面寬度是多少，把他設定成 device-width 的話就是在告訴瀏覽器，畫面顯示的螢幕寬度要跟硬體裝置相同（手機、電腦），如果沒給 width 值的話，瀏覽器就會使用預設的 980px 來當作預設的畫面顯示寬度。這個屬性在 HTML5 後出現，常用在 RWD 的設計實作之中。 initial-scale=1.0 是指預設的縮放程度，最常見的值也是預設值，就是 1 。 Step6. 繪製、產生畫面 到最後一個步驟，瀏覽器進入到了繪製階段，前面提到一連串很抽象的設定跟結構，終於可以被轉換成一個個像素，繪製階段所花的時間會跟 DOM 結構樹 與 CSSOM 樹的大小、規模有關，越複雜的結構或是樣式就會需要更多時間，應該不難理解。 從開發者工具看渲染順序 我們透過瀏覽器的檢查工具，也能看出上面講的 CRP 六個步驟，是不是真的依照順序進行，以 Chrome 為例子，打開開發者工具，並切換到 Performance 之後，按下錄影，重新整理之後結束錄影，就能夠看到這段時間內瀏覽器是怎麼產生畫面的： 對應前面步驟說明： 1、2： 拉取資源並解析 DOM 樹 為 index.css 解析 CSSOM 樹 執行 JavaScript 檔案 （ index.js ) 根據 viewpoint 的 meta tag 產生layout 繪製螢幕 參考資源 Google 在 Udacity 的教學真的講的蠻仔細的，搭配圖文也能更讓學習者一目瞭然： Google 的教學","link":"/2020/01/05/iron30-25/"},{"title":"JS 原力覺醒 Day26 - 常用 API： setTimeout / setTimeInterval","text":"來講一下常用到的瀏覽器 API ，其實前面在講 Event Queue 的時候就已經提過 setTimeout 了，不過這邊就讓我們從更具實用性的層面來看這些方法。 Outline setTimeout / setInterval 使用 setTimeout / setInterval 清除 this in setTimeout / setInterval callback 解決回呼函式內 this 的問題 setTimeout / setInterval 、迴圈與 Closure setTimeout / setInterval 使用 setTimeout 前面有提到 setTimeout 的基本使用方式，而第一個參數傳入的 callback 會被推送到 Event Queue ，待主執行環境堆疊清空以後，才會被執行 ，所以就算第二個參數設定的時間是 0 秒，也不會立刻執行。 function step(stepNum){ console.log(`step${stepNum}`) } step('1') setTimeout(function(){step('2')},0) step('3') // will print: step1 --&gt; step3 --&gt; step2 setInterval setInterval 使用方式與 setTimeout 的語法相同，差在 setTimeout 只會執行一次，而 setInterval 則會根據開發者給的時間間隔，每隔一段時間執行一次。 setInterval(function(){console.log('da') },1000) // print : da -&gt; da -&gt; da setTimeout / setInterval 清除 由於 setTimeout / setInterval 函式本身會回傳一個計時器 id ，我們就可以把這個 id 記錄下來，當頁面要離開用不到的時候使用 clearTimeout / clearInterval 將他們清除： let timerId = setInterval(function(){ console.log('do something') },1000) 清除計時器在以前可能還不是會非常被注重的問題，但是像現在主流前端框架把渲染工作交給 JS ，如果使用虛擬路由來控制頁面切換的話，就算頁面切換了，JS 檔案也不會重新載入，主執行環境會一直存在，因此前面設定的計時器在不需要時如果沒有清除，就可能會造成頁面運算的負擔。 this in setTimeout / setInterval callback setTimeout / setInterval 裡第一個回呼函式內的 this 如果沒有經過處理的話，預設都是指向全域環境 window ，因為這兩個都是屬於 window 物件底下的函式，我們可以推斷我們傳進去的回呼函式是在裡面被執行。雖然沒辦法直接看到 setTimeout 裡面的原始碼，不過可以推斷內容大概是像這樣 ，下面以 Pseudo code 示意： window = { ... setTimeout:function(timerFunc,time){ //several minutes later... timerFunc() } } 之前提過在思考 this 的連結的時候，有提到，「如何呼叫」函式將會影響 this 的指向，想一想「隱含」的繫結， 再對比上面的 setTimeout 內容，可以看出我們傳入的回呼函式在 setTimeout 被呼叫，但因為是直接呼叫，沒有隱含繫結，因此在內的 this 會指向全域。 解決回呼函式內 this 的指向問題 承上一段，那要怎麼樣才能讓 this 指向目前所屬的執行環境，讓開發者在撰寫程式碼的時候更不容易誤解？ 方法一 有一個方法是：使用箭頭函式，因為箭頭函式內沒有 this ，更準確來說， 箭頭函式內的 this 與他外部語彙範疇的 this 相等。 let boss = 'Yoda' let user = { name:'Luke', introduce:function(){ setTimeout(()=&gt;{ console.log('hey, ' + this.name) },1000) } } user.introduce() // print : hey,Luke 方法二 另外一個方法是，使用 Function.bind，這個方法跟 call 或 apply 都可以指定函式執行環境內要綁定的 this ，差別在呼叫 bind 後會回傳一個全新、綁定過 this 的函式。 let user = { name:'Luke', introduce:function(){ setTimeout(getName.bind(this),1000) } } function getName(){ console.log('hey, '+ this.name) } user.introduce() // print : hey,Luke setTimeout / setInterval 、迴圈與 Closure 這段要講的大概是最經典的面試考題，只要講到跟 Closure 有關的問題，通常一定會提到迴圈。 先來看這段例子： for(var i =0;i&lt;10;i++){ setTimeout( function (){ console.log(i) },1000) } 在一秒過後我們就很驚訝的會發現， JS 吐出了 10 個 10 給我們，這是因為 var 宣告是屬於 function scope 但是 for 迴圈並不是 function ，所以在之內宣告的變數 i 就等於是全域變數。也因此無法透過 fucntion 產生函式執行堆疊或閉包，於是這個回呼函式會被推到 Event Queue，待時間到要執行，去獲取i 的時候，全域的 i 早就已經被 for 迴圈修改而成為10了 ，所以才會有這樣子的結果 解方： 要解決這個問題我們只要想辦法讓維持 setTimeout 回呼函式與每個 i 的聯繫即可，還記得 let 屬於 block scope ？所以用 let 產生的變數是綁在會在不同的 block 上 ，對 for 回圈來說，每次 i+1 的迴圈迭代之後的，都是一個新的 block，再搭配 block scope 的特性，就可以在每個 block 留下與每個 i 的連結： for(let i =0;i&lt;10;i++){ setTimeout( function (){ console.log(i) },1000) } // print : 1,2....10 或是ㄧ樣利用 function scope 的特性： for(var i=0;i &lt; 10; i++){ getValueOf_i(i) } function getValueOf_i(i){ setTimeout(function(){ console.log(i) },1000) } 這樣一來當 i 以參數形式傳入另外一個函式時，就會被函式執行環境保留而產生閉包。","link":"/2020/01/05/iron30-26/"},{"title":"JS 原力覺醒 Day27 - JS 常用 API - Object.assign && Object.defineProperty","text":"今天要講的是是兩個在操作物件時常用到的 JS API ，有時候我們會需要做一些比較進階的操作，例如對物件屬性做一些比較細節的微調；還有複製物件，但是複製物件的話，因為物件傳參考的特性的關係，在結構複雜的物件上，往往需要特別處理，例如物件內的屬性是另外一個物件。所以我們也會帶到「深拷貝」和「淺拷貝」的概念。 Outline Object.defineProperty Object.assign 深拷貝 淺拷貝 Object.defineProperty Object.defineProperty 其實是 Object 函式建構子上的靜態方法（還記得 Obejct 其實是一個函式？），用來對某個物件直接定義一個新的屬性，用法如下： const object1 = {}; Object.defineProperty(object1, 'property1', { value: 42, writable: false }); 這個方法接受三個參數，第一個是要新增屬性的目標物件，第二個是屬性名稱，第三個是這個屬性的描述器設定。 屬性的描述器？那是什麼？ JS 內物件屬性的描述器有兩種類型，每一種各有不同設定值： 資料描述器 ( Data descriptor )： 資料描述器是一個帶有值的屬性，其實也就是你要定義屬性的 value 啦。這個屬性有可能是可修改、或是不可被修改的。 存取描述器 ( Accessor descriptor )： 存取描述器定義的內容包含的 getter 與 setter 兩個函式。要怎麼存、取這個屬性，就是由存取描述器來負責的。 兩種描述器都有屬於自己的屬性設定值，先分別介紹： 資料描述器上，有兩個可選值： value ( undefined ) : 定義這個屬性對應的值。 writable （ false ）: 定義這個屬性是某可以被指派，如果為 true 就代表這個屬性可以透過 如 ob.name= 'new value' 被更新。 存取描述器上也有兩個可選值： get ( undefined ) : 即物件的 getter 函式，是一個定義物件如何被取用的函式，當物件屬性被取用的時候會被呼叫。 set ( undefined ) : 即物件的 setter 函式，是一個定義物件如何被指派的函式。 剩下的幾個設定值是兩種描述器都能夠使用且可選、非必須的。分別是（ 括號內的是預設值 ）： configurable ( false ) : 定義了這個物件屬性的描述器設定是否可以被修改，如enumerable 、 writable 、 或是自己本身 configurable 。 enumerable ( false ) : 定義這個屬性在物件裡就屬於可以被巡訪的，也就是使用 Object.keys 或是 for...in 來對物件作遍歷的時候能不能夠存取到。 而要定義的物件屬性的描述器必須一定要是上述兩者中的其中一種，兩者無法同時屬於兩者。 Example - 描述器預設值 var o = {}; // 創造新物件 Object.defineProperty(o, 'a', {}); // empty descriptor setting Object.getOwnPropertyDescriptor(o,'a') //預設描述器值： // configurable : false // value : undefined // writable : false // enumable : false 剛剛說描述器無法同時是資料描述器跟存取描述器，也就是說在 ****defineProperty 的第三個參數描述器設定內，如果有 get 這個設定值出現，就不能再有 value ，否則就會報錯： var o = {}; // 創造新物件 Object.defineProperty(o, 'a', { value: 37, writable: true, enumerable: true, configurable: true, get(){ return 123 } }); //Invalid property descriptor. Cannot both specify accessors and a value or writable attribute Example - 自訂 getter 與 setter 函式 自訂 getter 與 setter 一樣是在 Object.defineProperty 裡面的第三個參數自訂屬性的行為： var o = {}; Object.defineProperty(o, 'a', { get() { return 'It will return this value if I access o.a' ; }, set() { this.myname = 'this is my name string'; } }); Object.assign Object.assign 用來複製所有物件內可被尋訪 (Enumable) 的屬性，而且複製的來源不限於某個物件，可以多個物件一起進行屬性的複製，這個方法的第一個參數跟 defineProperty ㄧ樣都是目標物件，後面可以有複數個參數，就是要被複製屬性的來源。而使用 Object.assign 來進行複製的時候，後面的相同物件屬性會蓋掉前面相同的物件屬性： let b = Object.assign({foo: 0}, {foo: 1}, {foo: 2}); ChromeSamples.log(b) // {foo: 2} 所以，如果我想要複製某一物件的內容到一個全新的物件上的話，只要這麼寫： let oldObject = { a:'a', b:{ c:'cinsideb' } } let newObject = Object.assign({},oldObject) console.log(newObject) //{a: &quot;a&quot;, b: {…}} 另外，如果只是單純要把某個物件內容複製到另外一個物件，可以用 ES6 後的新的、比較簡潔好閱讀的寫法 Spread ，也可以達到一樣的效果： let newObject = { ...oldObject } 淺拷貝 ( Shallow Copy ) 在使用 Object.assign 時有一個要注意的地方，就是他雖然可以複製屬性，但要是物件屬性的內容也是另外一個物件時，從這個屬性複製到新物件上的，也只會是這個內層物件的參考，而不是這個物件的拷貝，這個現象就稱為淺拷貝（可以理解為，只複製最外層屬性，往下被複製的都只有參考）。 let oldObject = { a:'a', b:{ c:'c' } } let newObject = Object.assign({},oldObject) newObject.b.c = 'modified c' console.log(oldObject) /* { a:'a', b:{ c:'modified c' } } */ 由上就可以看出，當我修改新的物件的內層屬性物件時，被複製的物件的內層屬性物件 (b.c)，也會跟著一起被改動。 深拷貝 （ Deep Clone ) 相對於淺拷貝，深拷貝就是完全的複製整個物件內容了。那麼如果要達到這個效果，我們可能要自己動手處理，檢查要複製物件的某屬性是不是物件，如果是的話，就要再以Object.assgn 複製一次，並且這個檢查要搭配遞迴的概念來檢查，才能確保完全的複製。 function cloneDeep(obj){ if( typeof obj !== 'object' ){ return obj } let resultData = {} return recursion(obj, resultData) } function recursion(obj, data={}){ //對物件屬性做巡訪 for(key in obj){ if( typeof obj[key] === 'object'){ // 如果是物件就繼續往下遞迴 data[key] = recursion(obj[key]) }else{ // 如果不是物件的話就直接指派 data[key] = obj[key] } } return data } let player = {name:'Anakin',friend:{robot:'R2D2'}} let player2 = cloneDeep(player) obj.name = 'Darth Vader!!!' player2.friend.robot = 'no!!!' console.log(player) // {name:'Anakin猿',friend:{robot:'R2D2'}} 參考文件 MDN 官方文件的說明 Javascript properties are enumerable, writable and configurable JS-淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy)","link":"/2020/01/05/iron30-27/"},{"title":"JS 原力覺醒 Day28 - JS 裡的資料結構","text":"隨著硬體規格條件的提升， 網站商業邏輯的運作也慢慢從以往的後端伺服器轉移到客戶端，因此前端領域的專業知識就變得越來越重要，隨著前端技術被重視，也開始慢慢出現 React 、 Vue 、 之類前端框架的生態圈出現，而後端則慢慢演變為單純的 API 伺服器負責提供資料的存取端口。同樣的，畫面的互動也是另一個越來越被注重的部分，因此怎麼實作出更精緻優雅的前端介面以及互動邏輯也是前端工程師們面臨的新挑戰之一。這些在在的都考驗了工程師們對 JS 這個語言本身更全面的了解。 如同前面所說，隨著商業邏輯慢慢著重在前端，許多資料的規格訂定也常常會跟隨著介面的結構而有所不同，這些隨著前端邏輯而被暫存在前端的資料，變得有點像是後端伺服器放在前端的副 @本。所以，前端工程師的經驗跟專業，就會在資料結構的選擇與判別使用的時機的能力上顯現出差異，而某些資料結構我們在前面的文章多多少少都有提到一些了。在這篇文章內，我想較全面的，對在開發上，常使用到或常見的資料結構做一些說明。 基本上有三種類型資料結構： 陣列型態的資料結構 ：Stack 、Queue 以「節點」為基礎的：Linked Lists、 Trees 在資料查找上非常方便的： Hash Tables Outline Stack Queue Linked Lists Trees Hash Tables 總結 參考文章 Stack Stack 具有後進後出的特性，堆疊的概念我相信各位 JS 工程師都已經非常熟悉了，而這大概也是 JS 內最重要的資料結構了，在之前講到執行環境堆疊的時候有提過。以程式的方式來說，堆疊的結構就是一個具有 push 跟 pop 兩個方法的陣列，push 可以把元素放到堆疊的最上層，而 pop 可以把元素從堆疊的最上層拿出來。 Queue Queue，序列 也是 JS 語言的核心部分之一，Queue 具有「先進先出」的特性，還記得我們之前提到的 Event Queue 、 MacroTask Queue 以及 MicroTask Queue 嗎？因為有了 Queue 這種樣子的資料結構，JS 才能夠具有非同步這麼具有識別度的特性。那麼以程式的角度來看，Queue ㄧ樣是有兩種方法的陣列：unshift 與 pop。 unshift 可以把元素放到 Queue 的最尾端，而 pop 則是把元素從最前端取出來，Queue 也可以反向操作，只要把 unshift 與 pop 換成 shift 與 push。 Linked List Linked List ，鏈結串列是一種有序的、且線性的資料結構，在 Linked List 上每一筆資料都可以被看作是一個節點 ( Node )，每個節點上都包含了兩個資訊：一個是要儲存的數值、一個是指向其他節點位置的指標。Linked List 具有以下特性： 是被一個一個指標串連起來的 第一個節點被稱為 head ，是一個指向第一個節點的參考指標 最後一個節點被稱為 tail 節點，是指向最後一個節點的參考指標 最後一個指摽指向的是 null Linked List 基本上有 單向（ singly ） 跟 雙向 ( doubly ) 兩種類型，在單向的鏈結串列中，只存在一個指向下一個節點的指標。 而在雙向的鏈結串列中，則會有兩個指標，一個指向上一個節點，一個指向下一個節點。 Linked List 由於結構的關係，可以在頭、尾，任何地方插入節點，因為只要改變指標的指向就可以了，所以只要搞懂運作方式，他也能實現前面提到的 Queue 跟 Stack 結構的行爲。Linked List 在前後端開發上也很有幫助，在前端 React 框架常常搭配使用的狀態管理器 Redux 中，從畫面到 Action 到 Reducer 這樣子的資料流，就使用了 Linked List 的思考方式，來決定資料的下一個目標（ 函式 )。在後端 Express 框架上則用 Linked List 來處理 Http Request 與 Middleware 層的資料流動。 接下來讓我們以雙向的鍊結串列來看看實際上在 JS 內是怎麼使用的，首先我們會需要節點的類別，這樣我們就可以自己指定節點跟下一個節點： class LinkedNode { constructor(value,prev,next){ this.value = value; this.next = next; this.prev = prev; } } let head = new LinkedNode(null,null,null) let node1 = new LinkedNode(1,head,null) let node2 = new LinkedNode(2,node1,null) let node3 = new LinkedNode(3,node2,null) node1.next = node2 node2.next = node3 然後我們可以再創一個 LinkedList 類別來記錄這些節點間的關係， class LinkList { constructor(value,prev,next){ this.head = null this.tail = null this.lenght = 1 } addToHead(){ } } Linked List 要能再頭地方加入新的節點成為新的 head，因此加入輔助函式看看： class LinkedNode { constructor(value,prev,next){ this.value = value; this.next = next; this.prev = prev; } } class LinkList { constructor(value){ this.head = null this.tail = null this.addToHead(value) this.lenght = 0 } addToHead(value){ const newNode = new LinkedNode(value); newNode.next = this.head; // 讓原本的 head 成為新節點的 next newNode.prev = null // head 並沒有前一個節點 this.head = newNode // 最後把原來的 head 換成新的節點 this.lenght += 1 return this.head } } let newList = new LinkList('first') newList.addToHead('second') newList.addToHead('third') newList.head.value // third newList.head.next.value //second newList.head.next.next.value //first 接下來我們再實作一個可以從中間刪除任意節點的方法，要找到 Linked List 的某一個數值並且刪除，就只能用尋訪的方式一個一個尋找，這裡我們用 while 回圈以一個類似遞迴的方式來尋找： class LinkList { constructor(value){ this.head = null this.tail = null this.addToHead(value) this.lenght = 0 } addToHead(value){ ... } removeFromHead(){ if(!this.head.next) this.head.next = null const value = this.head.value; this.head = this.head.next this.length-- return value } remove(val) { if(this.length === 0) { return undefined; } if (this.head.value === val) { this.removeFromHead(); return this; } let previousNode = this.head; let thisNode = previousNode.next; while(thisNode) { // thisNode 的參考會隨著 while 而不斷的往 next 去尋找 if(thisNode.value === val) { break; } previousNode = thisNode; // 同時也會不斷紀錄前一個節點 thisNode = thisNode.next; } if (thisNode === null) { return undefined; } previousNode.next = thisNode.next; // 一旦成功找到要刪除的節點，才能夠順利銜接前後節點，達到刪除的效果 this.length--; return this; } } 示範實做跟說明幾個函式到這邊，基本上只要知道怎麼修改節點的指向，就可以了解怎麼實作這些操作 Linked List 的方法，包括從 head 刪除節點、從中間新增、刪除節點，以及從最後面新增、刪除，讀者可以自己練習完成看看。 Tree 樹的結構跟 Linked List 有點像，也是從一個節點開始往下長，差別在於 Linked List 裡一個節點只能對到另一個節點，而在樹狀結構內，一個節點可以對到好幾個其他節點，也稱為子節點（ Child Node ) ，之前我們講到的 DOM ，正是一種樹狀結構，最上層的 html 是上層節點，而往下延伸出 body 與 head 等下層子節點。 而樹的結構也可以被加上特殊的規則，例如常聽見的二元樹結構， 就是從樹狀結構演變而來，因為在二元樹裡面，每個節點被規定只能擁有另外兩個子節點。而且左邊子節點的數值只能小或等於父節點的數值，而右邊子節點的數值必須大於父節點的數值，以這樣子排列方式，我們就可以有規律的去搜尋或是操作我們需要的節點，例如，整個二元樹的最小值可以在最左邊且最後代的子節點被找到，反之在最右邊後代節點則可以找到最大值。 在樹的搜尋上則有兩種相似的方式： 深先搜尋 ( Depth-First Traversal, DFT ) ： 把樹想成由最上面開始往下生長的結構，深先搜尋就是從最上面的根節點，往下垂直的搜尋，深先搜尋裡又分為三種走訪順序，以上面的二元樹圖為例，分別是： 前序 （ Pre Oreder ) ： 順序：訪問根節點 → 訪問左子樹 → 訪問右子樹 上圖順序： A → B → D → G → C → E → F → H 中序 ( In Order ) ： 順序：訪問左子樹 → 訪問根節點 →訪問右子樹 上圖順序： D → G → B → A → E → C → F → H 後序 （ Post Order ）： 順序：訪問左子樹 → 訪問右子樹 → 訪問根節點 上圖順序： G → D → B → E → H → F → C → A 廣先搜尋 Breadth-First Traversal , BFT ) 廣先搜尋則跟深先搜尋相反，是以水平方向為主的搜尋方式，在樹狀結構裡面，每往下長出一個子節點，就會被視為一層。深先搜尋在執行時是先查看節點有無子節點，如果有的話就盡量往下去搜尋，而廣先搜尋則是在搜尋時先檢查子節點有無其他同一層的節點，然後將這些同層子節點記錄下來，一個一個去搜尋，因此在執行廣先搜尋時，必須用到 Queue 來輔助。 上圖順序： A → B → C → D → E → F → G → H 樹狀結構與前面鍊狀串列結構實作方法相似，而且樹狀結構若要往下探討可以有很多種變形，例如把不同層的節點串在一下之後就會變成複雜的圖 ( Graph )，這些內容多到可以再寫一篇文章，因此在這邊先不提供範例。 Hash Table 雜湊表是根據鍵值 （ Key ) 來查找對應記憶體位置的資料結構。陣列就是一個很類似 Hash Table 的結構，只不過陣列是利用「索引」來查找資料，因此只能是數字。 可以把 Hash Table 想成是建立在陣列上，透過將不同字串轉成對應的陣列索引來查找，而達到比較靈活的鍵值查找，要達到這樣子的效果，我們會需要實作一個 Hash Function ，來把字串轉換成索引。 Hash Function 的運作方式大概會是給每個字元對應的可運算數值，當要查找的時候就把字串內所有字元的數值加起來然後給陣列當成索引值，如果加起來的數值太大，陣列沒有那麼多空間，就必需透過另外的規則簡化（如：加完的數值 mod 10 ) 來取得對應、可行的索引。 getCharNum(char){ return charCodeAt(char) } hashFunction (key) { let hashCode = 0 key.split('').forEach(char=&gt;{ hashCode += getCharNum(char) }) return hashCode % 10 } 上面是一個 hash function 的實作，當然這只是簡化的範例而已，真正應用在現代系統環境的實作邏輯複雜非常多。透過 Hash Table 的運作方式我們可以利用字串來存取對應的數值，有沒有覺得很熟悉，想到什麼？沒錯就是 JS 的物件！從結果來看 JS 的物件非常像是 Hash Table 的結構，不過根據我的調查結果，有一說是這點會根據 JS 引擎的實作而有所差異，有些引擎裡面是透過混合 Linked List 跟 Hash Table 兩種資料結構來實作物件。 總結 終於講完了這些常見的資料結構，看完之後你應該可以發現這些資料結構大概有一半在前面 JS 相關內容都有提到，分別是： Stack ：Call Stack Queue ：Task Queue Linked Lists ：原型鍊 Tree : DOM Hash Table : 物件的 鍵 -值 結構 這些部分如果不深入去看這個語言運作方式的話是不會發覺的，這些資料結構也可以應用在許多系統資料的運算。雖然這個章節只能很粗淺的介紹，但我希望讓原本不熟悉資料結構的人，下次再看到類似的東西可以不會那麼害怕，也能夠更冷靜地往下研究原本要鑽研的知識細節。 參考文章 Data Structures in JavaScript Objects and Hash Tables in Javascript Basics of Hash Tables Hash Table","link":"/2020/01/05/iron30-28/"},{"title":"JS 原力覺醒 Day29 - Set / Map","text":"ES6 之後加入兩種新的資料結構：Map 跟 Set 。 Map 與 Set 都是像字串跟陣列這樣可以被尋訪的類型，也就是說可以使用 for 迴圈去一個一個查找跟操作他們的值。今天就來說明一下這兩個類別跟使用方式吧！ Outline Set Map Map 與 Object Set Set 的中文翻譯與數學裡面的「集合」相同，「集合」是某個定義好並且具有相同性質的元素的集合，講白話一點就是「一堆東西」。在 JS 內的集合當然代表「一堆值」，他跟陣列有點像，差別在 Set 能夠讓開發者可以方便快速的儲存不重複、獨特的數值。至於 Set 內儲存的元素內容沒有型別限制，可以是純值也可以是物件型別。 Set 除了具有儲存不重複數值的性質外，在上面還有一些很方便的方法可以直接處理數值，讓我們陸續來看看，首先創造一個新的 Set ，創造新的 Set 很簡單，只要在 Set 的建構子傳入一個陣列即可： let set = new Set([1,2,3,'Hello','World',true]) 在 Set 類別上有許多方法讓我們可以用比較語意化的方式操作 Set 內容： add( value ) : 新增一個元素到 Set 內 clear() ：刪除所有 Set 內的元素 delete( value) ：刪除 Set 內特定的某個元素 forEach() ： 跟 array 上的 forEach 功能相同 has( value ) ：檢查 Set 內有沒有對應值的元素，這個功能如果在陣列內，必須透過 indexOf 來檢查才能達成。 values() ：會回傳 Set 內所有數值 size ：回傳 Set 元素長度 就像前面說過的， Set 內儲存的是不重複的元素，因此如果有相同數值的元素再次被傳入，這個數值就會直接被忽略。 set.size //6 set.add('Hello') set.size //6 對 Set 做巡訪的方式跟陣列很相似，一樣可以用 forEach 方法，甚至 Set 可以很方便的直接轉為陣列 ： let setArr = [...set] 這個特性非常好用，利用這點我們就可以很快速的過濾出陣列內的重複值！ let duplicatedValueArr = [1,2,3,5,10,19,10,4,5,6,3,1,2] let uniqueArr = [...new Set(duplicatedValueArr)] 這樣子是不是既方便快速又簡潔？ 如果單純使用陣列可能還需要透過 filter 跟外部變數來儲存重複值輔助檢查，使用 Set 的話，這些功夫都可以省去。 Map Map 也是跟陣列、跟 Set 具有相同特性且可被巡訪的物件型別，差別在於， Map 跟物件ㄧ樣是鍵值的組合，也就是說，Map 同時具有跟陣列ㄧ樣可以被巡訪的特色，同時也有物件儲存任意屬性跟數值的能力。 Map 類型上的方法也與 Set 大同小異，差別在 Set 新增元素的方法是使用 add ，而 Map 內必須用 set 方法 ，且新增元素時必須傳入兩個參數，第一個是要儲存的鍵 ( key )，另外一個是要儲存的數值內容 ( value )。 創造新的 Map 的方式與創造 Set 相同，但由於 Map 是鍵-值對的結構，傳入建構子內的陣列內不能夠像 Set 那樣只是個單一元素，而必須要是個鍵-值的組合，所以我們可以用二維陣列來達成，大概像是這樣： let map = new Map([['name','Luke'],['Hello','World']]) 取得 Map 元素 ： map.get('name') // Luke 新增元素 ： map.set('Greeting','I am Anakin') // { ... 'Hello'=&gt;'World', 'Greeting'=&gt; 'I am Anakin'} 其他像是刪除特定元素或是刪除所有 Map 內元素則都跟 Set 上的方法差不多： map.delete('Hello') map.clear() map.size Map 與 Object Map 其實跟物件ㄧ樣都是 鍵-值 的組合，事實上這些結構相似的類型有許多種，如，那麼使用 Map 相比於使用物件有什麼好處呢？還記得前面提到在 JS 內除了原始型別以外的型別都是物件型別嗎？這代表除了物件以外像是 Array 以及Function 這樣的型別都是繼承自 Object，這其中當然包含 Map 。 所以這兩種型別才有這麼相似的結構 ，性質相同的部分就不用多說了，但是這兩者還是有一些不差異，這些差異可能足以影響資料存取的複雜度以及程式碼閱讀的難易度，所以我們可以認識一下究竟兩者有什麼不同的地方： 鍵值的類型： 在物件內的鍵值（或屬性名稱） 必須是字串或是 Symbol。而在 Map 內，鍵值可以是任何型別，這包含任何其他的物件或是陣列 。你當然可以試試看用物件來當作另外一個物件的屬性名稱，不過這個物件會被 JS 強制轉型變成 [object Object] 而變成另外一個字串屬性。 let o = {} let anotherObj = {} o[anotherObj] = 'anotherObject' // {'[object Object]' : anotherObject} let theThirdObj = {} o [theThirdObj] = 'theThirdObj' // {'[object Object]' : anotherObject} 元素的順序，在 Map 裡面，元素被新增進去之後，順序就會被固定下來。而在 Object 內則無法保證。 繼承關係：Map 繼承於物件 （ Object ) ，而反過來則否，因此在 Map 上那些方便的方法，在 Object 上無法使用。 let newMap = new Map() console.log(newMap instanceof Object) //true console.log(Object instanceof newMap) //false 可被巡訪：這大概是最大的差別了，因為一般物件上並沒有提供可以直接巡訪的方法，只能透過 for .. in 迴圈達成，或是必須透過 Object.keys 方法把屬性轉為陣列，但是在陣列 、 Set 跟 Map 上都有 forEach 方法可以直接對裡面的元素做巡訪。 Map 與 Object 使用時機 Ｍap 在操作元素上雖然提供了許多語意化的方法，但有時候我們還是會需要像一般物件那樣方便新增元素的方式，最後我們就來看看兩者各適合怎樣的使用情境： 屬性值：這也是兩種型別最大的差別。在知道屬性值都單純只是字串時，使用一般物件就好，因為 Map 雖然可以儲存任何型別的數值，但是因為使用函式建構子創造物件，且在新增、修改元素時必須透過 get 、 set 函式幫忙，因此速度上會比單純使用物件還要慢。 JSON 格式：在需要以 JSON 格式來進行開發作業時，選擇一般物件。因為 JS 內的物件可以很直接的被轉為 JSON 格式，這在進行 API 溝通時非常好用。 順序性： 在 Map 內的元素順序會被保留，因此在處理資料時，如果維持順序的穩定很重要，就可以考慮使用 Map 。 需要一些特定功能：有時候我們會需要某個函式來取得其他屬性資訊，物件因為存取方便的關係，在物件內的屬性如果是函式，就可以直接被執行，Map 就比較麻煩。 總結 除了前面我們提到的幾個基本資料結構，今天我們又認識了 JS 內新的 Map 跟 Set 兩種新的資料型別。在資料結構選擇上永遠是根據你的需求而定，雖然用簡單的物件或陣列組合或許就可以達到，多認識一些這樣子的資料結構不一定會大幅度增加開發速度，但絕對會讓你在開發時有更多其他潛在更好的選擇來達成你的需求。","link":"/2020/01/05/iron30-29/"},{"title":"JS 原力覺醒 Day03 - 執行環境與執行堆疊","text":"這個章節我們會直接介紹幾個專有名詞，包括前一章節提到的執行環境，加上執行堆疊，如果想要了解後面的提升、範疇等觀念，這些概念都是必要的，在後面的章節也會不斷被提到。 Outline 執行環境 執行堆疊 執行環境 ( Execution Context ) 在前面提到直譯語言必須依賴環境才能被執行，在 JavaScript 裡面，提供這個環境的工作就是由 JavaScript 引擎來擔任。所以當我們說「瀏覽器執行/讀了你的 JavaScript 程式碼之後出現了錯誤」，其實並不真的是瀏覽器去讀你的程式碼，而是身為瀏覽器一部分的 JavaScript 引擎在做這件事。上面提到，能夠讓程式碼被執行的環境也被稱為「執行環境（ Excution Context ）」。 執行環境是一個抽象的概念，概括地來說，任何你JS 程式碼被執行、讀取的地方，像是 function 裡、甚至全域 ，都可以是執行環境。執行環境可以分為以下幾種： 全域執行環境 （ Global Ex. Context ） ： JavaScript 預設的執行環境，不在任何函式裡面的程式碼就是在全域執行環境內，這個執行環境會做幾件事情： 創造全域環境（全域物件），（在瀏覽器裡面是 window ，在 Node.js 內是 global ) 創造 this 物件，並將其指向這個全域物件，你可以打開瀏覽器的 console 並把 this 的值印出來試試看，關於 this 的指向在後面會提到。 記憶體指派流程（後面會提到） 函式執行環境（ Functional Ex. Context ）： 每當一個函式被呼叫，一個全新的執行環境也會跟著被創造出來，這也代表 JS 已經開始解析你的程式碼並執行。函式執行環境產生時做的事情差不多，差別是不會產生全域物件，而相對的會在函式內產生 argument 物件，內容是執行階段時函式引數的內容。每個函式都有屬於自己的執行環境，但是只會在函式被呼叫的時候才會產生，這種執行環境可以同時存在好幾個。 eval 函式內的執行環境：在 eval 函式內可以透過字串的方式去執行 JavaScript Code ，但是因為 eval 函式現在已經不常被使用，普遍也不被推薦使用，這邊就先不細提，想知道為什麼不被推薦，可以搜尋關鍵字「Eval is evil.」。 執行堆疊 ( Execution Stack ) 上面我們提到，每當函式被呼叫時，就會產生對應的執行環境，而當函式裡有另一個函式被呼叫時，執行環境是按照什麼順序被產生的？ JavaScript 使用後進先出的「堆疊」結構，依序來儲存隨著函式宣告所產生的執行環境。 各位應該都看過全面啟動吧？主角們為了完成任務不斷深入更下一層的夢境，而在每一層都有必須達成的目標，之後才能夠返回上一層，否則任務就會失敗。今天提到的堆疊其實是類似的概念，我們把「進入夢境」的動作對應到「函式呼叫」。 而到了下一層新的夢境，則呼應「產生執行環境」。你可以在裡面做任何你想做的事情，做完之後 return 回到上一層函式。放心，除非你喝醉了，否則寫 JS 是不會讓你進入混沌狀態的。讓我用一段程式碼來舉例，看看執行環境是如何被產生並且堆疊的： let movie = 'Inception' function firstLayerDream(){ return secondLayerDream() } function secondLayerDream(){ return thirdLayerDream() } function thirdLayerDream(){ return 'Mission Complete.' } let result = firstLayerDream() 當第一個位在全域的函式 firstLayerDream 被呼叫的時候，專屬的執行環境就產生了。 並且裡面的程式碼馬上就被「執行」（也就是開始被解析），直到碰到 return 關鍵字才會結束並離開這個執行環境。 隨著裡面的函式呼叫，第二層、第三層，的執行環境也被創造在裡面，一樣要等到 return ，才會結束並離開。 於是就有了這樣子的先後關係順序： 「堆疊」本身其實是一種資料結構，在堆疊裡面，某個元素之上如果還有有其他元素就無法被取出，因此有了「先進後出」的特性。如果你有吃過罐裝的品客應該可以很輕易知道我在說什麼，想想看，你沒辦法直接吃最底部的洋芋片對吧！ 總結 今天稍微介紹了幾個非常重要的專有名詞，目前為止都還沒有進入 JS 語法的範疇，但這些觀念對於接下來的內容理解至關重要，請讀者一定要確定了解再往下，別擔心，如果有不理解的，隨時可以透過無線電聯絡我。","link":"/2020/01/02/iron30-3/"},{"title":"JS 原力覺醒 Day30 - 我是怎麼活過這三十天的？","text":"總算來到最後一天了，最後一天不會有技術內容，只會有很純的純 Mur Mur，想聽的再請留下。最後我打算記錄一下這三十天的感受，給其他沒參加過鐵人但是正在猶豫要不要參加的朋友參考。 普遍看到參賽方式有幾種情況： 精明準備型：囤好囤滿 30 天，完全事先囤貨所以內容超精緻 微囤貨：不事先準備太多，只囤幾天貨用來緩衝 硬派：「 什麼！？不就是要現學現賣才叫做鐵人嗎？ 」的類型 老實說我認為如果不事先準備的話，那麼能不能完賽跟主題的選擇還有自身對主題熟悉度會有很大的關係，所以如果你也正在思考要不要參加，可以從這點著手。如果主題是你想寫但不熟，可以考慮現在開始到下次開賽前先慢慢累積文章量；或者你覺得對主題比較上手，可以挑戰看看自己在短時間內對知識的理解程度。 30天連續發文不只考驗技術 經過評估，我走的是微囤貨路線，因為我是在 9/2 開賽前幾天才知道有鐵人賽這個活動，剛好我的下一個近期目標是對 JS 這個語言更有系統性的認識，當時是覺得這個活動可以用來挑戰一下自己，也正好可以之前寫的 原子化學習 裡面把知識最小化的學習方式做實作驗證，所以想了一下大概要寫什麼之後就跳坑了。到了開賽期限 9/16 前一天，我硬生出大約 10 來篇準備留著緩衝。 沒想到正式開賽才發現我完全低估每天必須發文所帶來的壓力了，因為事先沒有累積太多文章的關係，我幾乎每天都在想著下一篇文章的內容怎麼寫、大綱怎麼擬定、要怎麼畫出核心概念圖才能讓人比較好理解之類的問題。這樣子的狀況持續到大概第 20 篇的時候是最痛苦的，因為越後面的主題我越不熟，需要越多時間，而前面的幾篇卻也因為思考解說方式跟準備圖例的關係花了不少時間，留下來的緩衝時間所剩無幾。 在這個時間點想繼續寫覺得吃力，想放棄又覺得不太對，瞬間覺得自己好像在跑一場已經完成 2/3 ，明明心裡知道快結束了但眼前就是還看不到終點線的尷尬窘境。所以我深深覺得鐵人賽除了考驗技術熟悉度更考驗筆者的心理耐力。在最後雙十連假那幾天實在是最難受的，雖然咬著牙硬寫完了，但是基本上我是ㄧ邊配獵人邊寫完的（喂 使用工具 工欲善其…咳咳，好廢話不多說，稍微介紹一下我這幾天用來幫助寫文章工具，基本上有三個： Notion 在正式開賽之前，我先用 Notion 的 Table 整理了三十天的大綱，雖然最後沒有完全ㄧ樣，不過可以讓自己對文章主題有個底，時間的掌握也比較精準，哪些主題自己比較不熟的話就要預留比較多時間。 簡單的流程圖繪製軟體 這種軟體的選擇就比較多，我是選 Sketch，一來之前有學過一點，二來覺得他匯出圖片很方便，雖然他主要是用來前端介面設計的工具，但是拉拉簡單的區塊跟流程箭頭還是很好用的。還有另外一套網頁版繪圖軟體也很推薦：Draw.io 瀏覽器開發者工具： 因為我寫的主題不是製作產品型的主題，許多範例程式碼只要可以馬上確認結果就好，這個時候整個瀏覽器都是我的實驗場 :D 是音樂，我加了音樂 如果你以為我是像老派英雄主義電影裡的主角ㄧ單單靠著強大的意志力就輕輕鬆鬆寫完 30 篇文章練成鐵人那就錯了，我也希望我可以。 我曾經抱著很中二的想法，覺得如果世界上沒有音樂的話，我們幹嘛活著？老實說我現在還是深深這麼想的，大概今後也會一直這麼中二下去。總之最後來介紹一下陪伴我度過這地獄般 30 天的幾首曲子： Tauk - Horizon ： 風格上屬於前衛搖滾，我很喜歡他們華麗的效果器加上風格多變的主奏電吉他，雖然沒有人聲，但總能聽得我熱血沸騰，附上近期喜歡的一首曲子： Takami Nakamoto - Ashes： 這個音樂家的作品風格定位上還是比較偏電子舞曲，一般人聽來可能會覺得比較實驗性或藝術性，但我真的很喜歡各種奇異材質的聲響。想暫時脫離現實生活看一下不ㄧ樣世界樣貌的絕對推薦（建議戴耳機）： Mariya Takeuchi - Plastic Love : 這首毫無疑問是經典，我真的很喜歡遍佈整首的 Disco 元素，前奏剛下沒多久眼前就浮現煙霧彌漫然後雷射燈球光芒四射的場景，查了一下定位屬於 City Pop ，City Pop 是在 1970 日本傳統音樂受到西方音樂文化元素的影響而發展出來的獨特曲風，在當時由山下達郎組成的樂團 SUGAR BABE 帶起風潮。而竹內瑪莉雅就是山下的妻子，也是早期非常有名的音樂家之一，這首歌在前陣子 City PoP 復甦的時候出現在我的推薦歌單內，聽過後立刻愛上。 The Brand New Heavies : 這個團體是 Acid Jazz (酸爵士) 的經典團體之一，Acid Jazz 緣起於 Disco 文化，在 1980 年代開始變成風潮，當時舞廳的 DJ 嘗試將爵士樂中的樂句加以取樣，融入電子音樂裡面並融合了靈魂樂、Funk、R&amp;B 等曲風，因而吸引了年輕世代跟老年族群的注意，也是一個讓當代大眾重新開始接觸爵士樂的契機。 雖然在 1987 年由知名唱片經營者 Eddie Piller 與 DJ Gilles Peterson 創立同名自有品牌後才正式被命名，不過 Acid Jazz 這種風格受 60 年代迷幻文化影響至深。（ Acid 同時也是迷幻藥的別稱 ）所以你常常能在這種曲風裡面聽見運用電子特效達成的迷幻效果，同時又因為強烈的律動感而忍不住開始擺動身體，讓我們來聽聽看 The Brand New Heavies 今年出的專輯同名歌曲，你一定會很喜歡： 總結 原本以為在我整理完過去的學習經驗，寫出原子化學習已經是我自己在今年最有標誌性的里程碑了，沒想到又幹了一件突破自己耐力極限的事情啊 (X。老實說好幾次都以為我沒辦法完賽了，我也不知道是什麼讓我可以支撐到最後，也許是賽期後半段開始陸陸續續有人追蹤，甚至有讀者會參與內容的討論以及告知筆誤，讓我覺得有莫名一股一定要繼續寫下去的責任感。 其實後面還想有寫但來不及寫的主題：演算法跟設計模式，但在我寫這篇文章的當下，已經有些厲害的工程師以演算法當成 30 天的主題並且已經或快要完賽了： 透過 LeetCode 解救美少女工程師的演算法人生 前端工程師用 javaScript 學演算法 模組化設計 上面稍微推薦一下幾個很棒的相關系列，接下來完賽後我陸陸續續也會去看之前沒時間看的那些主題，如 神Q超人的 TypeScript 或是 六角校長的職場教學，讀者有興趣的話之後也可以跟我一起惡補回來 ( X 。","link":"/2020/01/05/iron30-30/"},{"title":"JS 原力覺醒 Day04 - Function Scope  / Block Scope","text":"今天我們要來談談「範疇( Scope )」。 Outline 詞彙環境 （ Lexical Environment ） 什麼是範疇 （ Scope ） Function Scope Block Scope 總結 語彙環境 （ Lexical Environment ） 在講到範疇以前，我必須先提一下一個很重要而且相關的概念，那就是語彙環境，弄清楚語彙環境之後，後續我們講到範疇就比較能夠區分差異性。語彙環境代表程式碼在程式中實際的物理位置。白話一點來說就是： 你把這段程式碼寫在哪 ? 既然是「詞彙」，就代表跟文法、語法相關，所以跟語法分析脫不了關係。語彙環境會影響 JavaScript 與法解析器分析程式碼的結果。回憶一下前幾天我們提到 JS 引擎的時候，JS 在被執行時，會先會被丟給語法分析器解析。 還記得抽象語法樹 ( AST ) 嗎？某段變數宣告寫在全域，或寫在函式宣告裡面，都會產生不ㄧ樣的抽象語法樹。語彙環境的差異就由這個階段產出的 AST 來決定。因此，程式碼的實際位置對我們後續在 JavaScript 其他觀念時非常重要。 什麼是範疇 （ Scope ） 上一章節我們提到除了全域的執行環境 ( Global Ex. Context ) 之外，每當一個函式被呼叫的時候，一個對應的函式 （ Function Ex. Context ）執行環境也會被產生，執行完之後就會離開。而在這個由函式裡面宣告的變數只能在離開該執行環境之前被取得、採用，而在全域執行環境下也無法直接取得在函式內宣告的變數。像這樣有限的存取範圍就是 「 範疇 」。用白話一點的方式說： 範疇是變數可以被使用的範圍 再讓我們來看個這段程式碼： 我在全域環境底下想要透過 console 取用 hello 函式裡面的變數，卻得到了「 localText is not defined. 」的錯誤，這是因為在取用該變數的當下，hello 函式並沒有被呼叫而產生執行環境，所以對全域來講這個變數是不存在的（ 沒有被宣告 ）。這就是 Scope 的基本概念。 Function Scope Function Scope 可以從字面上直接理解為「 在 function 內的 Scope 」，或是「由 function 來決定 Scope 」。延續上一個例子，我在全域環境底下沒辦法取用函式內的變數，是因為該函式的執行環境還沒有被產生，所以我們只要想辦法讓它產生就行了。但要記得離開執行環境，也就是「結束這個函式之後」，在裡面所宣告的變數就無法被取得了，所以只能在函式內被取用。 那如果是反過來，在函式內想要拿到函式外面宣告的變數的話，會不會有問題？ 答案是可以的，因為只要還沒有結束整個 JS 主程式，全域環境都會一直存在，而 JS 在找不到變數時，預設的行為就是會向外尋找有沒有相同名字的變數。因此不會有像前一個例子一樣找不到變數宣告的情況產生。 Block Scope 前面說到 Function Scope 是由函式來決定範疇，這是之前 ES5 版本的行為，在 ES6 之後，出現了 let 、 const 等兩種宣告變數的關鍵字，讓我們除了使用 funciton 來定義範疇，也能 「區塊 ( Block )」來定義。什麼是區塊呢？區塊就是兩個大括號裡面的範圍（{ 、 }）， if 判斷式 、while 或是 for 迴圈語法用到的大括號範圍就是 Block ，當然， function 的大括號也算。 所以什麼是 Block Scope 呢？其實有個 JS 之前就存在的語法 「 try / catch 」 就有 Block Scope 的特性，讓我們先來看看一段程式碼： 由上面這段程式碼來看，在全域的部分，還是可以取得 foo 變數，因為對使用 var 宣告的變數來說，有沒有大括號並不影響範疇，再來讓我們仔細看看 catch 這個特殊語法區塊，他不是函式，但是卻有一個系統提供的變數 err ，這個變數只能在 catch 區塊裡面被使用（通常是拿來丟出錯誤），當我們從全域呼叫時，就會產生錯誤，像這樣的行為就是 Block Scope 的特性。簡言之： Block Scope 就是用大括號去定義範疇。 總結 這個章節我們了解什麼是範疇、Function Scope 以及 Block Scope 的觀念了，接下來讓我用一個簡單的例子，整合 var 、 let 、const 等宣告方式，看看兩種定義 Scope 的方式會造成變數存取上有什麼不同的結果 : 我們在全域的環境下呼叫 bar 函式，照理說在該函式內產生的變數都可以被存取到，但因為 Block Scope 的關係，由 let 與 const 宣告的變數只能在 if 判斷式內被取得。 因為使用 block scope 能夠更靈活地去管理所宣告的變數，避免重複宣告導致的混淆，在 ES6 出現之後， let 與 const 廣為被推薦使用。","link":"/2020/01/02/iron30-4/"},{"title":"JS 原力覺醒 Day05 - Scope Chain","text":"在上一章我們針對什麼是範疇 ，以及兩種不同的範疇做了說明，而如果 JS 在範疇內找不到某變數， 就會向外尋找。在這章節我會針對這個預設行為做比較詳細的說明。 Outline 複習一下執行堆疊 範疇鍊：攸關語彙環境 複習一下執行堆疊 這邊我直接上一個稍微複雜點的範例： 我們從全域呼叫了 a 函式，產生了 a 執行環境，後又在 a 函式裡面呼叫了 c 函式，最後在裡面才呼叫了 b 函式 ( a → c → b)，因此會有一連串的執行環境依序被產生，而行程執行堆疊。把概念套用到我們之前的模型，（你現在應該可以想像了），大概長這樣，： 範疇鍊：攸關語彙環境 在 function 產生的執行環境內一但找不到某個變數，預設會向外部環境尋找看看該變數有沒有在外面被宣告，這裡的「外部環境」是什麼呢？有人可能會很直覺的看向上面的執行堆疊圖，然後說這個外部環境是上一個執行環境的堆疊。 其實並不是這樣，這邊有一個很重要的觀念，也是今天的重點： JavaScript 會根據前面提過的「語彙環境」，也就是程式碼的實際位置（全域 或是 函式內），來決定要往哪裡去尋找這個找不到的變數。 因為 函式 c 在 函式 a 的裡面，因此我們可以說 c函式的外部語彙環境在 a 函式，以此類推，b 函式的外部語彙環境則是全域環境，因此當我們在 b 函式裡面想要呼叫 c 函式內部的變數的時候，理所當然是找不到的（因為 JS 會從 b 函式的執行環境往全域尋找）。 最後附上對應的程式碼圖來驗證上面的說明： 今天的主題其實就是上述的觀念，所以只要能夠了解執行環境與語彙環境的差異，就能知道什麼是「 Scope Chain ( 範疇鍊）」了，當執行環境往外部環境尋找變數，仍然找不到的時候，就會不斷往更外一層的語彙環境去尋找，直到找到這個變數或是找到全域環境為止（如果到全域仍然找不到，就會跳錯誤）。 例如在這個範例裡面的 c 函式，如果想要取用全域變數的時候，會先往外（ a 函式）尋找，發現找不到，才又往全域環境尋找（可往上參考語彙環境堆疊圖）。這一連串的查找動作所產生的物理位置的裡外關係（而不是執行環境產生的先後順序），就是 Scope Chain 。","link":"/2020/01/02/iron30-5/"},{"title":"JS 原力覺醒 Day06 - 提升 Hoisting","text":"今天我們要提到另外一個講到 JS 一定會提到的概念，就是提升 ( Hoisting )，提升是 JavaScript 裡面特有的行為，指的是在宣告一個變數或是函式之前，就先使用它，而且不會出錯，懂了這個概念之後，很多疑雲應該也會迎刃而解。 Outline 執行環境創造 JS 最特別的地方就是在你要使用一個變數之前，不一定要先宣告，只要在相同環境底下的其他地方有宣告，就不會發生錯誤，常見的其他語言如果不先宣告，通常就會出錯。這個現象對其他語言的使用者來說，可能會有點疑惑，不過當我們了解底層語法解析器的運作模式之後，就不會那麼難以理解了。 hello() console.log(greeting) // undefined var greeting = 'hello , master.' function c3po () { console.log('c-3po has been called!') } 上面這段程式碼不會出錯，看起來就像底下的變數跟函式宣告被拉到這段程式碼的最上面， 回想一下前面我們講到 V8 引擎，全域執行環境產生之後會做兩件事情： 產生全域物件 window 產生 this 物件 記憶體空間的指派 其實不只這樣，在執行環境裡面用到的變數跟函式，總要有地方存放，所以在這個階段還會做幾件事情： 會為所宣告的變數保留記憶體空間，但還不會指派程式碼寫入的值，只會給初始值 undefined。 也會為一般的函式宣告（使用 function 關鍵字宣告的具名函式）保留記憶體空間，且會將整個函式內容存入記憶體空間。 所以這個變數記憶體空間被保留到哪裡？這個地方就是全域記憶體 ( Global Memory ) ，或稱記憶體堆積 （ Heap ）。 在這個階段，執行環境正好「剛產生」後，所有宣告的變數都只有做保留記憶體空間的動作，還沒有被赴值，因此也被稱為「創造階段」。創造階段結束後，就會進入「執行階段」，直到這個時候前面宣告的變數才會被赴值，程式碼才會真的被執行。 執行環境與提升 上述在「創造階段」所做的，為變數及函式保留記憶體空間的動作，就被稱為「提升( Hoisting )」。提升這個動作在不論是全域執行環境還是函式執行環境，所有的執行環境都會進行。 let 、const 的提升 let 、const 兩個是在 ES6 之後才出現，用來宣告變數的關鍵字，這兩個關鍵字沒辦法像使用 var 那樣，在函式宣告之前就使用，乍看之下，在這兩個變數上並不會有提升的動作。但是其實是有的，只是 JS 在變數正式被赴值之前不讓你使用而已，在同一執行環境底下，使用 let 宣告變數的語彙環境（實際位置）之前的區域，被稱為 TDZ (Temporal Dead Zone) 。 console.log(name) // Reference Error! function doSomeThing( ){ console.log(name) // Reference Error! } doSomeThing() // 在 let 、 const 變數宣告正式發生前，都無法取用（TDZ) let name = 'Luke' 所以這邊只要知道， 使用 let 、 const 宣告變數雖然還是有提升的作用，但是還是不能像 var 那樣自由的使用，等於有跟沒有一樣。 而我認為這樣子的限制也能減少開發者寫出讓人誤會的程式碼的機會，算是一個好處。","link":"/2020/01/02/iron30-6/"},{"title":"JS 原力覺醒 Day07 - 陳述式 表達式","text":"這很基本，不過為了了解後面的說明，還是要提一下，JavaScript 有兩種語法分類：陳述式與表達式。而了解這兩種語法分類之後，後半段會提到，JavaScript 基於這些觀念，在函式宣告上具有獨特不同的運作方式。 Outline 陳述式（ Statement ） 表達式 （ Expression ） Expression Statements 函式陳述式 （Function Statement） 函式表達式 （Function Expression） 陳述式（ Statement ） 陳述式一定會做一些事情，但陳述式不會產生數值。所以不能被放在 JS 內預期會產生數值的地方，例如函式的參數、函式的回傳值、或是宣告變數時等號的右邊（不能分配給另一變數）。 陳述式會產生動作 下面這些都是 JavaScritp 裡的陳述式： 變數宣告 if 判斷式 while 迴圈 for 迴圈 switch 判斷是 for-in 迴圈 直接的函式宣告 var a = 3 ; if(a === 3){ //doSomeThing… } { //doSomeThing , this is a Block Statement } for (var i = 0 ; i&lt;=10 ; i++ ){ //doSomeThing } try{ … }catch (){ … } 上面這些例子都是陳述式，會執行某些動作，而且通常是在執行環境產生時就會被執行。值得注意的是區塊陳述 （ Block Statement ），就像 if 的區塊一樣，在裡面會執行一些動作，但執行完成後也不會回傳任何數值，區塊陳述也是一樣的概念，只是一定會執行，不會經過判斷。 另外，變數的宣告為什麼是陳述式？他會做什麼動作嗎？會的，JS 引擎在這個時候會幫你留一個記憶體空間，並把這個變數名稱跟記憶體空間做連結，函式宣告也是一樣的道理，等等就可以看到。 表達式 ( Expression ) 表達式是一段可以很長，但會產生結果值的程式碼，而且很常是運算式。 An expression is a phrase of JavaScript that a JavaScript interpreter can evaluate to produce a value. - JavaScript: The Definitive Guide 表達式是一段 JS 直譯器能夠運算並產生數值的程式碼。 1 + 2 functionInvocation() ture || false d true &amp;&amp; true a = 3 //會回傳 3 a === 3 Array.isArray([]) ? doSomeThing() : doOtherThing() 上面這些用法都是表達式，我們應該都用習慣了，但是如果沒有特別注意就不會特地去分類。好，現在我們知道陳述式會執行動作、表達式會回傳某值，接下來我們要看看比較特別的部分。JS的函式宣告，根據不同的方式可以是宣告式也可以是表達式函式，這兩種方法則分別稱為「函式陳述式」跟「函式表達式」。 函式陳述式( Function Statement ) 函式陳述式是藉由直接給定名字來直接宣告一個函式。剛剛有說到變數宣告會使 JS 引擎來幫你保留記憶體空間，所以是陳述式。像這樣子直接的函式宣告，跟變數宣告會產生的行為是一樣的，差別是整個函式內容在語法解析階段都會保留進記憶體空間，這個行為就是之前提到的提升 （ Hoisting ），所以屬於函式的陳述式。 function functionStatement (){ //doSomething } 函式表達式 ( Function Expression ) 另外一種宣告函式的方式是函式表達式，是把一個匿名函式指派給一個變數，這種宣告方式的函式內容不會在一開始就被提升，會被提升的只有該變數而已。在執行階段，才會把函式內容指派給變數，以下面程式碼為例，這個時候 functionExporession 才是一個可以用的函式，而變數的指派屬於表達式，因此這種方式也被稱為函式表達式。 var functionExpression = function(){ //doSomeThing }","link":"/2020/01/02/iron30-7/"},{"title":"JS 原力覺醒 Day08 - Closures","text":"Outline Closure 的形成 經典範例 Closure 的形成 函數內的變數在函式執行完之後，就無法再被參照到，這個時候一開始被分派的記憶體就會被釋放什麼意思呢？ function getEnemyInfo(){ let enemies = ['Darth Vader','Sheev Palpatine']; let enemyLeader = 'Sheev Palpatine' return enemies } function getBattleInfo(){ let fellowInfo = ['Clone' , 'Clone' , 'Warship', 'Clone']; let enenyInfo = getEnemyInfo() // enemyLeader is not defined // because it's located in another function. console.log(enemyLeader) return `the number of fellows is: ${fellowInfo.length }, and the number of enemies is&quot; ${enenyInfo.length}` } getBattleInfo() 先來了解一下基本觀念，如上述例子，getEnemyInfo 函式裡面宣告的變數，在函式執行環境結束後（執行完），就再也無法取得，（ 也可以說該變數的有效範圍只存在於該函式內 ），因為這時執行堆疊已經剩下全域。除非我把該變數宣告在全域，否則在外面是無法拿到的。 下面來看一個經典的 Closure 例子： let country = 'United Nations' let soilder = ['Clone' , 'Clone' , 'Warship', 'Clone']; let jedi = ['Yoda' , 'Obi-Wan', 'Anakin'] function addA(numA){ return function (numB){ return numA+numB } } let addB = addA(jedi.length) let fellowNum = addB(soilder.length) 上面是一個要把兩個數字加起來的 add 函式。 這個函式會返回另外一個函式，之後才會真正把兩個數字加起來，在我們輸入第一個參數之後，就會結束該函式執行環境並返回另外一個函式。 照理說當 addA 函式回傳第二個函式之後，addA 的執行環境就結束，就沒辦法拿到該函式參數 numA ，但對 addB 函式而言，在其內部有引用到他內部沒有的變數 （numA），因此他會轉為向外部環境（ Scpoe Chain ）尋找 ，JS 引擎就會為此保留這個函式的記憶體空間，不會釋放。 這看起來就 numA 在 addB 執行環境存在時，暫時為了 addB 而被保留，完全只屬於 addB ，所以這個暫時存在的封閉環境，就被稱為「閉包 ( Closure )」。 經典範例 接下來我們要來看一個很常見，且非常容易讓人誤解的例子： function pushFuncToArray(){ var funcArr = [] for (var i=0; i&lt;3; i++){ funcArr.push(function(){ console.log(i) }) } return functionArr } var functionArr = pushFuncToArray() functionArr[0]() functionArr[1]() functionArr[2]() 如果你沒有接觸過 Closure ，乍看之下一定會覺得依序的執行結果會是 0,1,2 ，可是~~瑞凡，~~並不是，結果是 3,3,3 ! 這是為什麼？很簡單，我們在把函式推到陣列裡面的時候 ，因為處於 pushFuncToArray 內部且有引用到該函式內的變數 i ，而形成閉包。 JS 引擎的確會暫時為你保留 i 的記憶體空間，不過因為在把函式推送到陣列裡面的時候，並沒有立即引用到 i ，所以等到 pushFuncToArray 結束，一個一個執行 functionArr 裡面的函式時， i 早就已經被 for 迴圈修改為 3 （因為迴圈已經結束，i 維持在跳出迴圈之前的值 ） ，這時候怎麼拿，當然 i 都會是 3 啦！ 之後還會講到相同的概念，如果你有點不懂，後面還會再講到，但請盡量確保一定要弄清楚再往下囉！ 那麼我們明天見。","link":"/2020/01/02/iron30-8/"},{"title":"JS 原力覺醒 Day9 - 原始型別與物件型別","text":"今天要講到 JS 型別概念，雖然你平常寫 JS 的時候可以看到很多種類別，但其實大致上可以分為兩個比較主要的大分類。 Outline 物件型別 ( Object Type ) 原始型別（Primitive Type） 物件型別 ( Object Type ) 第一種叫做「物件型別」，「物件」指的是物件。恩，但其實有很多東西本身也算是物件，例如陣列和函式，不相信嗎？讓我們繼續看下去，你可以再 JS 裡面宣告一個陣列，然後用 typeof 去得到這個陣列的型別，結果一定會讓你感到意外： let arr = [] console.log(typeof arr) //object 那麽這樣我要怎麼判斷出陣列了呢？ JS 提供了 Array.isArray() 的方法，來讓我們知道某物件是不是陣列。好，那麼函式也是物件型別嗎？當我一樣用 typeof 去觀察的時候，居然得到了不同的結果！ let hello = function(){ console.log('hello') } console.log(typeof hello) // function 「 看吧！聽你在亂講 」，你一定想這麼說，別急，換另一個方法來觀察看看， instanceof 是一個可以觀察某對象是不是另外一個對象的後代，那我們來看看 function 是不是物件的後代： console.log( hello instanceof Object ) // true 答案是沒錯。不過為什麼會這樣呢？函式在 JS 裡面算是一個比較特別的物件，稱為「 函式物件 ( Function Object ) 」，所以剛才我們用 typeof 乍看之下才會得到 function 的結果。 而正是因為「函式同時也是物件」這樣的特性，前面我們提到的「函式表達式 ( Function Expression ) 」才能成功！ let someVariable = function() {...} 而函式物件特別的地方在於，只要搭配 new 關鍵字，他也能夠用來產生新的物件，這與其他物件導向語言產生物件的方法非常類似： const Foo = function () {}; const bar = new Foo(); bar; // {} bar instanceof Foo; // true bar instanceof Object; // true 原始型別 ( Primitive Type ) 原始型別又稱為純值 ( Primitive Type ) ，用來表示只代表單一值的一種資料型別，如 12 只代表12，沒有其他意思了，原始型別上也不像 物件型別上，有一些預設方法讓我們能夠直接取用，（ Array.isArray ）這樣子的東西，不像物件那麼複雜，所以稱為純值。此外，因為 JS 內只有兩種分類，所以「除了原始型別的型別，都是物件型別」，因此只要弄清楚哪些是原始型別，就可以很輕易找出物件型別。 JS 裡面有六種純值： null undefined number ( 0 ) string ( “string”) boolean ( true ) symbol (目前少用) 其中比較特別的純值是 ES6 之後才出現的 Symbol ，Symbol 類別是透過 Symbol () 方法產生，由於每個 Symbol 值所對到的記憶體位置不一樣，因此很適合用來避免物件屬性意外的被修改。 const a = {}; const symbol1 = Symbol('123'); const symbol2 = Symbol('123'); // they have different memory address in JS console.log(typeof symbol1);// expected output: &quot;symbol&quot; a.symbol1 = 'Hello!'; a[symbol1] // undefined a['symbol1'] // &quot;Hello!&quot; 上面可以看出使用字串來存取物件屬性跟以 Symbol 來存取會得到不同的結果，因為以往物件的屬性除了用 「.」運算子來存取，但這樣很容易因為重複赴值而被意外的修改，因此 Symbol 就可以用來避免這個問題發生。 &quot; A symbol value may be used as an identifier for object properties; this is the data type’s only purpose. &quot; - MDN Docs 結論 Function 只是一種特殊型態的物件 （函式物件） Function 可以用來創造新的物件 （搭配 new 關鍵字） 不是所有的型別都是物件，但是除了純值以外的型別都是物件。 JS 裡面有六種純值 Symbol 可以用來防止物件屬性被意外的修改","link":"/2020/01/02/iron30-9/"},{"title":"初探Regex 正規表達式","text":"正規表達式英文全名Regular Expression， 想必一定曾是每個工程師的惡夢，在新手眼裡彷彿精靈語一樣神秘又難親近， Regex是一把複雜卻威力強大的武器。如果可以活用，在很多場合可以幫助你少寫很多的if判斷式，今天這篇文章就要來幫助理解正規表達式。 為什麼需要 Regular Expression? Regex可以實用的情境大致有幾種： 尋找匹配的字串 取代匹配的字串 驗證使用者輸入資料欄位 擷取某段想要的資訊 舉例Js為例子來說，如果我想要看看資料裡面有沒有某個字元&quot;M&quot;，一個簡單的方式是這樣寫： let stringMatch = &quot;This is Mujing.&quot;.some(s=&gt;{ return s==&quot;M&quot; }) // Check if there is M in my data. 不過如果今天，當條件變得更多更複雜的時候這時候正規表達式就派上用場了。 (字串裡面必須包含一個數字或一個大寫字母)： let re = &quot;&quot; let result = &quot;uSer0910&quot;.match(/([0-9]|[A-Z])/g) //result.length = 1 Regular Expression 規則說明 正規表達式使用時是將規則寫在兩個正的斜線裡面，並且撰寫的時候有幾種類型的匹配方式： 直接匹配： 例如直接輸入字元&quot;abc&quot;.match(/a/) 就可以匹配到a字元。 使用跳脫字元匹配：有些英文字在Regex裡面代表的特殊意義，但因為是用英文字元代表的，所以在使用時要用“\\”跳脫字元來告知這不是一個直接匹配的字元。 特殊字元匹配：跟第二種相反，有一些特殊符號一但出現，就代表某種意義，如“[]“就代表任意匹配，如果要單純匹配 “[” 字元，則必須用反斜線告知。 JS 的Regular Expression寫法 JS裡面寫正規表達式的時候你可以直接用兩個斜線代表，或是new一個RegExp物件並將要寫的規則寫入建構子，不要用這種做法要注意，RegExp預設會直接幫你跳脫特殊字元，如果你要在裡面寫跳脫字元規則的話，記得寫兩個反斜線來告訴他不要跳脫： 例如： new RegExp('\\d') // return /d/ (變成匹配d這個字元了) new RegExp('\\\\d') // return /\\d/ (是我要的數字匹配規則) RegExp物件底下有一個test方法，用法如下： /a/.test('An Apple a day.') // return true 就可以很快的測試自己寫的方法對不對了，這個方法用在表單檢查也非常好用。 正規表達式還可以用在很多地方，如match、split、replace等操作字串的方法， 學會之後想怎麼用就怎麼用。 以下整理正規表達式常用的特殊規則，或可參考JS官方文件 跳脫字元規則 這邊有個好記的規則，小寫的 符號 說明 \\d 匹配任意數字 \\D 匹配任意非數字字元 \\w 匹配所有文字字元 (a-z、A-Z、0-9、_ ) \\W 匹配所有“非”文字字元 (標點符號、特殊字元) \\s 匹配空白字元 \\S 匹配“非”空白字元 \\b 匹配字元邊界 /（空格或開頭/) \\B 匹配字元邊界 特殊符號 符號 匹配說明 \\ 反斜線，跳脫特殊字元，例如想尋找&quot;/&quot;的時候 . 任意字元 $ 字元結尾 ^ 字元開頭 [] 中括號，比對中括號裡面的任一字元，可以用範圍匹配：[A-Z]、[a-z]、[0-9] [^] ^代表「反」，比對中括號裡面&quot;以外&quot;的任一字元 | 同程式常見的OR邏輯 () 群組 指定匹配次數 因為一個字元只會匹配一次，如果要多次匹配，就可以用指定字數的規則。 需注意：這些次數針對的是的是該該符號擺放位置的前一個匹配規則。 符號 匹配次數 * 0次或更多 + 1次或更多 ? 0次或1次 {m} m次 {n,} 最少n次 {m,n} 從m次到n次 {m,n}? 從m次到n次，選到匹配最少次的 基礎範例： 其實懂了基本邏輯之後，剩下的就是組合而已，匹配的規則要用在查就可以了，因為比較常用的寫法都差不多。 1.驗證手機號碼: 手機號碼有10個數字，要怎麼寫呢？你可能第一個會想到[0-9]，方向對了， 但[0-9]只會匹配一次，如果要匹配10次可以這麼寫: /[0-9]{10}/ 2.商品型號: 一般電商在後台上架商品的時候，一個常見的需求是輸入商品型號，為了減少使用者錯誤率也為了提高效率，我們可以用正規表達式解決，假設今天商品型號的規則是： 三個英文字母 + “-” + 五個數字 （例如ABC-90006 ) 那麼其實搭配上面講的匹配次數就可以： /[A-Z]{3}-[0-9]{5}/ 3.驗證密碼（至少包含一個大寫字母以及一個數字): 這個情況想必跟[A-Z]以及[0-9]脫不了關係，但會遇到順序性的問題，直接給[A-Z][0-9]代表的是先一個大寫字母在加上一個數字，不能夠反過來，這時就會需要最少匹配一次的&quot;＋&quot;跟最寬容的&quot;＊&quot;。 拆解各種情況： [A-Z][0-9] :匹配一個A-Z的字母跟一個0-9的數字，而且不能顛倒 [A-Z]+ :代表匹配大寫字母最少一次 [A-Z]* :代表匹配A-Z0次或更多（這樣就代表可有可無，不是我們想要的） [A-Z]+[0-9]+ :匹配[A-Z]最少一次之後在匹配0-9最少一次(如：AABB909) 看完上面四個範例你應該就會理解剛剛講的順序性是什麼，根據這個條件，可能會有的情況有幾種： 1. [任意字串] + [至少一個A-Z字元]+[至少一個數字]+[任意字串] 2. [A-Z字元在開頭]+[任意字串]+[至少一個數字] 簡單來說就是要考慮我要匹配的字元是在開頭以及結尾，我們可以用 “.*”來達成 [ 任意字符 ]的[ 匹配任意次（包含0次）]，以及 &quot;+&quot; 達成最少一次的匹配： .*[A-Z]+ ：表示至少有一個A-Z字元，前面可以有其他「任意次」個「任意字元」。 組合！！ .*[A-Z]+.*[0-9]+.* 這樣就可以達到不管前面有什麼，最後有什麼，只要有一個A-Z跟一個數字，就符合規則啦！ 但最後還要考慮順序的問題，可以用 OR 邏輯將數字跟字母對調，就完美符合我們的需求啦！ .*[A-Z]+.*[0-9]+.* | .*[0-9]+.*[A-Z]+.* 幾個練習Regex的網站： 比較推薦第一個，他是互動式的，一步一步帶你了解正規表達式的使用方式，說明的很詳細。 剩下兩個則是自己在測試的時候很好用，寫完表達式右邊還有規則的說明，非常方便。 RegexOne Regex101 Regexr","link":"/2019/02/12/regex-js/"},{"title":"Summernote 所見即所得編輯器達成圖片上傳","text":"當使用者在後台管理商品資料的時候，必須用到編輯器讓使用者輸入資料，當然也少不了常常跟編輯期搭配使用的圖片上傳，這邊選用Shrine跟Summernote來當作例子，講解前端如何發起上傳圖片的request將圖片上傳到後端。 解釋一下：Shrine 是Rails 裡面一套圖片上傳的套件，而Summernote 是一套歷久彌新而且非常好用的所見即所得編輯器，你應該會常常在各大開源專案看到他的影子。 今天重點會著重在前端圖片上傳到後端，並回傳圖片位址的流程，在後端功能的實作上不會有有太詳細的解說。 Summernote 文件：https://summernote.org/ Shrine 文件：https://github.com/shrinerb/shrine OUTLINE HTML編輯器功能說明 圖片上傳流程解析 實際程式碼 HTML編輯器功能說明： HTML編輯器的介面其實長得很像Word，有各種按鈕讓你設定跟編輯文字的外觀。只不過你在Web使用編輯器的時候，實際上是在編輯他的Css Style，去改變文字大小、顏色等外觀。 Summernote 使用上非常容易，搭配jquery的selector就可以很快成功有一個編輯器介面可以用： &lt;div id=&quot;summernote&quot;&gt;&lt;/div&gt; $('#summernote').summernote(); 圖片上傳流程解析： 要能夠在編輯器裡面上傳並插入圖片，大致上有兩個關鍵步驟： 使用者選擇要上傳的圖片 上傳完畢，拿回圖片網址，並將圖片插入目前游標位置 我們可以看到在上述編輯器裡面有個圖片上傳按鈕，以Web以及Javascript的角度來思考的話，點擊該按鈕應該會有一個callback，就算沒有我們也可以自己實作一個，不過既然Summernote預設就有這個按鈕，我猜想應該會有一個點擊上傳圖片後的hook，可以自己寫callback來決定使用者選擇圖片後，要做什麼動作。 果不其然在官方文件被我找到這個 onImageUpload 的hook： 在callback參數裡面可以拿到使用者選擇的檔案，只要在這個callback裡面利用ajax進行圖檔上傳的動作，就可以順利上傳了，甚至在文件裡還有提供插入圖片到游標位置的方法： // upload image to server and create imgNode... $summernote.summernote('insertNode', imgNode); 既然有了方法，就可以整理一下圖片上傳的流程： 實際程式碼： jquery ajax圖片上傳： function imageUpload(files){ let formData = new FormData(); formData.append('upload', files[0]); return $.ajax({ type: &quot;POST&quot;, url: '/upload', data:formData, beforeSend: function(xhr) { xhr.setRequestHeader('X-CSRF-Token', $('meta[name=&quot;csrf-token&quot;]') .attr('content'))}, cache : false, contentType : false, processData : false, }); } 我把ajax內容拆了出來，把資料用參數的方式傳遞，以免每次上傳都要重寫一次： callback 內容 $('#summernote').summernote( { height: 300, callbacks: { onImageUpload: function(files) { imageUpload(files).done((data, textStatus, jqXHR)=&gt;{ let url = &quot;/uploads/&quot;+data.imageUrl $('#summernote').summernote('insertImage', url, 'newimage'); }) }, } }); st=>start: Summernote選擇圖片 cb=>start: 圖片透過ajax上傳 saveImg=>start: 圖片儲存至Server(或cdn) saveInfo=>start: 儲存圖片相關資料至資料庫 getInfo=>start: 拿回圖片位址並回傳（從資料庫或cdn callback） insertImg=>end: 將拿回圖片位址放入並插入編輯器游標位置 st->cb->saveImg->saveInfo->getInfo->insertImg{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","link":"/2019/02/12/summernote-shrine/"},{"title":"TypeScript(1) - 基本型別介紹","text":"變數宣告方式 指定型別 指定型別的宣告其實跟一般宣告方式差不多，只是在變數後面多了一個「:&lt;要宣告的型別&gt;」的指定，指定之後赴值一樣只能是同行別的值： let name: string = 'moojing'; 不指定型別 Typescript裡宣告變數，可以不指定型別，那就會是類似Js的方法，： let name = 'moojing'; 型別不指定的話，TS會自動偵測赴與的值是什麼類型，但是如果再次赴與不同型別的值，編譯就會報錯： name = 2 ; //Error: Type '2' is not assignable to type 'string'. TypeScript的幾種型別 TypeScript 裡面的型別基本上跟JS原生的型別相同，只是因為型別系統的加入又多出了幾種型別，： Any String Number Boolean Array Object Tuples Enums Void Never Any Any型別顧名思義就是任何型別都可以放入這個變數，如果使用這個型別，基本上就跟原本Js可以隨意assign的使用方式ㄧ樣了。實務上不太建議使用Any，因為這樣就跟使用JS沒有兩樣了： let anyType:any = 1234; anyType='1234' //It's Okay. String / Number / Boolean 這三種基本型別的宣告都很直觀，直接宣告即可： let myName:string = &quot;Moojing&quot; let myName:number = 123 let myName:boolean = true Array Array的型別有兩種宣告方式： let array:Array&lt;number&gt; = [2,3,4] let array1:number[]=[4,5,6] 也可以宣告型別為any的Array: let array1:any[]=[4,5,6] Tuples 元組 Tuples在數學上的意思是有限的序列組合，其實就是包含很多不同型別元素的陣列： let address: [string,number] = [&quot;Superstreet&quot;,31] 不過使用Tuples就要注意，元素類型的順序也要跟宣告的相同，以上面的例子來說，第一個元素就不能是數字，第二個元素也不能是字串。 Enum 列舉 Enum就是把所有可能的狀態列出來： enum Color{ Red, Green, Black } Enum的宣告方式很像一般物件，但是元素的值預設是向陣列的index，0,1,2… enum Color{ Red, Green, Black } let myColor:Color = Color.Green; console.log('myColor: ', myColor); //1 不過你也可以自己決定每個狀態對應的值： enum Color{ Red =100, Green=200, Black=300 } let myColor:Color = Color.Green; console.log('myColor: ', myColor); //200","link":"/2019/02/23/typescript-1/"},{"title":"TypeScript(2) - 函式宣告、函式型別與物件","text":"基本宣告方式 函式本身的型別宣告可能在幾個地方發生，分別是參數跟回傳值： function multiply(value1: number, value2: number): number{ return value1*value2 } console.log(multiply(2,3)); //6 當然也可以像JS原本的宣告方式一樣，如此一來預設的類型會是Any，不過這樣使用TS就失去意義： let myName:string = 'Moojing' function returnMuyName (){ return myName; } 函式型別 JS 裡面，我們可以把 function assign 給變數，但是 TypeScript 裡面想要啟用型別檢查，就一樣必須在變數後面聲明這個函式的型別，（包含參數和回傳值），但如果一個變數沒有任何型別的話，這個 function 的型別跟一般變數一樣會被設為 any ，所以可以傳入型別。 function sayHello():void{ console.log('Hello') } function multiply(value1:number,value2:number): number{ return value1*value2 } let doSomeThing = sayHello; let doSomeThing = multiply; 但是這樣一來我們就無法直觀的判斷這個變數的型別，畢竟使用TS就是要將他的優點發揮到極致，還記得之前我們提過變數型別的宣告嗎？我們可以這麼做： let doSomeThing: (val1: number, val2: number)=&gt;number; doSomeThing = multiply; doSomeThing = sayHello;// Type '() =&gt; void' is not assignable to type '(val1: number, val2: number) =&gt; number'. 這樣一來在assign錯誤的函式型別時，TS就能夠檢查出錯誤，不過這樣一來函式的宣告就變得有點的雜亂不易閱讀，這時我們可以使用 type 關鍵字把函式型別抽出來另外宣告： type someType = (val1: number, val2: number)=&gt;number; 物件型別 將物件assign給某變數，該變數的型別宣告方式，其實跟前面function型別的宣告方法差不多： let userData : {name: string, age: number}= { name: &quot;Max&quot;, age:27 } 宣告完物件型別之後，就不能再assign該物件型別裡沒有定義的property跟類型: userData = { a:'hello', //類型 '{ a: string; b: number; }' 不可指派給類型 '{ name: string; age: number; }'。 b:22 }","link":"/2019/02/23/typescript-2/"},{"title":"TypeScript(3)  Union Types與Custom Type","text":"TypeScript(3) Union Types與Custom Type Union Types 當某個變數需要可以同時容納兩種以上的型別時，我們可以在宣告型別的時候使用常見用於or邏輯的「|」來宣告型別： let myAge : number | string = 27; 上面的例子代表這個變數可以同時容納兩種以上的型別。 Custom Type 結合前幾章節講到的所有知識，當你的物件結構很複雜，又想要針對每個property宣告型別時，就可以使用「type」關鍵字來宣告自訂的型別： type ComplexType = { data: number[] , output:(all:boolean) =&gt; number[] }; let complexData: ComplexType = { data:[100,3.99,10], output:function (all: boolean): number[]{ return this.data } }","link":"/2019/02/23/typescript-3/"},{"title":"TypeScript(4) 進階型別 never、void、null與undefined","text":"除了基本型別外，還有一些型別是比較不常見的，必須要先了解函式型別跟Union Type，所以放在這邊講，以下將個別介紹： Void Never Null Undefined Void void用於function的回傳值定義，代表這個function不會回傳任何值： function returnNothing() : void{ console.log('returnNothing') } Never never這個型別跟void很像，但定義上更嚴謹，有些function根本不會結束，例如拋出例外，或是無窮迴圈，never就是用來代表這些函式行為的類型: function errorMsg(message:string): never{ throw new Error(message); } Null 與 Undefined 就算再JS裡面，null跟undefined依然是很特殊的型別。TS裡面，可以選擇要不要嚴格檢查，在tsconfig.json裡面可以設定strictNullChecks(預設為true)。 如為true，代表嚴格null檢查，變數只要設定為其他型別就不能為null(undefined)反過來講如為false，則代表所有型別變數都可以設為null(undefined)，無需另外撰寫規則。 tsconfig.json : &quot;compilerOptions&quot;: { ... &quot;strictNullChecks&quot;:false ... } let canBeNull:number = 12; canBeNull = null;//it's ok with strictNullChecks:false 在嚴格null檢查的模式下，如要達成上面的行為，我們就必須用到Union Types: let canBeNull:number |null = 12; canBeNull = null //it's still ok even with strictNullChecks:true","link":"/2019/02/23/typescript-4/"},{"title":"TypeScript(5) 物件屬性的修飾子","text":"Typescript 跟一般 OOP 的語言寫法相似，所以講到物件一定少不了一些物件的基本觀念，修飾子是用來規定物件屬性（或稱成員） 存取權限的關鍵字，大致有以下三種： public 公有屬性，可以被自由存取的屬性 private 私有屬性，只限於該屬性所屬的類別內可以存取 protected 受保護屬性，除了該屬性所屬類別，該類別之子類別（繼承該類別的類別）內也能存取。 修飾子使用方式 Typescript 裡面，沒有加上修飾子的屬性，預設都會被認為是public，如果想要加上其他修飾子的話，只要在變數宣告前面加上修飾子就可以了： class Person { private name: string; constructor(name: string) { this.name = name; } } Getter / Setter 我們可以透過 getter 以及 setter 來當作統一出入口，來對無法直接存取的私有變數進行操作， getter 及 setter 跟 JS ES6 的使用方式相同。 class Person { protected name: string; constructor(name: string) { this.name = name; } } class Employee extends Person { constructor(name:string){ super(name) //把 name 傳給父類別的建構子 } get nameGetter():string{ return this.name } set nameSetter(value){ this.name = value } } let Jack = new Employee('Jack') console.log(Jack)","link":"/2019/04/16/typescript-5/"},{"title":"TypeScript(6) 物件繼承","text":"TypeScript(6) 物件繼承 了解物件可以有私有/保護屬性之後，接下來我們要來看物件的繼承，繼承可以讓一個全新的類別被實體化（new 出來）的時候，就能夠直接取用某個類別的方法。通常我們稱被繼承的類別為「父類別」，繼承別人的物件稱為「子類別」。 題外話，早期 Javascript 必須透過 property 來達到繼承，但 ES6 之後也有類別(class)繼承的做法。 假設我今天想要寫一隻程式來記錄動物的行為，於是我創造了一個 Animal 類別，裡面有一個 move 方法，可以描述某個動物移動了幾步。 class Animal { name:string; constructor(theName: string) { this.name = theName; } move(meters: number) { console.log((this.name + &quot; moved &quot; + meters + &quot;m.&quot;)) } } 但動物有很多種，我想細分動物的種類，也一樣共用描述行為的這些方法，該怎麼做到？這時候就需要用到繼承，Typescript 裡面使用 extends 語法來進行繼承。 class Snake extends Animal { constructor(name: string) { super(name); } move() { super.move(5); } } 並且使用 super 來取得父類別的屬性以及方法（也就是 Animal )，且記得如果在子類別有使用建構子，一開始要先使用spuer()呼叫父類別建構子，否則會報錯。 在Snake裡面如果寫入跟父類別 Animal 相同的方法，我們就稱這個動作為「複寫」（覆蓋掉父類別方法），但是以上述程式碼為例，就算不複寫，snake 一樣可以直接調用 move 方法（因為繼承。","link":"/2019/04/16/typescript-6/"},{"title":"react-compound-component","text":"一般來說在進行正式的專案開發，製作可以重複被使用的元件時，常常也必須考慮到元件的彈性、與可維護性。因為我們不知道在未來，這個元件會因為產品的需求而產生怎麼樣的調整，所以最低程度地保持元件的可擴充性就可以讓開發者在這個時候比較輕鬆的以最小限度的影響來達成想要的修改。 複合元件就是一種可以同時提高可維護性跟彈性的元件設計方法，或稱為設計模式（ Design Patern ) 。設計模式一詞源自更早期的軟體界發展歷史，這個詞可以用來代稱那些應付經常出現問題的解決辦法。亦即設計模式是經年累月透過所有軟體界的開發者不斷地遇到相同或類似問題之後，慢慢整理出來的方法。有一些設計模式是所有語言都可以通用的，例如你可能會聽過的「 工廠模式 」、「 觀察者模式」。而有一些模式是針對特定情境的問題所設計的，我們今天要談的複合元件就是前端元件開發的設計模式之一。 需要的先備知識 這篇文章主要會講解如何設計一個複合元件，再繼續往下閱讀之前，你可能要確保自己了解 React children 與 context 的相關概念，才能夠比較輕鬆的閱讀這篇文章所提及的內容，在這邊附上幾篇可以參考的資源： React Children - 操作元素的 React 原生 API ： A Complete Guide To props.children In React | codeburst 官方文件：React Top-Level API React 裡面 Context 的概念： 官方文件： Context – React 複合元件是什麼 複合元件，或稱合成元件( Compound Component ）可以從詞面上看出它大致的意思，就是指數個聚集在一起，並有某些相互關係的元件。透過複合元件，可以讓兩個或兩個以上相關聯的元件用一些不明顯的方式來共用狀態，這是什麼意思，而複合元件到底又解決了什麼樣的問題呢？ 元件常見的多層結構問題 舉我們常見的下拉選單為例，如果我們現在想要製作自己的選單元件，最直觀的製作方法會是直接創造一個元件，然後把所有相關的資料傳入： import { useState } from &quot;react&quot;; function Option ({name, value, onClick}) { return &lt;option className=&quot;option&quot; value={value} onClick={onClick} &gt; {name} &lt;/option&gt; } export default function Select({ options }) { const [selectedValue, setSelectedValue] = useState(options[0]); const onClickOption = (option) =&gt; () =&gt; setSelectedValue(option); return ( &lt;div className=&quot;root&quot;&gt; &lt;div className=&quot;selectedValue&quot;&gt; {selectedValue.name} &lt;/div&gt; {options.map((option) =&gt; ( &lt;Option name={option.name} value={option.value} onClick={onClickOption(option)}/&gt; ))} &lt;/div&gt; ); } 上面的程式碼範例只是一個示意，所以並沒有考慮到 CSS 的樣式，這邊會以狀態的傳遞方式為重點。所以以這個下拉選單的例子來說，我們會把整個選單的名字跟對應的數值，直接傳入這個 &lt;Select/&gt; 元件裡面。 const optionList = [ { name: &quot;optionA&quot;, value: &quot;valueA&quot; }, { name: &quot;optionB&quot;, value: &quot;valueB&quot; } ]; ... &lt;Select options={optionList} /&gt; 但是這麼一來除了沒辦法直接存取到 &lt;Option/&gt; 元件之外，你也可以發現這份相關的選單資料其實是從最上層傳入 &lt;Select/&gt; 元件之後，再次被傳入 &lt;Option/&gt;，&lt;Option&gt; 這個元件才有辦法拿到需要用來顯示的選項內容與對應數值。 一般我們不會樂見這種資料被層層傳遞的使用方式，你可能覺得兩層可能還好，不會太難看出它們的關係，但在實際開發時總是無法永遠確保不會有需要第三層的情況出現，因此雖然難免還是有些不得已必須這麼使用的情況，大多時候對開發者來說這種情況當然是越少越好。你可以想像使用這個用法製作的元件，在當所必須傳入的屬性隨著時間和需求的改變而變得太多時，它會變得越來越難看清楚每個屬性所對應的內容，和與之相關的流程邏輯。 對上面的 &lt;Select/&gt; 元件來說，也許一個比較好的設計方式最好還是能夠跟原生的 select 與 option 標籤具有同樣的使用方式： &lt;select&gt; &lt;option value=&quot;value1&quot;&gt;optionA&lt;/option&gt; &lt;option value=&quot;value2&quot;&gt;optionB&lt;/option&gt; &lt;/select&gt; 當我們把 &lt;Select/&gt; 元件用某種方式拆分成兩個個別獨立，且相關連的元件之後，就能夠享有一個好處是能夠把元件的樣式內容分開來管理，也就是說我們在設計元件時不需要把所有的程式碼塞在一起。而除了讓內容分離之外，使用複合元件的另外一個很大的好處是能夠讓狀態在這兩個相關連的元件之間共享，這麼一來也可以減少把狀態「傳到上層在傳到下層」的情況發生。 複合元件的好處 \b綜上所述，由於複合元件原本就是為了讓元件之間的相依，並提高使用彈性的方法。所以他所帶來的好處也不難理解： 讓開發者能夠更容易且隨心所欲控制元件，例如：元件的排列順序。 讓相關元件扁平化，可以使用在同一層而不用全部包在一個地方。 元件內容分離，讓元件更容易管理，就像我們即將要做的：把上面原本的 &lt;Select/&gt; ，拆出 &lt;Option/&gt; ，分離成兩個元件。 以 &lt;Select/&gt; 為例子來設計複合元件 下拉選單是前端一個很常見的需求，尤其我們因為樣式的關係，無法使用原生的 Html 元素，所以常常需要客製化的製作。這邊我們就來看看怎麼利用 React 來設計一個跟前端原生的 &lt;select&gt; 元素使用方式較為相近的元件吧！在這個例子裡面，我會以 Class Component 為基礎來進行設計。 元件的條件要求： &lt;Select&gt; 與 &lt;Option&gt; 兩個元件必須要能夠分開使用而不是全部放在同一個元件中，像是這樣： &lt;Select&gt; &lt;Option value=&quot;value 1&quot; &gt; option 1 &lt;/Option&gt; &lt;Option value=&quot;value 2&quot; &gt; option 2 &lt;/Option&gt; &lt;Option value=&quot;value 3&quot; &gt; option 3 &lt;/Option&gt; &lt;/Select&gt; &lt;\bSelect/&gt; 必須能夠根據其子元素的所有 &lt;Option/&gt; 元件內容以及排列順序來顯示下拉清單 元件的製作結果如下： 先思考元件結構 通常複合元件中，會有一個作為父層元件的主元件，而由其他的元件作為子元件。不過在 &lt;Select/&gt; 與 &lt;Option/&gt; 的例子中則比較單純，只有父層的 &lt;Select/&gt; 與子層的 &lt;Option/&gt;。以這個架構為前提之下，我們可以繼續往下想想另外幾個問題，那就是： 作為父層元件的 &lt;Select/&gt; 是怎麼知道在它下層的 &lt;Option/&gt; 的內容的？ &lt;Select/&gt; 又是怎麼比對出幕前使用者所選到的選項的？ 只要能夠解答這兩個問題，我們基本上就掌握了實作這個 &lt;Select/&gt; 複合元件的關鍵。 首先，第一個問題的思考方向是一個很常見的 children 屬性，我們只要透過這個屬性就能夠取得「被放入」元件的內容，也就是所有的 Option 元件。而關於 Select 是怎麼知道目前所選的數值的？可想而知的是在 Select內一定會有一個狀態負責儲存目前被選中的值。 另外我們再每個 Option 被選中時也必須進行更新這個被選中數值的動作，所以我們也需要在 Option 元件上面掛上對應的 onClick 事件，這麼一來當Option被點擊時，Select 才有辦法知道 Option 選中的數值是哪一個。關於這一點我們可以透過 React 的相關 API ： Children.map 以及 cloneElement 來達成。Children.map 負責巡訪每個子元件 Option， cloneElement 則複製一個新的 Option 並讓我們可以在這個時候再次傳入額外的屬性。 // ... 在 Select 元件內 // 選項表單 &lt;div className=&quot;optionList&quot;&gt; {Children.map(children, (child) =&gt; React.cloneElement(child, { ...child.props, onClick: this.onOptionClick(child), }) )} &lt;/div&gt; 藉由上述的程式碼片段可以看出我把個別的子元件內容傳給了 onClick 事件，接下來在事件裡面只要知道要儲存什麼數值藉以比對選中的選項，並拿到元件上對應的屬性值，就能夠透過這個數值進行比對。 // ... 在 Select 元件內 // Select 元件的狀態 ... state = { selectedOptionKey: &quot;&quot;, selectedOptionValue: &quot;&quot;, selectedOption: null, openOptionList: false }; ... // Option 上的點擊事件 onOptionClick = (child) =&gt; () =&gt; { const { props: { value, optionKey } } = child; this.setSelectedOptionKey(optionKey); this.setSelectedOptionValue(value); this.setState({ selectedOption: child }); this.toggleOptionList(); }; 在點擊事件內雖然我做了許多件事情，不過可以看到我從 child 的 props （也就是 &lt;Option/&gt; 上的屬性內容）取出兩個屬性值，分別為 value 以及 optionKey，其中 optionKey 是每個 &lt;Option/&gt; 上都會有，用來區別選項且應該要不重複的值，之後我們就可以拿這個值來決定目前所選中的選項是哪一個。 比對的方式很單純，既然我們可以拿到 &lt;Option/&gt; 上的屬性，我們就能夠拿出來跟儲存在 &lt;Select/&gt; 代表被選中的 &lt;Option/&gt; 的 selectedOptionKey 這個狀態做比對，如下： // ... 在 Select 元件內 // 選項表單 &lt;div className=&quot;optionList&quot;&gt; {Children.map(children, (child) =&gt; React.cloneElement(child, { ...child.props, onClick: this.onOptionClick(child), isSelected: child.props.optionKey === this.state.selectedOptionKey }) )} &lt;/div&gt; 我們直接利用 isSelected 以布林值傳給下層的 &lt;Option/&gt; ，這麼一來 &lt;Option/&gt; 就能夠透過這個數值決定要顯示什麼樣的內容，或是樣式，我們來看看 &lt;Option/&gt; 的內容。 // Option 元件 function ClassOption({ children, isSelected, onClick }) { return ( &lt;div onClick={onClick} className={`option ${isSelected ? &quot;isSelected&quot; : &quot;&quot;}`} &gt; {children} &lt;/div&gt; ); } 由於這個例子中 &lt;Option/&gt; 需要顯示的東西和需要判斷的邏輯比較單純，所以元件內容也比較單純，但可以看到我們拿到從 &lt;Select/&gt; 元件裡面傳入的兩個屬性來做一些顯示和判斷，這兩個屬性都不是在使用元件時傳入的，而是從 Select 元件來，所以如果不了解原理的話，就沒辦法直接看出來處。 利用 Class Compoennt 靜態屬性 通常複合元件在設計時會把複合元件中的子元件掛在父元件上，而因為在本篇文章所舉的例子裡面，剛好用到的是 Class Component ，所以可以利用靜態屬性的概念，讓兩個看似分離的元件，更明確的產生關聯，所以我們在 &lt;Select/&gt; 元件內會多做一件事情： // Select 元件內 static Option = ClassOption; 善用 Context API 雖然在這個例子裡面我們沒有使用到，不過若是想要設計的複合元件結構比較複雜，有多層元件結構的話，可以利用 React 提供的 Context API 來進行跨多層元件的數值內容傳遞。 // Select 元件 &lt;SelectContext.Provider value={{ [ 想要傳遞的數值內容 ] }}&gt; // ... 元件內容 &lt;SelectContext.Provider&gt; 最終完成的結果 在上面的內容之中我只解說幾個最關鍵的部分，至於沒有講到的其他細節\b，就請讀者自己思考看看囉，在這邊附上完整的程式碼範例。 動手試試看 本篇文章的是以 Class Component 為例子來進行設計這個複合元件，不過在撰寫這篇文章的此刻，Functional Component 是實際開發時比較主流的元件類型，其實利用 Functional Component 照理說也能夠設計出使用方式與這個例子完全一樣的複合元件，讀者們在了解複合元件的概念後，也可以自己嘗試使用 Functional Component 來實做看看自己的複合元件，那麼，就先說到這囉！","link":"/2021/04/03/react-compound-component/"},{"title":"就是要一起拖拖拉拉！(二) - 利用 DataTransfer API 實作拖拉元素間的資料傳遞","text":"上週提到了瀏覽器拖拉時會陸續觸發的幾個事件，我們知道了對可拖曳物件 (draggable) 進行拖曳與放開時以及拖曳物件滑過目標物件上方時，都會觸發對應的事件。今天我想研究看看在事件與事件之間可以做什麼事情，瀏覽器提供了 DragEvent 這個 API ，讓我們可以在開始拖曳時夾帶資料，並在拖曳結束放開時取得該筆資料。 Outline DataTransfer 物件 實際應用 DataTransfer API DataTransfer 物件 上次有提到在瀏覽器操作中的拖曳功能，必須要自己搭配事件處理來實作，但其實有一些拖曳行為是預設就是有效，像是網頁連結和圖片的拖曳，以及文字選取的拖曳（反白）。而在這些以外的元素如果要觸發拖曳就必須使用 draggable 屬性來達成。 而在拖放事件的最一開始， ondragstart 事件被觸發時，我們其實可以利用事件物件（也就是事件回呼函式內的第一個參數 event ) 裡面的 dataTransfer 物件來賦予被拖放物件想要挾帶的資料，使用方式如下： let dragger = document.querySelectAll('#dragger') dragger.addEventListener(&quot;dragstart&quot;,function(e){ e.dataTransfer.setData('text/plain', 'This text may be dragged') }) dataTransfer.setData dataTransfer 物件負責處理拖曳行為之間的資料傳輸，這個物件裡面有兩個方法，分別是 setData 與 getData ， setData 使用方式如下： dataTransfer.setData(format, data); 這個 API 有兩個參數，分別是： format ：想要挾帶的資料格式，使用的是網頁常見的 MIME 格式字串，如文字格式就是 text/plain ，關於 MIME 型別可以參考 MDN 說明。 data : 想要挾帶的資料 dataTransfer.getData 而在拖曳行為結束觸發 drop 事件時，則可以反過來利用 dataTransfer.getData 來取得前面挾帶的資料。 dataTransfer.getData(format); 記得必須透過同樣的格式字串來取得同一個參數。 DataTransfer.types 回傳在 ondragstart 時透過 setData API 所設定資料的資料格式，因為可能不會只設定一種格式的資料，所以會以陣列的方式來表示。 實際應用 Datatransfer API 接下來我們就試試看根據上面的說明，如何應用到實際的拖拉操作流程上，修改上次的範例來做說明，先做一個輸入框來設定拖曳時想要挾帶的數值。 let dragDataInput = document.querySelector('#dragDataInput') &lt;div class=&quot;row align-items-center&quot;&gt; &lt;div class=&quot;col-2 d-flex align-items-center&quot;&gt; &lt;p class=&quot;m-0&quot;&gt;輸入想要挾帶的資料:&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-10&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;dragDataInput&quot; class=&quot;form-control&quot;&gt; &lt;/div&gt; &lt;/div&gt; 之後在原本的 dragststart 事件處理裡面，利用 dataTransfer 設定夾帶資料，這邊資料的格式就用字串做表示。 dragger.addEventListener(&quot;dragstart&quot;,function(e){ dragTemp = e.target e.dataTransfer.setData('text/plain', dragDataInput.value) }) 後面一樣在 drop 事件就能夠透過 e.dataTransfer.setData 收到前面設定的資料了，我把它掛到拖曳完成的元素上。 dropper.addEventListener(&quot;drop&quot;,function(e){ ... let dragText = e.dataTransfer.getData('text/plain') dragTemp.append(dragText) e.target.style.color=&quot;#fff&quot; ... }) 完整範例可以在這裡看到。 參考文章 https://developer.mozilla.org/zh-TW/docs/Web/API/HTML_Drag_and_Drop_API","link":"/2020/03/07/web-dnd-2/"},{"title":"就是要一起拖拖拉拉！(一) - 瀏覽器 Drag and Drop API 操作","text":"Drag and Drop 在一些網頁產品裡面算是蠻常見的應用，使用起來的效果也常常讓人印相深刻，在像是 Trello、Asana、Cakeresume 等需要進行一些計畫安排或是畫面規劃等互動性較強的工具，都會看到它的蹤影，由於之前的工作內容剛好都沒有機會碰到，最近又剛好想要研究，今天就讓我們一起來研究相關的 API 吧。 Outline 基本概念 宣告 draggable 與 droppable 元素 可拖曳 (Draggble) 元素上的事件 可拖曳 (Droppable) 元素上的事件 實作 Drag and Drop 範例 總結 參考資料 基本概念 瀏覽器的拖拉功能基本上是由一連串的事件觸發而組成。在要被拖拉的元素上要先以 draggable的 屬性宣告，告訴瀏覽器這個元素是可以被拖移的，而在能夠放下拖拉元素的另外一個元素，相對的也必須以 dropabble 屬性宣告，才能夠接收拖移過來的元素內容。 而這一連串拖移的動作又可以拆分為幾個發生的時間段，說到這裡，對瀏覽器比較有概念的人應該可以猜到了。沒錯，這些時間段在瀏覽器內都是一個對應會被觸發的事件 (以下使用 Camelcase 做表示）： 開始拖移 (onDragStart) 拖移中 (onDrag) 拖移進入某個元素 (onDragEnter) 拖移經過某個某個元素 (onDragOver) 拖移離開某個元素 (onDragLeave) 結束拖移 (onDragOver) 而拖拉期間與元素互動的方式，將會由開發者利用這些事件觸發來決定，詳細可以參考 MDN 官方網站，接下來會試著實作出基本拖放功能範例，以此說明一些常用到的拖拉事件觸發是如何發生。 宣告 draggable 與 droppable 元素 首先我們要先做出一個可拖曳的跟可放置的元素。分別在兩個素上將 draggable 屬性與 dropabble 屬性宣告為 true （這個專案使用 Bootstrap 作為輔助，後面會有範例）。 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row justify-content-center&quot;&gt; &lt;div draggable=&quot;true&quot; class=&quot; box box-dragger&quot;&gt;&lt;/div&gt; &lt;div droppable=&quot;true&quot; class=&quot;box box-dropper&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 之後，我們來看看上述提到的每個事件代表的意義與被觸發的時機，才能在實作時知道什麼時候該用什麼事件來搭配完成功能。 可拖曳 (Draggble) 元素上的事件 DragStart 事件 這個事件只會在被拖曳元素剛開始被拖曳時被觸發一次，我們可以試著在 .box-dragger 元素上宣告 dragstart 的事件監聽，接著就可以試著拖曳看看。 dragger.addEventListener(&quot;dragstart&quot;,function(){ console.log(&quot;drag start!!!!&quot;) }) DragEnd 事件 dragend 事件會在拖曳結束時被觸發，應該很好理解，利用以下的程式碼片段： dragger.addEventListener(&quot;dragend&quot;,function(){ console.log(&quot;drag end!!!!&quot;) }) 之後試著拖曳 .box-dragger 元素後再放開就可以看到上述的事件被觸發。 Drag 事件 drag 事件會在可以拖曳元素被拖曳期間持續被觸發： dragger.addEventListener(&quot;drag&quot;,function(){ console.log(&quot;draging!!&quot;) }) 可以看見一如上面說的 dragstart 事件只會被觸發一次，而 drag 事件會在拖曳期間持續被觸發。 可放置 (Droppable) 元素上的事件 DragEnter 、DragLeave 事件 這兩個事件的觸發分別會在被拖曳元素進入可放置元素和被拖曳元素離開可拖曳元素時發生： dragger.addEventListener(&quot;dragenter&quot;,function(){ console.log(&quot;dragenter&quot;) }) dragger.addEventListener(&quot;dragleave&quot;,function(){ console.log(&quot;dragleave&quot;) }) 試著把元素拖曳進可放置元素再離開，可以發現 dragenter 和 dragleave 分別被觸發了一次。 DragOver 事件 dragover 這個事件名稱代表的意義應該不難理解，意思是當可放置元素上有拖曳中的元素經過，就會持續觸發，有點像是 CSS 裡面的 :hover 所代表的使用情境，試著使用下面的程式碼試試看這個事件的綁定吧： dropper.addEventListener(&quot;dragover&quot;,function(){ console.log(&quot;dragover&quot;) }) 順利的話應該會看到以下結果： Drop 事件 在 MDN 裡面， drop 事件的定義是「一個元素或文字選取區塊被放置至一個有效的放置目標時觸發。」，但想要順利的觸發這個事件必須要注意的一點是，在 drop行為發生之前的 dragover 事件的預設行為會阻止 drag 行為的完成，也會讓 drop 事件無法被觸發。 因此必須在 dragover事件裡面停止預設的行為，這可以用 preventDefault 方法來達到。對這個預設行為有興趣的可以先參考官方說明，這部分預計在下一篇文章會有更詳細的說明。 dropper.addEventListener(&quot;dragover&quot;,function(e){ e.preventDefault() }) dropper.addEventListener(&quot;drop&quot;,function(e){ console.log(&quot;drop!&quot;) }) 實作 Drag and Drop 範例 現在就讓我以前面的說明為例，來看看如何做出能夠可以把 dragger 拖放到 dropper 元素內的拖曳功能吧，我們已經宣告完 draggable 以及 droppable 的元素了，接下來只要利用事件處理就能夠完成拖拉互動了。 現在我們有兩個方塊，左邊藍色方塊是前面提到的 dragger 右邊則是 dropper ，目標是讓藍色方塊可以被拖曳拉到右邊另一個方塊，而一個很基本的構想是在 drop 事件觸發時，拿掉原本的舊藍色方塊，並把藍色方塊複製一份，放到右邊橘色方塊裡面。 我們可以用另一個常見的 Web API 叫做 appendChild ，原本是用來在元素內掛載新的元素，不過如果所掛載的對象是一個已經存在的元素，就會變成是移動元素的效果（驚喜不驚喜意外不意外？沒關係我也是現在才發現），可以參考 W3School 的範例。 所以在 dragstart 發生時，我先試著把藍色方塊的內容暫存到另外一個變數裡面。 let dragger = document.querySelector(&quot;.box-dragger&quot;) let dropper = document.querySelector(&quot;.box-dropper&quot;) let dragTemp; dragger.addEventListener(&quot;dragstart&quot;,function(e){ dragTemp = e.target }) 接下來要記得上面提到的，在 dragover 裡面要阻止瀏覽器預設行為。 dropper.addEventListener(&quot;dragover&quot;,function(e){ e.preventDefault() }) 這個時候 drop 事件已經可以順利被觸發，只要在 drop 事件觸發時，在 event.target 也就是 dropper 裡面掛載藍色方塊的元素，就可以完成移動。 上面會看到兩個方塊沒有對齊是因為我一開始有給一些 margin ，不過從開發者工具裡面可以確定藍色方塊已經被拖曳放到橘色方塊之中。 再搭配適合的事件觸發以及適當的樣式調整，像是 dragenter 時改變顏色、 dragleave 時復原，就可以讓拖曳的元素經過可放置元素時產生顏色的改變來提示使用者。 最後在 drop 事件觸發並掛載後，調整一下元素的 spacing 可以看到比較好看的效果了。 想了解完整程式碼的話，我把這個 Demo 放在 Codepen 。 總結 其實拖拉互動效果並沒有非常複雜，可以想成瀏覽器提供給我們從拖拉開始到結束，一連串的時間段，讓我們可以在期間自由地做互動效果的調整，只要知道什麼時候該做哪些處理，基本上就是網頁元素的互動而已。 而想要達成拖拉互動效果也並不是只有一種方法，也沒有最正確的答案，只要熟悉DOM 元素的操作，能達到心中想要的效果我相信都是可以的。下一章節一樣會針對瀏覽器這個拖拉功能做稍微深入一點的研究，希望今天的主題能夠帶給你一些新的啟發，那麼下次見啦！ 參考資料 MDN 文件 W3School - appendChild","link":"/2020/02/28/web-dnd-1/"},{"title":"React 與 Webpack4 專案建置全實戰 (1)","text":"寫了快一年的 Vue ，最近剛接觸 React ，我還挺中意這種架構跟撰寫方式的，所以順手研究了一下 Webpack。如果你在開發時是使用react-create-app 之類的手腳架，應該會跟 Vue 的 vue-cli 工具蠻類似的。但這類工具不太容易客製化的調整設定（有時候，你並不需要那麼多功能）。 所以為了讓自己能夠適應各種需求跟情況，我打算試試看打造一個適合自己做開發的 React 起始專案，方便之後進行任何需要 React 開發的時候使用。 適合閱讀對象 適合有至少接觸過手腳架工具或是 Gulp、Grunt 等 Task Runner 處理檔案的 Js 開發者，完全初學者建議先用手腳架練習即可，以免未入門先棄坑。 大綱 因為文章內容有點多，所以我預計分為三個部分來解說： 第一部分 配置說明 webpack 緣由 安裝 webpack webpack.config.js 設定及說明 第二部分 使用 package.json 建立自己的 script 指令集 webpack-dev-server 開始撰寫 JS 程式碼 第三部分 引入 React 搭配 Eslint 做檢查 延伸文章 配置說明 預計會使用到的工具如下 : webpack : 一定要的 webpack-dev-server : 加速開發流程 babel : 用來把專案裡的 JS 及 JSX 轉譯成為瀏覽器看得懂的程式碼 sass : 方便做 CSS元件模組化，ㄧ樣需要轉譯成 CSS eslint : 檢查 JS 撰寫習慣必備 Webpack 什麼是 Webpack ? Webpack 是一套非常完整的前端打包工具，他讓開發人員透過設定檔的方式很方便的去規劃專案架構。早期我們撰寫 Sass 的時候是透過 Grunt 或是 Gulp 等Task Runner來做轉譯，但以現在前端開發的規模，除了 Sass 轉譯，我們常常還需要處理其他事情，例如 minify、uglify 及 JS新舊版轉譯，當這些事情開始複雜起來的時候，相較於一個一個去撰寫 Task 的內容，有一個統一設置入口的 Webpack 就方便快速許多。 安裝 Webpack Webpack 必須在 node 環境下執行，所以請注意你的系統是否有安裝 node ，如果沒有，我推薦你使用 nvm 安裝，除了可以方便的管理你的 node 版本，連 npm 都幫你裝好了。 Step1. 產生 package.json 你的專案目錄底下必須 package.json 檔案以紀錄你使用的套件，這邊可以使用指令： npm init 來產生 package.json，輸入後會有一些關於設定的問題，如專案名稱或是版本號，請依照自己的意思輸入就好。 Step2. 用 npm 安裝webpack webapck 只會在開發環境使用，所以安裝的時候請加上參數 npm install --save-dev webpack Step3. 使用 webpack-cli 如果一開始不熟，想要快速產生設定檔模板的話，我找到了一個還不錯的工具： webpack-cli，它用起來就像上面 npm init ，使用互動介面來幫你產生設定檔。 npm i webpack-cli @webpack-cli/init npx webpack-cli init webpack-cli還有其他方便的指令，可以參考他的Github，但我後續還是比較習慣手動修改內容。 以上有幾個地方值得注意的： 第二個問題提到的「 entry file 」 指的是 Ｗebpack 來抓取你來源檔，準備編譯輸出時，所「進入」的第一個檔案，你可以想成是進入點。 第三個提問：「what the location of the app…」指的是進入點檔案的確切位置（相對於專案根目錄） 第四個提問：「 which folder will your…」指的是 檔案打包處理完之後要輸出到哪裡。 最後一個提問由於我還是比較習慣 使用sass，所以我選擇它。 webpack.config.js 設定及說明 產生完 config 檔之後，你會在裡面最先看到的應該有 module 、 entry 、 output 、plugins 四個設定，而這也是我們在調整的時候最長會需要注意的四個設定，以下將一一簡單介紹。 （ 使用 webpack-cli 所產生的 config 似乎不會產生entry設定，但沒關係，你可以之後再補上，而且 webpack 也會有預設值，所以不用擔心會有問題。 ） entry ： 進入點，你可以直接給一個路徑字串，但他其實還可以用物件跟陣列來表示，這邊先不詳細說明。 entry: './app.js', output 輸出點，表示檔案被處理完之後要放的位置，最常被使用的名稱是「 dist 」。 output: { path: path.join(__dirname, 'dist'), filename: '[name].js', }, module 用來定義不同種類的檔案（模塊）是如何被處理的，會根據不同的副檔名套用不同的 rule ，也是最主要告訴 webpack 檔案如何被處理的設定，舉例來說，剛剛在 cli 設定的時候，最後的預處理我選擇了 sass ，他就在模板裡幫我產生了下面的內容 ： module: { rules: [ { test: /\\.(scss|css)$/, use: [ { loader: 'style-loader' }, { loader: 'css-loader' }, { loader: 'sass-loader' } ] } ] }, 以上設定的意思是「只要是.scss 或是 .css結尾的檔案，就幫我使用下列的處理方式。」，loader在 webpack 裡面主要是用來做轉譯處理的模組，所以記得在使用你想要的 loader前，要先使用 npm 安裝喔～ 這邊要注意的是，當使用多個 loader 處理檔案時，loader 是從最後面開始被載入的（bottom-up），知道這點之後應該就可以理解上面的意思： 先透過 sass-loader 將 sass 檔案轉成 css 後 然後透過 css-loader ，讓我在 js 檔裡可以直接引入 最後透過 style-loader ，以在 &lt;head&gt; 內插入 &lt;style&gt; 標籤的方式，讓我剛剛在 js 檔裡引入的 css 內容順利生效」 plugin 除了上述 module 的處理，如果還有一些功能想要達成，還可以透過 webpack 的擴充套件來處理，例如我想要在把我 bundle 完的 js 檔案自動的插入某個 html 檔，讓我少做一些雜事，就可以使用 HtmlWebpackPlugin，官方還有推出許多的 Plugin 以便符合不同使用情境，可以參考這裡。 plugins: [ new HtmlWebpackPlugin({ template: './static/index.html' }), ], 處理前的 html 模板（static/index.html）: &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 處理後的 index.html: &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/bundle.js&quot;&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以看到 Webpack 幫我們把需要的 js 跟 css 資源載進來了。 先寫到這裡，在這個部分我只針對設定的屬性功能做說明，還沒有確切說到如何使用 Webpack 進行打包處理，下個章節開始會有更多實作的部分，所以請你消化吸收關於這些設定的方法之後，繼續前進吧！ 下一篇：React 與 Webpack專案建置全實戰 (2)","link":"/2019/05/10/webpack-react-1/"},{"title":"React 與 Webpack4 專案建置全實戰 (2)","text":"這是這個系列的第二部分，如果想從頭開始看的話可以往上一篇前進： React 與 Webpack4 專案建置全實戰 (1) 這個章節會是比較實戰的內容，前面已經解說完 webpack 的基本設定內容，現在讓我們來看看要如何實際執行。 文章大綱 使用 package.json 建立自己的 script 指令集 webpack-dev-server 開始撰寫 JS 程式碼 使用 package.json 建立自己的 script 指令集 （已經熟悉 node 的開發者可以跳過） 如同前面所說， webpack 必須在 node 環境下才能夠被執行，所以在專案目錄下通常會有 package.json 檔。 package.json 解說 如果前面你是使用 webpack-cli ，那麼它應該就會幫你產生一份 package.json 檔 ，這份檔案是 node 用來記錄專案所需要的套件的描述檔，讓我們稍微看一下內容： 其中比較重要的有 script 、 dependencies 、 devDependencies 三項，分別是用來： script : 用來撰寫自己的指令，可以用 npm run “你的 script” 來執行相對應的指令內容。 dependencies : 專案開發時會用到的套件內容，因為 webpack 的使用通常只在開發階段，因此這個部分不會有相依賴的套件。 devDependencies : 開發階段使用的套件，可以在 npm install 時加入 -D ，該套件就會被記錄至此。 加入自己的 script 根據官網，webpack 最基本的指令是： webpack &lt;entry&gt; -o &lt;output&gt; 其中 entry 跟 output 各自會自動對應到 webpack.config.js 裡面的設定，所以其實直接下 webpack 也行，那麼 ，我們就在 script 裡面加入看看： package.json ... &quot;script&quot;:{ &quot;build&quot;:&quot;webpack&quot; } 然後試試看指令 : npm run build 應該沒問題，這樣的好處是之後不管我 webpack 指令怎麼修改，我在 cli 裡面執行的指令都可以是相同的。之後你就可以在 dist 資料夾裡面找到 webpack 處理完的 js 檔。 不過這種編譯方式還是會有換行符號跟空白，佔據多餘的空間，因此我們可以在指令後面加入 mode 參數 : &quot;script&quot;:{ &quot;build&quot;:&quot;webpack --mode=production&quot; } 可以看到webpack 幫我們把程式碼多餘的空白都被壓成單行了，這樣子的好處是減少程式碼體積，加快瀏覽器頁面載入速度，所以通常在開發完成準備正式上線時我們都會這麼做。 webpack-dev-server 但在開發階段你應該不會希望每次修改完檔案都要手動build ，再自己開瀏覽器來看吧!? 這時候我們就希望他能夠即時偵測修改並重新產生新的 bundle 一個比較簡單的方式是： webpack --watch 使用這個方式， webpack 會自動幫我們偵測檔案的變化並重新 build 一次，但還是需要手動重新整理才看得到結果。 安裝 webpack-dev-server 所以這裡我要介紹一個 webpack 裡一個很好用的套件叫做 web-dev-server，他可以直接幫你架起一個本地的開發 server ，除了能夠直接偵測並更新，還能自動幫你刷新頁面，省了不少功夫，毫無疑問是開發必備工具。 首先我們要安裝： npm install webpack-dev-server --save-dev 接下來在 webpack.config.js 裡面新增對應的設定區塊： webpack.config.js ... devServer: { contentBase: path.join(__dirname, 'dist'), open: true, hot: true } “contentBase” 是 server啟動的時候預設的根目錄，通常是對應到編譯完檔案的資料夾 dist ，才能夠看見變更結果。 “open” 是使用 dev-server 指令啟動後自動幫你開啟瀏覽器，“hot” 是所謂的 「 hot module reload 」 ，當檔案有變更的時候自動幫你刷新內容，也是讓我想要使用它的主要原因。 其他 dev-server 相關的設定可以參考 Webpack 官方網站。 啟動及運行 我一樣在 package.json 的script 標籤裡面加入 dev-server 相關的指令： package.json ... &quot;script&quot;: &quot;webpack-dev-server --open&quot; 這裡的 open 參數，跟上面設定檔內的 open 作用相同，所以擇一就可以了，執行完後你應該就會看到自動開啟的網頁內容了，這邊再提醒一次，記得要搭配 WebpackHtmlPlugin，才能夠讓 js 的修改順利插入到 html 裡面。 開始撰寫 JS 程式碼 在前面的段落裡，我們使用 webpack-cli 來快速產生基本的 webpack 設定，包括進入點、輸出資料夾、以及轉譯 sass、css 相關一系列的 loader ，來產生瀏覽器可以看得懂的程式碼。 最後我們用了 webpack 的 WebpackHtmlPlugin，來把我們編譯好的 js 檔直接插入我們預先寫好的 html 樣板中，現在我們可以實際撰寫 js 程式碼來看看結果是不是如同我們所預期。 JS 程式碼測試，抓取元素內容 首先，在 html 樣板裡面有一個 id 是 app 的區塊，這是後面會用來插入 react內容的地方。那麼既然我已經設定好 entry file 跟我的 html 樣板，照理說我應該可以在 js 檔裡面抓到這個 #app 元素，我試著在這個元素裡面插入一些內容： document.getElementById('app').append('Hello, this is entry file from weboack bundler.') 看起來沒問題： CSS 測試，套用元素外觀 接下來我要試著引入 CSS 內容，照著前面的說明，我一樣在 src/index.js 裡面加入了： import '../scss/index.scss' 然後在 index.scss 套用所有 body 為橘色試試： body{ color:red; } 也跟預期的一樣！！ 你可能會發現這個 html 上面並沒有用來引入 css 內容的 &lt;link&gt; 標籤，這是因為style-loader 是透過插入 &lt;style&gt; 標籤的方式讓 css 內容生效，可以打開瀏覽器檢查工具查看： 測試結果都沒有問題的話，就只剩下引入 react 了！ 我在下個章節會提到需要安裝的套件以及設定方式，還有加入 eslint 的設定，如果你也沒問題，那就跟著一起往下吧！ 下一章節：React 與 Webpack4 專案建置全實戰 (3)","link":"/2019/05/10/webpack-react-2/"},{"title":"React 與 Webpack4 專案建置全實戰 (3)","text":"這篇文章應該是這個系列的最後一篇，之後如果有用到的話還是會慢慢分享 webpack 相關的設定方式。 由於使用 React 通常會搭配 JSX 語法來做開發，而這樣的撰寫方式並不能直接被瀏覽器所解析，所以我們就會需要用到 Babel 來幫助我們轉譯成瀏覽器看得懂的 JS 語法。 因此這篇文章主要會解說如何在 Webpack 裡面 Babel 相關的設定，應該不會太長，讓我們繼續看下去吧！ 安裝及設定 babel-loader 前幾章節有說過 loader 是一系列用來轉譯的套件，所以要在 webpack 裡面使用 babel 我們也必須使用 babel-loader，參考 Github 上的安裝指令： npm install -D babel-loader @babel/core @babel/preset-env webpack 其中 @babel/core 是babel 的主要部分，而 preset-env 是針對那些 JS 最新公佈但瀏覽器還沒有支援的語法做轉譯。 然後只要在 module 裡面加入以下程式碼，就可以開始設定跟使用 babel 囉： module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } ] } 其中 option 內的 presets 是為了告訴babel想要用什麼模組去做轉譯，babel 把可能的轉換整理成一系列的 preset ，當然也包含 react 的preset 啦，等等就會看到。 安裝 babel-preset-react 如上提到的，babel 也提供了 react 轉譯相關的模組，在 webpack 的設定方式也不難，先安裝： npm install --save-dev @babel/preset-react 然後ㄧ樣在 preset 裡面加上 ‘@babel/preset-react’， webpack 就會自動套用到啦，然後因為這個 preset也包含 JSX 的轉譯，所以就不用另外安裝相關模組了。到這邊你應該可以開始使用 react 跟 jsx 來做開發了，後面會陸續分享 webpack 相關，比較細節的其他設定，請大家耐心等候囉。 延伸文章 Comparison of Build Tools Webpack 打包優化策略 令人困惑的 webpack 之 entry 一看就懂的 JSX 簡明入門教學指南","link":"/2019/05/28/webpack-react-3/"},{"title":"寫給職場工作者：工作環境是否會影響一個人的思考方式？","text":"自從我進入大學階段之後，就一直有人不斷對我說要快一點決定未來人生的方向，每次被問到這個問題我都不是很能理解，這個在前面將近一半的學習生涯把學生教成考試機器的教育體系，為何又理直氣壯地期望這些學生在短短幾年內如獲天啓般突然知道自己的人生規劃？ 綜上所述，我目前是一位軟體工程師，今年是我工作的第三年，我依舊在思考人生目標，但值得慶幸的是我正在做自己喜歡的工作（而且我學很快）。雖然對未來職涯方向還沒有很清楚的藍圖，但是對於這幾年來在職場體驗到所發生的人事物依舊有一些心得，所以今天想來跟各位聊聊（個人角度下）工作本身對工作者的長期影響。 職場制約論 我相信大家應該都了解「環境很重要」這件事，以一個在台灣常見的上班族來說，光是工作的時間每天就有八小時（以上），仔細想想就佔了一個社會人士的人生將近 1/3 的時間，我們往往沒有意識到，這段時間裡面我們所做的事情、交流的對象、交談的方式在長久以來在不斷重複經歷之下，深植在腦海中。 我們可以用行為心理學裡「操作制約」來看待職場環境，操作制約的核心概念是根據行為產生的後果，會影響個體後續再重複相同行為的可能性。在操作制約裡有所謂的「增強」與「懲罰」，「增強」指的是個體喜愛、想要的事物，「懲罰」則反之。在個體做了某種行為後透過增強，給予想要的獎勵；或透過懲罰，施予不想要的刺激，來影響個體（實際上行為心理學對操作制約有更詳細的分類跟探討，這邊因為篇幅關係無法做太詳盡的說明）。 如果你已經工作一段時間應該會有所體悟，常常甚至不需要主動學習，剛進入職場後就會有人來告訴你可以這樣做不可以那樣做、什麼時候要做什麼否則就會大難臨頭等等那些所謂職場的淺規則或「不成文的規定」，到頭來我們甚至不會去思考為什麼要樹立這些莫名的規章。 當音樂課只剩下畫答案卡的聲音 時間拉回更早更早——或許進入職場前我們早就是這樣學習跟成長的，還記得國小的時候學校的「嘉獎」、老師打的「甲上上上上上 / 特優」、「小過」、「大過」，現在回想起來真的很沒有意義 ——但當時我們又怎麼會意識到呢？當社團時間只剩下自習、當我們的音樂課只剩下畫答案卡的聲音，也許在熱衷於那些無聊大人訂下的守規矩遊戲時，我們的青春就這樣被被惡狠狠地蓋上了合格認證。 十幾年過去，開始工作、進入社會後，這樣的情況似乎一點也沒有減少。無聊的大人們養出另一世代壞掉的大人（ 誰知道呢，也許我才是壞掉的那一邊? ），許多人自以為當上老闆就擁有對別人所有的控制權，慣老闆的八卦早就不算新聞、另一部分人成了訓練有素的職場玩家，想盡辦法奉承巴結上司、深諳遊戲規則的這些人，教會了社會新鮮人「是非對錯」，也間接增強了這種盲目尊崇權威的社會結構，即使是在寫這篇文章的當下，台灣社會裡也許也還充斥著這樣的的公司職場環境。 盲目地追求高薪是一種慢性病 現在在台灣，軟體工程師似乎已經成為一種趨勢，許多人一窩蜂投入軟體產業、補習板根線上課程處處林立，但我總覺得許多這樣做的人再做決定之前都沒有思考過這樣的決定是否真的適合自己、或是跟價值觀是否相符。在這樣的情況下，即使後來這些人進入軟體產業，成功成為軟體工程師，終究還是會因為得不到成就感而無法堅持下去。 「知道方法的人會去工作，而知道這個人為什麼要工作的人，就會成為他的老闆」 - &lt;狼與辛香料&gt; 不管在看這篇文章的你是誰，相信我，就算你是工作者、就算很多人告訴你要找一份穩定的工作、過一個安穩的生活，你永遠都有選擇權。打開選擇權，在職場裡面若發現自己意識到思考的不對勁，就思考看看你是否適合現在的環境、你跟每天相處的同事是否是同一類型的人？ 不要勉強自己，你可以選擇一份安穩的生活，也可以選擇踏上尋找個人定位的旅程 — — 即使身邊願意這麼做的人寥寥無幾。而有時候你需要的只是多一點思考。 所以呢？ 所以關於今天問題的結論，我會說職場環境所帶來的負面影響對那些了解自己、清楚人生目標的人們是不會有作用的。所以就算現在職場上依舊有許多我們看不慣的陋習，只要願意花時間思考什麼才是最重要的，也許在了解到工作不過是追求個人目標過程中的一種手段後，那些淺規則在你眼中就會變得渺小且微不足道了。","link":"/2020/03/09/working-environment/"},{"title":"每個衝擊都是一次學習的機會 - 近期的一點心得","text":"好久不見。各位最近過得如何呢 ? 是不是又往自己的目標前進了一點 ? 一段時間沒有寫文章了，由於轉換工作環境的緣故，自從三月以來，這是第一次可以空出時間好好寫下一些東西。 我目前在 Snapask 任職，這是我第一次到比較有規模的團隊裡面，有很多專案流程的細節是以前沒有接觸過的，所以這幾個月來相對於技術學習上。我在思考方式以及工作方法等方面比較有心得，所以這篇文章不會有技術內容，而是會跟大家分享我近期的收穫，或許能夠給未來也跟我面臨相似問題的人一個參考。 目前我的公司剛好有一個 Web Team 的職缺，JD 在這，如果有興趣的人歡迎找我聊聊，或許可以幫你評估一下狀況然後幫你 Refer ，加快面試流程，你可以透過以下方式找到我： Facebook: https://www.facebook.com/mujing/ Gmail: moojitsai@gmail.com 個人過往技術狀況 有一些經驗的 Junior，靠自學誤打誤撞進入前端領域（剛滿兩年），前面經歷的都算是較小型的新創，團隊大多都不超過十人。當時工作較為偏向單打獨鬥，內容較有彈性，技術工具及解決方法策略的選擇上相對自由，可以自行決定然後直接執行，但時程規劃比較沒有組織跟流程。 參與新的團隊 因為以前合作經驗較少，所以第一次進到團隊，有很多新的工作方法以前沒有參與跟執行過，例如大家認為很常見的 Code Review 、例如跟主管們 1 on 1 、還有 scrum 中的會議流程…，其實有許多細節。 不過因為實際會遇到的工作細節每間公司一定都會不同，所以在接下來的內容我不會一一詳細的解說，我會以個人成長的角度來分享在這個新環境中學到、並為我在職涯發展上帶來不同見解的觀點。 從就職開始說起，那些剛到職的 Junior 們可能聽說過很多次，不過我可以再用我的個人經驗告訴你，永遠不要「只」以薪水來決定工作的選擇（當然該拿的還是要拿，不過如果你真的很想體驗一整年都沒有成長的倦怠感，那麼你應該試試）。 進入新環境的第一要務 我想對大部分的 Junior 來說，進入公司後最重要的一件事就是優先找到能夠讓你學習並成長的對象 （ Mentor / Role Model )，這長期來講會是一個重要的外在因素，不用擔心找不到，每個人都有值得學習的部分，但如果你觀察幾個月之後還是沒有答案，那麼你可能到錯地方了。 適應之後 工作一段時間差不多適應新的環境以後，可能會有兩種情況，一種是工作模式跟以前所習慣的差不多，一種是跟我比較像也就是公司的工作流程跟以往使用的有比較大的差距。不管是在哪一種情況底下，在這個時期都應該要著重於一件事情： 找到你想做的事 / 想解決的問題 不要把自己當勞工來看，找到一個你想達成的長期目標，通常這個目標不會是被分派的任務之一，因為你會有自己的目標，公司也會有自己的步伐要前進，想辦法找到這兩者間的平衡點。這會回到一個問題是你當初選擇這間公司的原因、或是說你想在這間公司想得獲得的經驗、講官腔一點也能說是未來展望。相較於上面提到的外在因素，這則會是長期的內在動機，也是遇到阻礙時能夠支撐你的重要原因。 對那些適應良好的人這件事可能會自然地發生。即使是對不太能適應或遇到麻煩的人，若你有確保做好第一點提到的確保工作環境有學習對象，那麼你應該能夠得到一些引導而在設法解決後再度回來思考這個問題。 我獲得的幾個觀點 1. 看見每個人價值觀的不同 在中小型團隊裡面會遇到許多不同的人，幾個月的合作跟交流下來我可以明顯感受到每個人都有每個人的做事方法跟步調，這是一個很棒的地方，因為每個人都有能夠學習的地方，試試看跟他們交流你的想法，常常能夠讓你從不同角度重新看帶事情。 2. 先想清楚，再動刀 這一點，講老套一點就是三思而後行，在執行某個任務之前應該先在腦中演練過要執行的細節，這個 pattern 不只是工程師的基本能力，生活中很多地方都能夠應用。也避免邊做邊想讓自己遭遇一團混亂的處境。 以我的經驗來說，在以往的工作經驗裡面我都可以快速執行想做的方法然後遇到問題再快速設法解決，但在注重工作流程的公司這麼做就很容易遇到狀況。 ３. 不斷尋找工作流程上能夠改善的地方 這不管對哪一個階段的工作者都很重要，但我相信對初出茅廬的 Junior 工程師來說尤然。每個人在執行上都會有盲點，對較為資深的工程師來說這些盲點可能不會是個大問題，但對資淺工程師來說的話，一旦某個環節碰到問題，通常就會讓他們立刻明顯的感受到阻礙。 4. 使用新工具：蕃茄鐘 這一段呼應上一點，我是一個非常容易分心的人，因為我對許多身邊發生的事感到好奇，我相信這是我的優點。不過這個特點對於完成任務來說反而是一個問題。我知道我需要建立一個能夠讓自己專心的工作模式，試了很多方式後決定開始試試看使用蕃茄鐘，沒想到一試成主顧。 基本上蕃茄鐘就是讓自己專心時間後，再放鬆一小段時間，然後持續進行這個循環。對我來說感受比較明顯的地方有： 明確感到時間的流逝： 也就是增強對時間的感知，以往因為較長時間的連續執行工作，有時候容易造成正在做的事情已經偏離最一開始想要達成的目標，但自己還沒有察覺，在番茄鐘的工作法底下比較能夠知道目前正在做的某件事情已經花掉多少時間。 比較能夠把一件大任務切成許多小部分： 因為蕃茄鐘的這種模式，所以在使用時自然必須學著切分任務，再開始進行之前先想好這段時間要做什麼事情，並在結束後來看看自己的成效。 適度讓大腦休息： 長時間的連續工作真的比較容易遇到盲點，例如有時候遇到某個問題解不掉，然後又執著在錯誤的程式碼環節，就容易卡住很長一段時間，但往往休息一段時間後再回來，不就後就能找到癥結點。 勾勒自己的未來 以上就是我近期的心得，寫在最後面，有一件應該要常常被思考的事情是去設想自己在近幾年之後在工作領域裡的角色定位，你想要有能力做到什麼樣的事情？解決什麼樣的問題？這些都是最基本卻又很容易被忽略的事情。 畢竟在這個工程師這個行業裡頭，技術是學不完的，但你的時間卻非常有限。不知道這些經驗能夠幫助你到什麼地步，不過還是希望你能夠有所收穫，不用免強自己做個鐵人、也不要甘於當個水手，做個靈活的海盜，適當利用環境、武器跟手邊的資源，該守就守，該進攻進攻，容許自己能夠時時刻刻調整航向跟目的地。如果將來我們能夠在航道上相遇，那麼希望我能夠ㄧ如往常地帶給你一些新奇的東西與驚喜。就寫到這，下次又等到我有空時再見了！","link":"/2020/09/06/working-reward/"},{"title":"JS世界時間表","text":"這篇講解的是我如何從頭開始研究Javascript時區轉換相關API，以及一些時區相關的奇怪專有詞，最後做出世界時間表，我會盡使用淺顯易懂的方式來說明，如果你看完還是對內容有疑問，可以直接聯絡我 ，一起交流。順帶一提，你沒看錯現在是早上4:30 (X_X)。 Outline TimeStamp是什麼? GTM+8 與 UTC+8 ? 差在哪? toLocaleTimeString的使用 補充：DOM 操作 — cloneNode TimeStamp是什麼? TimeStamp 可以想成是某個執行動作的時間點，經常我們在操作資料的時候（最常見新增/修改），會希望留下時間紀錄，以免出問題的時候可以追查。就像公家單位的公文在蓋章的時候都會有時間戳記，系統也是ㄧ樣，只不過有時候不是我們常見的日期格式。 要用js觀察TimeStamp，可以在瀏覽器下: Date.now(); //1549041946540 你應該可以得到奇怪的一串數字，類似這樣 1549041946540 這個是什麼意思呢？是指從 1970/01/01開始至今的秒數，也就是TimeStamp。 為什麼是1970年？據說那是工程師們自己訂的，Unix系統的誕生日期。一樣透過Date物件可以把這串秒數轉成一般的TimeString: new Date(Date.now()) // Sat Feb 02 2019 01:32:14 GMT+0800 (台北標準時間) TimeString 也是String，只不過有一定的格式，才能給Date相關api讀取。 有興趣的人可參考這篇 。 GTM+8 與 UTC+8 ? 差在哪? 其實這兩種格式在一般使用的情況下沒有差別，只是GTM是歷史沿革，UTC是後來科學家發現一種可以更準確測量時間的方式而訂出的格式，他們之間的時間差只在區區幾秒之間（但這足以讓某些科學家抓狂），總之，因為GTM這個格式已經被國際使用許久，所以就算UTC出現以後，還是沒有消失 (跟IEㄧ樣，號稱時代的眼淚，但你不消失我才會流淚)。 W3School的解釋： The UTC() method returns the number of milliseconds between a specified date and midnight of January 1, 1970, according to universal time. Tip: The Universal Coordinated Time (UTC) is the time set by the World Time Standard. Note: UTC time is the same as GMT time. 基本上把他看做ㄧ樣就行了（除非你真的無法無視閏秒XD）我自己一般還是習慣使用UTC格式。 new Date(Date.now()).toUTCString() // 拿到目前UTC+0 的時間 toLocaleTimeString的使用 Js裡面時間相關api有很多，要算出不同時區的時間其實有不只一種方式，這裡用我覺得比較直觀的toLocaleTimeString()，第一個參數是語系，在後面的Option裡面可以設定很多格式，timeZone就是用來設定時區： let now = new Date(Date.now()) let month= now.toLocaleDateString(‘en-US’,{timeZone:’Your Time Zone’’,month:’long’}) TimeZone 的格式可以參考這個列表，我拿到時區後，直接綁在html上面，這樣在一開始渲染時，就可以直接拿到，非常直接。 &lt;li class=”zone London bg-white” id=”London” time-zone=”Europe/London” &gt;…&lt;/li&gt; option 兩個常用設定值 在Option裡面除了設定timeZone，也可以設定時制 {…hour12:false} //24小時制 甚至可以直接拿到完整的月份名字，如此一來就不需要另外寫月份的mapping表: let now = new Date(Date.now()) let month= now.toLocaleTimeString(‘en-US’,{timeZone,month:’long’}) //”February, 3:44:46 PM” 補充：DOM 操作 — cloneNode 這邊比較特別的是，因為重複的版型我習慣利用類似template的方式去做，所以我在底下區塊把重複的結構拉出來： &lt;div id=”zone-template” style=”display:none”&gt; &lt;div class=”country”&gt; &lt;div class=”name”&gt;NEW YORK&lt;/div&gt; &lt;i class=”date”&gt;27 JAN,2019&lt;/i&gt; &lt;/div&gt; &lt;div class=”time”&gt;02:46 &lt;/div&gt; &lt;/div&gt; 然後在畫面啟動的時候在去跑回圈一個一個掛到&lt;li&gt;裡面，記得使用cloneNode，確保這個版型能夠成功複製到每個區塊，如果單純用appendChild可能會有問題，詳情可以參考這篇。","link":"/2019/02/12/world-time/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"frontend","slug":"frontend","link":"/tags/frontend/"},{"name":"地下城","slug":"地下城","link":"/tags/地下城/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/tags/w3HexSchool/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"devOps","slug":"devOps","link":"/tags/devOps/"},{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"rails","slug":"rails","link":"/tags/rails/"},{"name":"ruby","slug":"ruby","link":"/tags/ruby/"},{"name":"ruby on rails","slug":"ruby-on-rails","link":"/tags/ruby-on-rails/"},{"name":"frontend-force","slug":"frontend-force","link":"/tags/frontend-force/"},{"name":"鐵人賽30天","slug":"鐵人賽30天","link":"/tags/鐵人賽30天/"},{"name":"ironman30","slug":"ironman30","link":"/tags/ironman30/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"typeScript","slug":"typeScript","link":"/tags/typeScript/"},{"name":"working","slug":"working","link":"/tags/working/"}],"categories":[{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"w3HexSchool 2020 年度鐵人賽","slug":"w3HexSchool-2020-年度鐵人賽","link":"/categories/w3HexSchool-2020-年度鐵人賽/"},{"name":"Canvas","slug":"Canvas","link":"/categories/Canvas/"},{"name":"devOps","slug":"devOps","link":"/categories/devOps/"},{"name":"FullStack","slug":"FullStack","link":"/categories/FullStack/"},{"name":"IThome - 鐵人賽30天","slug":"IThome-鐵人賽30天","link":"/categories/IThome-鐵人賽30天/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"走在漫漫長路 - 工作心得","slug":"走在漫漫長路-工作心得","link":"/categories/走在漫漫長路-工作心得/"}]}
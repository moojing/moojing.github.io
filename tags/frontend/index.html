<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>標籤: frontend - Moojing&#39;s Blog</title>


    <meta name="keywords" content="frontend,backend,javascript">
<meta property="og:type" content="website">
<meta property="og:title" content="Moojing&#39;s Blog">
<meta property="og:url" content="https://www.muji.dev/tags/frontend/index.html">
<meta property="og:site_name" content="Moojing&#39;s Blog">
<meta property="og:locale" content="zh-TW">
<meta property="og:image" content="https://www.muji.dev/images/og_image_name.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Moojing&#39;s Blog">
<meta name="twitter:image" content="https://www.muji.dev/images/og_image_name.png">







<link rel="icon" href="/images/favicon.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-134605527-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-134605527-1');
</script>
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="Moojing&#39;s Blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About Me</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜尋" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-8-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/tags">標籤</a></li>
            <li class="is-active"><a href="#" aria-current="page">frontend</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2021-04-03T10:14:38.000Z">2021-04-03</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Javascript-React/">Javascript React</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 分鐘 閱讀文 (大約 3082 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2021/04/03/react-compound-component/">React 設計模式 - 複合元件</a>
            
        </h1>
        <div class="content">
            <p>一般來說在進行正式的專案開發，製作可以重複被使用的元件時，常常也必須考慮到元件的彈性、與可維護性。因為我們不知道在未來，這個元件會因為產品的需求而產生怎麼樣的調整，所以最低程度地保持元件的可擴充性就可以讓開發者在這個時候比較輕鬆的以最小限度的影響來達成想要的修改。</p>
<p><strong>複合元件( Compound Component )就是一種可以同時提高可維護性跟彈性的元件設計方法</strong>，或稱為設計模式（ Design Patern ) 。設計模式一詞源自更早期的軟體界發展歷史，這個詞可以<strong>用來代稱那些應付經常出現問題的解決辦法</strong>。亦即設計模式是經年累月透過所有軟體界的開發者不斷地遇到相同或類似問題之後，慢慢整理出來的方法。有一些設計模式是所有語言都可以通用的，例如你可能會聽過的「 工廠模式 」、「 觀察者模式」。而有一些模式是針對特定情境的問題所設計的，我們今天要談的複合元件就是前端元件開發的設計模式之一。</p>
<h2 id="需要的先備知識"><a class="header-anchor" href="#需要的先備知識"></a>需要的先備知識</h2>
<p>這篇文章主要會講解如何設計一個複合元件，在繼續往下閱讀之前，你可能要確保自己了解 React children 與 context 的相關概念，才能夠比較輕鬆的閱讀這篇文章所提及的內容，在這邊附上幾篇可以參考的資源：</p>
<ul>
<li>React Children  -  操作元素的 React 原生 API ：
<ul>
<li><a href="https://codeburst.io/a-complete-guide-to-props-children-in-react-c315fab74e7c">A Complete Guide To props.children In React | codeburst</a></li>
<li>官方文件：<a href="https://reactjs.org/docs/react-api.html">React Top-Level API</a></li>
</ul>
</li>
<li>React 裡面 Context 的概念：
<ul>
<li>官方文件： <a href="https://reactjs.org/docs/context.html">Context – React</a></li>
</ul>
</li>
</ul>
<h2 id="複合元件是什麼"><a class="header-anchor" href="#複合元件是什麼"></a>複合元件是什麼</h2>
<p>複合元件，或稱合成元件( Compound Component ）可以從詞面上看出它大致的意思，就是指數個聚集在一起，並有某些相互關係的元件。<strong>透過複合元件，可以讓兩個或兩個以上相關聯的元件用一些不明顯的方式來共用狀態</strong>，這是什麼意思，而複合元件到底又解決了什麼樣的問題呢？</p>
<h2 id="元件常見的多層結構問題"><a class="header-anchor" href="#元件常見的多層結構問題"></a>元件常見的多層結構問題</h2>
<p>舉我們常見的下拉選單為例，如果我們現在想要製作自己的選單元件，最直觀的製作方法會是直接創造一個元件，然後把所有相關的資料傳入：</p>
<pre><code>import { useState } from &quot;react&quot;;

function Option ({name, value, onClick}) {
    return 
        &lt;option
          className=&quot;option&quot;
          value={value}
          onClick={onClick}
        &gt;
          {name}
        &lt;/option&gt;
}

export default function Select({ options }) {
  const [selectedValue, setSelectedValue] = useState(options[0]);
  const onClickOption = (option) =&gt; () =&gt; setSelectedValue(option);
  return (
    &lt;div className=&quot;root&quot;&gt;
      &lt;div className=&quot;selectedValue&quot;&gt; {selectedValue.name} &lt;/div&gt;
      {options.map((option) =&gt; (
              &lt;Option name={option.name} value={option.value} onClick={onClickOption(option)}/&gt;  
      ))}
    &lt;/div&gt;
  );
}
</code></pre>
<p>上面的程式碼範例只是一個示意，所以並沒有考慮到 CSS 的樣式，這邊會以狀態的傳遞方式為重點。所以以這個下拉選單的例子來說，我們會把整個選單的名字跟對應的數值，直接傳入這個 <code>&lt;Select/&gt;</code>  元件裡面。</p>
<pre><code>const optionList = [
    { name: &quot;optionA&quot;, value: &quot;valueA&quot; },
    { name: &quot;optionB&quot;, value: &quot;valueB&quot; }
  ];

...

&lt;Select options={optionList} /&gt;
</code></pre>
<p>但是這麼一來除了沒辦法直接存取到 <code>&lt;Option/&gt;</code> 元件之外，你也可以發現這份相關的選單資料其實是從最上層傳入 <code>&lt;Select/&gt;</code> 元件之後，再次被傳入 <code>&lt;Option/&gt;</code>，<code>&lt;Option&gt;</code> 這個元件才有辦法拿到需要用來顯示的選項內容與對應數值。</p>
<p>一般我們不會樂見這種資料被層層傳遞的使用方式，你可能覺得兩層可能還好，不會太難看出它們的關係，但在實際開發時總是無法永遠確保不會有需要第三層的情況出現，因此雖然難免還是有些不得已必須這麼使用的情況，大多時候對開發者來說這種情況當然是越少越好。<strong>你可以想像使用這個用法製作的元件，在當所必須傳入的屬性隨著時間和需求的改變而變得太多時，它會變得越來越難看清楚每個屬性所對應的內容</strong>，和與之相關的流程邏輯。</p>
<p>對上面的 <code>&lt;Select/&gt;</code>  元件來說，也許一個比較好的設計方式最好還是能夠跟原生的 select 與 option 標籤具有同樣的使用方式：</p>
<pre><code>&lt;select&gt;
  &lt;option value=&quot;value1&quot;&gt;optionA&lt;/option&gt;
  &lt;option value=&quot;value2&quot;&gt;optionB&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>當我們把 <code>&lt;Select/&gt;</code> 元件用某種方式拆分成兩個個別獨立，且相關連的元件之後，就能夠享有一個好處是能夠把元件的樣式內容分開來管理，也就是說我們在設計元件時不需要把所有的程式碼塞在一起。而除了讓內容分離之外，<strong>使用複合元件的另外一個很大的好處是能夠讓狀態在這兩個相關連的元件之間共享</strong>，這麼一來也可以減少把狀態「傳到上層在傳到下層」的情況發生。</p>
<h2 id="複合元件的好處"><a class="header-anchor" href="#複合元件的好處"></a>複合元件的好處</h2>
<p>綜上所述，由於複合元件原本就是為了讓元件之間的相依，並提高使用彈性的方法。所以他所帶來的好處也不難理解：</p>
<ul>
<li>讓開發者能夠更容易且隨心所欲控制元件，例如：元件的排列順序。</li>
<li>讓相關元件扁平化，可以使用在同一層而不用全部包在一個地方。</li>
<li>元件內容分離，讓元件更容易管理，就像我們即將要做的：把上面原本的 <code>&lt;Select/&gt;</code> ，拆出 <code>&lt;Option/&gt;</code> ，分離成兩個元件。</li>
</ul>
<h2 id="以-select-為例子來設計複合元件"><a class="header-anchor" href="#以-select-為例子來設計複合元件"></a>以 <code>&lt;Select/&gt;</code> 為例子來設計複合元件</h2>
<p>下拉選單是前端一個很常見的需求，尤其我們因為樣式的關係，無法使用原生的 Html 元素，所以常常需要客製化的製作。這邊我們就來看看怎麼利用 React 來設計一個跟前端原生的 <code>&lt;select&gt;</code> 元素使用方式較為相近的元件吧！在這個例子裡面，我會以 Class Component 為基礎來進行設計。</p>
<h2 id="元件的條件要求："><a class="header-anchor" href="#元件的條件要求："></a>元件的條件要求：</h2>
<ul>
<li><code>&lt;Select&gt;</code> 與 <code>&lt;Option&gt;</code> 兩個元件必須要能夠分開使用而不是全部放在同一個元件中，像是這樣：</li>
</ul>
<pre><code>      &lt;Select&gt;
        &lt;Option value=&quot;value 1&quot; &gt;
          option 1
        &lt;/Option&gt;
        &lt;Option value=&quot;value 2&quot; &gt;
          option 2
        &lt;/Option&gt;
        &lt;Option value=&quot;value 3&quot; &gt;
          option 3
        &lt;/Option&gt;
      &lt;/Select&gt;
</code></pre>
<ul>
<li><code>&lt;Select/&gt;</code> 必須能夠根據其子元素的所有  <code>&lt;Option/&gt;</code>   元件內容以及排列順序來顯示下拉清單</li>
<li>元件的製作結果如下：</li>
</ul>
<img src="/2021/04/03/react-compound-component/select-result.gif" title="compound-component-result"> 
<h2 id="先思考元件結構"><a class="header-anchor" href="#先思考元件結構"></a>先思考元件結構</h2>
<p>通常複合元件中，會有一個作為父層元件的主元件，而由其他的元件作為子元件。不過在 <code>&lt;Select/&gt;</code> 與 <code>&lt;Option/&gt;</code> 的例子中則比較單純，只有父層的 <code>&lt;Select/&gt;</code> 與子層的 <code>&lt;Option/&gt;</code>。以這個架構為前提之下，我們可以繼續往下想想另外幾個問題，那就是：</p>
<ul>
<li>作為父層元件的 <code>&lt;Select/&gt;</code> 是怎麼知道在它下層的 <code>&lt;Option/&gt;</code> 的內容的？</li>
<li><code>&lt;Select/&gt;</code> 又是怎麼比對出當下使用者所選到的選項的？</li>
</ul>
<p>只要能夠解答這兩個問題，我們基本上就掌握了實作這個 <code>&lt;Select/&gt;</code> 複合元件的關鍵。</p>
<p>首先，第一個問題的思考方向是一個很常見的 children 屬性，我們只要透過這個屬性就能夠取得「被放入」元件的內容，也就是所有的 <code>&lt;Option/&gt;</code> 元件。而關於 <code>&lt;Select/&gt;</code> 是怎麼知道目前所選的數值的？可想而知的是在 <code>&lt;Select/&gt;</code> 內一定會有一個狀態負責儲存目前被選中的值。</p>
<p>另外我們再每個 <code>&lt;Option/&gt;</code> 被選中時也必須進行更新這個被選中數值的動作，所以我們也需要在 Option 元件上面掛上對應的 onClick  事件，這麼一來當 <code>&lt;Option&gt;</code> 被點擊時，<code>&lt;Select/&gt;</code> 才有辦法知道 <code>&lt;Option/&gt;</code>  選中的數值是哪一個。關於這一點我們可以透過 React 的相關 API ： Children.map  以及 cloneElement 來達成。Children.map 負責巡訪每個 <code>&lt;Option/&gt;</code> 子元件 ， cloneElement 則複製一個新的 Option 並讓我們可以在這個時候再次傳入額外的屬性。</p>
<pre><code>// ... 在 Select 元件內
// 選項表單
 &lt;div className=&quot;optionList&quot;&gt;
              {Children.map(children, (child) =&gt;
                React.cloneElement(child, {
                  ...child.props,
                  onClick: this.onOptionClick(child),
                                 })
              )}
&lt;/div&gt;
</code></pre>
<p>藉由上述的程式碼片段可以看出我把個別的子元件內容傳給了 onClick 事件，接下來在事件裡面只要知道要儲存什麼數值藉以比對選中的選項，並拿到元件上對應的屬性值，就能夠透過這個數值進行比對。</p>
<pre><code>// ... 在 Select 元件內
// Select 元件的狀態 
...
state = {
    selectedOptionKey: &quot;&quot;,
    selectedOptionValue: &quot;&quot;,
    selectedOption: null,
    openOptionList: false
};

...

// Option 上的點擊事件
onOptionClick = (child) =&gt; () =&gt; {
    const {
      props: { value, optionKey }
    } = child;
    this.setSelectedOptionKey(optionKey);
    this.setSelectedOptionValue(value);
    this.setState({ selectedOption: child });
    this.toggleOptionList();
};
</code></pre>
<p>在點擊事件內雖然我做了許多件事情，不過可以看到我從 child 的 props （也就是 <code>&lt;Option/&gt;</code> 上的屬性內容）取出兩個屬性值，分別為 value 以及 optionKey，其中 optionKey 是每個 <code>&lt;Option/&gt;</code> 上都會有，用來區別選項且應該要不重複的值，之後我們就可以拿這個值來決定目前所選中的選項是哪一個。</p>
<p>比對的方式很單純，既然我們可以拿到 <code>&lt;Option/&gt;</code> 上的屬性，我們就能夠拿出來跟儲存在 <code>&lt;Select/&gt;</code> 代表被選中的 <code>&lt;Option/&gt;</code> 的 selectedOptionKey 這個狀態做比對，如下：</p>
<pre><code>// ... 在 Select 元件內
// 選項表單
 &lt;div className=&quot;optionList&quot;&gt;
              {Children.map(children, (child) =&gt;
                React.cloneElement(child, {
                  ...child.props,
                  onClick: this.onOptionClick(child),
                  isSelected:
                    child.props.optionKey === this.state.selectedOptionKey
                                 })
              )}
&lt;/div&gt;
</code></pre>
<p>我們直接利用 isSelected 以布林值傳給下層的 <code>&lt;Option/&gt;</code> ，這麼一來 <code>&lt;Option/&gt;</code> 就能夠透過這個數值決定要顯示什麼樣的內容，或是樣式，我們來看看 <code>&lt;Option/&gt;</code> 的內容。</p>
<pre><code>// Option 元件

function ClassOption({ children, isSelected, onClick }) {
  return (
    &lt;div
      onClick={onClick}
      className={`option ${isSelected ? &quot;isSelected&quot; : &quot;&quot;}`}
    &gt;
      {children}
    &lt;/div&gt;
  );
}
</code></pre>
<p>由於這個例子中 <code>&lt;Option/&gt;</code> 需要顯示的東西和需要判斷的邏輯比較單純，所以元件內容也比較單純，但可以看到我們拿到從 <code>&lt;Select/&gt;</code> 元件裡面傳入的兩個屬性來做一些顯示和判斷，這兩個屬性都不是在使用元件時傳入的，而是從 Select 元件來，所以如果不了解原理的話，就沒辦法直接看出來處。</p>
<h2 id="利用-class-compoennt-靜態屬性"><a class="header-anchor" href="#利用-class-compoennt-靜態屬性"></a>利用 Class Compoennt 靜態屬性</h2>
<p>通常複合元件在設計時會把複合元件中的子元件掛在父元件上，而因為在本篇文章所舉的例子裡面，剛好用到的是 Class Component ，所以可以利用靜態屬性的概念，讓兩個看似分離的元件，更明確的產生關聯，所以我們在 <code>&lt;Select/&gt;</code> 元件內會多做一件事情：</p>
<pre><code>// Select 元件內
static Option = ClassOption;
</code></pre>
<h2 id="善用-context-api"><a class="header-anchor" href="#善用-context-api"></a>善用 Context API</h2>
<p>雖然在這個例子裡面我們沒有使用到，不過若是想要設計的複合元件結構比較複雜，有多層元件結構的話，可以利用 React 提供的 Context API 來進行跨多層元件的數值內容傳遞。</p>
<pre><code>// Select 元件
&lt;SelectContext.Provider value={{ [ 想要傳遞的數值內容 ]  }}&gt;
//  ... 元件內容
&lt;SelectContext.Provider&gt;
</code></pre>
<h2 id="最終完成的結果"><a class="header-anchor" href="#最終完成的結果"></a>最終完成的結果</h2>
<p>在上面的內容之中我只解說幾個最關鍵的部分，至於沒有講到的其他細節，就請讀者自己思考看看囉，在這邊附上完整的程式碼範例。</p>
 <iframe src="https://codesandbox.io/embed/compound-compoennt-selectoption-u1x4w?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fcomponents%2FClassSelect%2Findex.js&theme=dark&view=editor"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="Compound Compoennt - Select/Option"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
<h2 id="動手試試看"><a class="header-anchor" href="#動手試試看"></a>動手試試看</h2>
<p>本篇文章的是以 Class Component 為例子來進行設計這個複合元件，不過在撰寫這篇文章的此刻，Functional Component 是實際開發時比較主流的元件類型，其實利用 Functional Component 照理說也能夠設計出使用方式與這個例子完全一樣的複合元件，讀者們在了解複合元件的概念後，也可以自己嘗試使用 Functional Component 來實做看看自己的複合元件，那麼，就先說到這囉！</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2020/09/06/working-reward/" class="image is-7by1">
            <img class="thumbnail" src="/thumbnails/reward-cover.JPG" alt="每個衝擊都是一次學習的機會 - 近期的一點心得">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-09-06T09:36:53.000Z">2020-09-06</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/走在漫漫長路-工作心得/">走在漫漫長路 - 工作心得</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16 分鐘 閱讀文 (大約 2440 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/09/06/working-reward/">每個衝擊都是一次學習的機會 - 近期的一點心得</a>
            
        </h1>
        <div class="content">
            <p>好久不見。各位最近過得如何呢 ? 是不是又往自己的目標前進了一點 ? 一段時間沒有寫文章了，由於轉換工作環境的緣故，自從三月以來，這是第一次可以空出時間好好寫下一些東西。</p>
<p>我目前在 Snapask 任職，這是我第一次到比較有規模的團隊裡面，有很多專案流程的細節是以前沒有接觸過的，所以這幾個月來相對於技術學習上。我在思考方式以及工作方法等方面比較有心得，所以這篇文章不會有技術內容，而是會跟大家分享我近期的收穫，或許能夠給未來也跟我面臨相似問題的人一個參考。</p>
<blockquote>
<p>目前我的公司剛好有一個 Web Team 的職缺，<a href="https://www.cakeresume.com/companies/snapask-taiwan-limited/jobs/web-engineer-2717a1?locale=en">JD 在這</a>，如果有興趣的人歡迎找我聊聊，或許可以幫你評估一下狀況然後幫你 Refer ，加快面試流程，你可以透過以下方式找到我：</p>
<ul>
<li>Facebook: <a href="https://www.facebook.com/mujing/">https://www.facebook.com/mujing/</a></li>
<li>Gmail: <a href="mailto:moojitsai@gmail.com">moojitsai@gmail.com</a></li>
</ul>
</blockquote>
<h2 id="個人過往技術狀況"><a class="header-anchor" href="#個人過往技術狀況"></a>個人過往技術狀況</h2>
<p>有一些經驗的 Junior，靠自學誤打誤撞進入前端領域（剛滿兩年），前面經歷的都算是較小型的新創，團隊大多都不超過十人。當時工作較為偏向單打獨鬥，內容較有彈性，技術工具及解決方法策略的選擇上相對自由，可以自行決定然後直接執行，但時程規劃比較沒有組織跟流程。</p>
<h2 id="參與新的團隊"><a class="header-anchor" href="#參與新的團隊"></a>參與新的團隊</h2>
<p>因為以前合作經驗較少，所以第一次進到團隊，有很多新的工作方法以前沒有參與跟執行過，例如大家認為很常見的 Code Review 、例如跟主管們 1 on 1 、還有 scrum 中的會議流程…，其實有許多細節。</p>
<p>不過因為實際會遇到的工作細節每間公司一定都會不同，所以在接下來的內容我不會一一詳細的解說，我會以個人成長的角度來分享在這個新環境中學到、並為我在職涯發展上帶來不同見解的觀點。</p>
<p>從就職開始說起，那些剛到職的 Junior 們可能聽說過很多次，不過我可以再用我的個人經驗告訴你，永遠不要「只」以薪水來決定工作的選擇（當然該拿的還是要拿，不過如果你真的很想體驗一整年都沒有成長的倦怠感，那麼你應該試試）。</p>
<h2 id="進入新環境的第一要務"><a class="header-anchor" href="#進入新環境的第一要務"></a>進入新環境的第一要務</h2>
<p>我想對大部分的 Junior 來說，進入公司後最重要的一件事就是優先找到能夠讓你學習並成長的對象 （ Mentor / Role Model )，這長期來講會是一個重要的外在因素，不用擔心找不到，每個人都有值得學習的部分，但如果你觀察幾個月之後還是沒有答案，那麼你可能到錯地方了。</p>
<h2 id="適應之後"><a class="header-anchor" href="#適應之後"></a>適應之後</h2>
<p>工作一段時間差不多適應新的環境以後，可能會有兩種情況，一種是工作模式跟以前所習慣的差不多，一種是跟我比較像也就是公司的工作流程跟以往使用的有比較大的差距。不管是在哪一種情況底下，在這個時期都應該要著重於一件事情：</p>
<blockquote>
<p>找到你想做的事 / 想解決的問題</p>
</blockquote>
<p>不要把自己當勞工來看，找到一個你想達成的長期目標，通常這個目標不會是被分派的任務之一，因為你會有自己的目標，公司也會有自己的步伐要前進，想辦法找到這兩者間的平衡點。這會回到一個問題是你當初選擇這間公司的原因、或是說你想在這間公司想得獲得的經驗、講官腔一點也能說是未來展望。相較於上面提到的外在因素，這則會是長期的內在動機，也是遇到阻礙時能夠支撐你的重要原因。</p>
<p>對那些適應良好的人這件事可能會自然地發生。即使是對不太能適應或遇到麻煩的人，若你有確保做好第一點提到的確保工作環境有學習對象，那麼你應該能夠得到一些引導而在設法解決後再度回來思考這個問題。</p>
<h2 id="我獲得的幾個觀點"><a class="header-anchor" href="#我獲得的幾個觀點"></a>我獲得的幾個觀點</h2>
<h3 id="1-看見每個人價值觀的不同"><a class="header-anchor" href="#1-看見每個人價值觀的不同"></a>1. 看見每個人價值觀的不同</h3>
<p>在中小型團隊裡面會遇到許多不同的人，幾個月的合作跟交流下來我可以明顯感受到每個人都有每個人的做事方法跟步調，這是一個很棒的地方，因為每個人都有能夠學習的地方，試試看跟他們交流你的想法，常常能夠讓你從不同角度重新看帶事情。</p>
<h3 id="2-先想清楚-再動刀"><a class="header-anchor" href="#2-先想清楚-再動刀"></a>2. 先想清楚，再動刀</h3>
<p>這一點，講老套一點就是三思而後行，在執行某個任務之前應該先在腦中演練過要執行的細節，這個 pattern 不只是工程師的基本能力，生活中很多地方都能夠應用。也避免邊做邊想讓自己遭遇一團混亂的處境。<br>
以我的經驗來說，在以往的工作經驗裡面我都可以快速執行想做的方法然後遇到問題再快速設法解決，但在注重工作流程的公司這麼做就很容易遇到狀況。</p>
<h3 id="３-不斷尋找工作流程上能夠改善的地方"><a class="header-anchor" href="#３-不斷尋找工作流程上能夠改善的地方"></a>３. 不斷尋找工作流程上能夠改善的地方</h3>
<p>這不管對哪一個階段的工作者都很重要，但我相信對初出茅廬的 Junior 工程師來說尤然。每個人在執行上都會有盲點，對較為資深的工程師來說這些盲點可能不會是個大問題，但對資淺工程師來說的話，一旦某個環節碰到問題，通常就會讓他們立刻明顯的感受到阻礙。</p>
<h3 id="4-使用新工具：蕃茄鐘"><a class="header-anchor" href="#4-使用新工具：蕃茄鐘"></a>4. 使用新工具：蕃茄鐘</h3>
<p>這一段呼應上一點，我是一個非常容易分心的人，因為我對許多身邊發生的事感到好奇，我相信這是我的優點。不過這個特點對於完成任務來說反而是一個問題。我知道我需要建立一個能夠讓自己專心的工作模式，試了很多方式後決定開始試試看使用蕃茄鐘，沒想到一試成主顧。</p>
<p>基本上蕃茄鐘就是讓自己專心時間後，再放鬆一小段時間，然後持續進行這個循環。對我來說感受比較明顯的地方有：</p>
<ul>
<li><strong>明確感到時間的流逝</strong>：<br>
也就是增強對時間的感知，以往因為較長時間的連續執行工作，有時候容易造成正在做的事情已經偏離最一開始想要達成的目標，但自己還沒有察覺，在番茄鐘的工作法底下比較能夠知道目前正在做的某件事情已經花掉多少時間。</li>
<li><strong>比較能夠把一件大任務切成許多小部分</strong>：<br>
因為蕃茄鐘的這種模式，所以在使用時自然必須學著切分任務，再開始進行之前先想好這段時間要做什麼事情，並在結束後來看看自己的成效。</li>
<li><strong>適度讓大腦休息</strong>：<br>
長時間的連續工作真的比較容易遇到盲點，例如有時候遇到某個問題解不掉，然後又執著在錯誤的程式碼環節，就容易卡住很長一段時間，但往往休息一段時間後再回來，不就後就能找到癥結點。</li>
</ul>
<h3 id="勾勒自己的未來"><a class="header-anchor" href="#勾勒自己的未來"></a>勾勒自己的未來</h3>
<p>以上就是我近期的心得，寫在最後面，有一件應該要常常被思考的事情是去設想自己在近幾年之後在工作領域裡的角色定位，你想要有能力做到什麼樣的事情？解決什麼樣的問題？這些都是最基本卻又很容易被忽略的事情。</p>
<p>畢竟在這個工程師這個行業裡頭，技術是學不完的，但你的時間卻非常有限。不知道這些經驗能夠幫助你到什麼地步，不過還是希望你能夠有所收穫，不用免強自己做個鐵人、也不要甘於當個水手，做個靈活的海盜，適當利用環境、武器跟手邊的資源，該守就守，該進攻進攻，容許自己能夠時時刻刻調整航向跟目的地。如果將來我們能夠在航道上相遇，那麼希望我能夠ㄧ如往常地帶給你一些新奇的東西與驚喜。就寫到這，下次又等到我有空時再見了！</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2020/03/09/working-environment/" class="image is-7by1">
            <img class="thumbnail" src="/thumbnails/work-life.jpg" alt="寫給職場工作者：工作環境是否會影響一個人的思考方式？">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-08T20:54:46.000Z">2020-03-09</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/走在漫漫長路-工作心得/">走在漫漫長路 - 工作心得</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 分鐘 閱讀文 (大約 1669 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/09/working-environment/">寫給職場工作者：工作環境是否會影響一個人的思考方式？</a>
            
        </h1>
        <div class="content">
            <p>自從我進入大學階段之後，就一直有人不斷對我說要快一點決定未來人生的方向，每次被問到這個問題我都不是很能理解，<em>這個在前面將近一半的學習生涯把學生教成考試機器的教育體系，為何又理直氣壯地期望這些學生在短短幾年內如獲天啓般突然知道自己的人生規劃？</em></p>
<p>綜上所述，我目前是一位軟體工程師，今年是我工作的第三年，我依舊在思考人生目標，但值得慶幸的是我正在做自己喜歡的工作（而且我學很快）。雖然對未來職涯方向還沒有很清楚的藍圖，但是對於這幾年來在職場體驗到所發生的人事物依舊有一些心得，所以今天想來跟各位聊聊（個人角度下）工作本身對工作者的長期影響。</p>
<h2 id="職場制約論"><a class="header-anchor" href="#職場制約論"></a>職場制約論</h2>
<p>我相信大家應該都了解「環境很重要」這件事，以一個在台灣常見的上班族來說，光是工作的時間每天就有八小時（以上），仔細想想就佔了一個社會人士的人生將近 1/3 的時間，我們往往沒有意識到，這段時間裡面我們所做的事情、交流的對象、交談的方式在長久以來在不斷重複經歷之下，深植在腦海中。</p>
<p>我們可以用行為心理學裡「操作制約」來看待職場環境，操作制約的核心概念是根據行為產生的後果，會影響個體後續再重複相同行為的可能性。在操作制約裡有所謂的「增強」與「懲罰」，「增強」指的是個體喜愛、想要的事物，「懲罰」則反之。<strong>在個體做了某種行為後透過增強，給予想要的獎勵；或透過懲罰，施予不想要的刺激，來影響個體</strong>（實際上行為心理學對操作制約有更詳細的分類跟探討，這邊因為篇幅關係無法做太詳盡的說明）。</p>
<p>如果你已經工作一段時間應該會有所體悟，常常甚至不需要主動學習，剛進入職場後就會有人來告訴你可以這樣做不可以那樣做、什麼時候要做什麼否則就會大難臨頭等等那些所謂職場的淺規則或「不成文的規定」，到頭來我們甚至不會去思考為什麼要樹立這些莫名的規章。</p>
<h2 id="當音樂課只剩下畫答案卡的聲音"><a class="header-anchor" href="#當音樂課只剩下畫答案卡的聲音"></a>當音樂課只剩下畫答案卡的聲音</h2>
<p>時間拉回更早更早——或許進入職場前我們早就是這樣學習跟成長的，還記得國小的時候學校的「嘉獎」、老師打的「甲上上上上上 / 特優」、「小過」、「大過」，現在回想起來真的很沒有意義 ——但當時我們又怎麼會意識到呢？<strong>當社團時間只剩下自習、當我們的音樂課只剩下畫答案卡的聲音，也許在熱衷於那些無聊大人訂下的守規矩遊戲時，我們的青春就這樣被被惡狠狠地蓋上了合格認證。</strong></p>
<p>十幾年過去，開始工作、進入社會後，這樣的情況似乎一點也沒有減少。無聊的大人們養出另一世代壞掉的大人（ 誰知道呢，也許我才是壞掉的那一邊? ），許多人自以為當上老闆就擁有對別人所有的控制權，慣老闆的八卦早就不算新聞、另一部分人成了訓練有素的職場玩家，想盡辦法奉承巴結上司、深諳遊戲規則的這些人，教會了社會新鮮人「是非對錯」，也間接增強了這種盲目尊崇權威的社會結構，即使是在寫這篇文章的當下，台灣社會裡也許也還充斥著這樣的的公司職場環境。</p>
<h2 id="盲目地追求高薪是一種慢性病"><a class="header-anchor" href="#盲目地追求高薪是一種慢性病"></a>盲目地追求高薪是一種慢性病</h2>
<p>現在在台灣，軟體工程師似乎已經成為一種趨勢，許多人一窩蜂投入軟體產業、補習板根線上課程處處林立，但我總覺得許多這樣做的人再做決定之前都沒有思考過這樣的決定是否真的適合自己、或是跟價值觀是否相符。在這樣的情況下，即使後來這些人進入軟體產業，成功成為軟體工程師，終究還是會因為得不到成就感而無法堅持下去。</p>
<pre><code>「知道方法的人會去工作，而知道這個人為什麼要工作的人，就會成為他的老闆」 - &lt;狼與辛香料&gt;
</code></pre>
<p>不管在看這篇文章的你是誰，相信我，就算你是工作者、就算很多人告訴你要找一份穩定的工作、過一個安穩的生活，你永遠都有選擇權。打開選擇權，在職場裡面若發現自己意識到思考的不對勁，就思考看看你是否適合現在的環境、你跟每天相處的同事是否是同一類型的人？</p>
<p>不要勉強自己，你可以選擇一份安穩的生活，也可以選擇踏上尋找個人定位的旅程  — — 即使身邊願意這麼做的人寥寥無幾。而有時候你需要的只是多一點思考。</p>
<h2 id="所以呢？"><a class="header-anchor" href="#所以呢？"></a>所以呢？</h2>
<p>所以關於今天問題的結論，我會說職場環境所帶來的負面影響對那些了解自己、清楚人生目標的人們是不會有作用的。所以就算現在職場上依舊有許多我們看不慣的陋習，只要願意花時間思考什麼才是最重要的，也許在了解到工<strong>作不過是追求個人目標過程中的一種手段後</strong>，那些淺規則在你眼中就會變得渺小且微不足道了。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2020/03/07/web-dnd-2/" class="image is-7by1">
            <img class="thumbnail" src="/thumbnails/DragnDrop.jpg" alt="就是要一起拖拖拉拉！(二) - 利用 DataTransfer API 實作拖拉元素間的資料傳遞">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-07T08:39:14.000Z">2020-03-07</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 分鐘 閱讀文 (大約 876 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/07/web-dnd-2/">就是要一起拖拖拉拉！(二) - 利用 DataTransfer API 實作拖拉元素間的資料傳遞</a>
            
        </h1>
        <div class="content">
            <p>上週提到了瀏覽器拖拉時會陸續觸發的幾個事件，我們知道了對可拖曳物件 (draggable) 進行拖曳與放開時以及拖曳物件滑過目標物件上方時，都會觸發對應的事件。今天我想研究看看在事件與事件之間可以做什麼事情，瀏覽器提供了 DragEvent 這個 API ，讓我們可以在開始拖曳時夾帶資料，並在拖曳結束放開時取得該筆資料。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>DataTransfer  物件</li>
<li>實際應用 DataTransfer API</li>
</ul>
<h2 id="datatransfer-物件"><a class="header-anchor" href="#datatransfer-物件"></a>DataTransfer  物件</h2>
<p>上次有提到在瀏覽器操作中的拖曳功能，必須要自己搭配事件處理來實作，但其實有一些拖曳行為是預設就是有效，像是網頁連結和圖片的拖曳，以及文字選取的拖曳（反白）。而在這些以外的元素如果要觸發拖曳就必須使用 <code>draggable</code> 屬性來達成。</p>
<p>而在拖放事件的最一開始， <code>ondragstart</code> 事件被觸發時，我們其實可以利用事件物件（也就是事件回呼函式內的第一個參數 <code>event</code> ) 裡面的 <code>dataTransfer</code> 物件來賦予被拖放物件想要挾帶的資料，使用方式如下：</p>
<pre><code>let dragger = document.querySelectAll('#dragger') 

dragger.addEventListener(&quot;dragstart&quot;,function(e){
	e.dataTransfer.setData('text/plain', 'This text   may be dragged')
})
</code></pre>
<h3 id="datatransfer-setdata"><a class="header-anchor" href="#datatransfer-setdata"></a>dataTransfer.setData</h3>
<p><code>dataTransfer</code> 物件負責處理拖曳行為之間的資料傳輸，這個物件裡面有兩個方法，分別是 <code>setData</code> 與 <code>getData</code> ， <code>setData</code> 使用方式如下：</p>
<pre><code>dataTransfer.setData(format, data); 
</code></pre>
<p>這個 API 有兩個參數，分別是：</p>
<ul>
<li>format ：想要挾帶的資料格式，使用的是網頁常見的 MIME 格式字串，如文字格式就是 <code>text/plain</code> ，關於 MIME 型別可以參考 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types">MDN 說明</a>。</li>
<li>data : 想要挾帶的資料</li>
</ul>
<h3 id="datatransfer-getdata"><a class="header-anchor" href="#datatransfer-getdata"></a>dataTransfer.getData</h3>
<p>而在拖曳行為結束觸發 <code>drop</code> 事件時，則可以反過來利用 <code>dataTransfer.getData</code> 來取得前面挾帶的資料。</p>
<pre><code>dataTransfer.getData(format); 
</code></pre>
<p>記得必須透過同樣的格式字串來取得同一個參數。</p>
<h3 id="datatransfer-types"><a class="header-anchor" href="#datatransfer-types"></a>DataTransfer.types</h3>
<p>回傳在 ondragstart 時透過 setData API 所設定資料的資料格式，因為可能不會只設定一種格式的資料，所以會以陣列的方式來表示。</p>
<h2 id="實際應用-datatransfer-api"><a class="header-anchor" href="#實際應用-datatransfer-api"></a>實際應用 Datatransfer API</h2>
<p>接下來我們就試試看根據上面的說明，如何應用到實際的拖拉操作流程上，修改上次的範例來做說明，先做一個輸入框來設定拖曳時想要挾帶的數值。</p>
<pre><code>let dragDataInput = document.querySelector('#dragDataInput')

&lt;div class=&quot;row align-items-center&quot;&gt;
    &lt;div class=&quot;col-2 d-flex align-items-center&quot;&gt;
            &lt;p class=&quot;m-0&quot;&gt;輸入想要挾帶的資料:&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-10&quot;&gt;

      &lt;input type=&quot;text&quot; id=&quot;dragDataInput&quot; class=&quot;form-control&quot;&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
  <img src="/2020/03/07/web-dnd-2/draginput.png" title="draginput">
<p>之後在原本的 <code>dragststart</code> 事件處理裡面，利用 dataTransfer 設定夾帶資料，這邊資料的格式就用字串做表示。</p>
<pre><code>dragger.addEventListener(&quot;dragstart&quot;,function(e){
   dragTemp = e.target
  e.dataTransfer.setData('text/plain', dragDataInput.value)
})
</code></pre>
  <img src="/2020/03/07/web-dnd-2/enterData.png" title="enterData">
<p>後面一樣在 <code>drop</code> 事件就能夠透過 <code>e.dataTransfer.setData</code> 收到前面設定的資料了，我把它掛到拖曳完成的元素上。</p>
<pre><code>dropper.addEventListener(&quot;drop&quot;,function(e){
	...
  let dragText = e.dataTransfer.getData('text/plain') 
  dragTemp.append(dragText)
  e.target.style.color=&quot;#fff&quot;
	...
})
</code></pre>
<img src="/2020/03/07/web-dnd-2/drop-finish.png" title="drop-finish">
<p>完整範例可以在<a href="https://codepen.io/monotrack/pen/eYNeNOr?editors=1010">這裡</a>看到。</p>
<h2 id="參考文章"><a class="header-anchor" href="#參考文章"></a>參考文章</h2>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/HTML_Drag_and_Drop_API">https://developer.mozilla.org/zh-TW/docs/Web/API/HTML_Drag_and_Drop_API</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2020/02/28/web-dnd-1/" class="image is-7by1">
            <img class="thumbnail" src="/thumbnails/DragnDrop.jpg" alt="就是要一起拖拖拉拉！(一) - 瀏覽器 Drag and Drop API 操作">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-28T02:04:03.000Z">2020-02-28</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 分鐘 閱讀文 (大約 2197 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/28/web-dnd-1/">就是要一起拖拖拉拉！(一) - 瀏覽器 Drag and Drop API 操作</a>
            
        </h1>
        <div class="content">
            <p>Drag and Drop 在一些網頁產品裡面算是蠻常見的應用，使用起來的效果也常常讓人印相深刻，在像是 Trello、Asana、Cakeresume 等需要進行一些計畫安排或是畫面規劃等互動性較強的工具，都會看到它的蹤影，由於之前的工作內容剛好都沒有機會碰到，最近又剛好想要研究，今天就讓我們一起來研究相關的 API 吧。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>基本概念</li>
<li>宣告 draggable 與 droppable 元素</li>
<li>可拖曳 (Draggble) 元素上的事件</li>
<li>可拖曳 (Droppable) 元素上的事件</li>
<li>實作 Drag and Drop 範例</li>
<li>總結</li>
<li>參考資料</li>
</ul>
<h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2>
<p>瀏覽器的拖拉功能基本上是由一連串的事件觸發而組成。在要被拖拉的元素上要先以 <code>draggable</code>的 屬性宣告，告訴瀏覽器這個元素是可以被拖移的，而在能夠放下拖拉元素的另外一個元素，相對的也必須以 <code>dropabble</code> 屬性宣告，才能夠接收拖移過來的元素內容。</p>
<img src="/2020/02/28/web-dnd-1/Drag_n_Drop.jpg" title="Drag_n_Drop">
<p>而這一連串拖移的動作又可以拆分為幾個發生的時間段，說到這裡，對瀏覽器比較有概念的人應該可以猜到了。沒錯，這些時間段在瀏覽器內都是一個對應會被觸發的事件 (以下使用 Camelcase 做表示）：</p>
<ul>
<li>開始拖移 (onDragStart)</li>
<li>拖移中 (onDrag)</li>
<li>拖移進入某個元素 (onDragEnter)</li>
<li>拖移經過某個某個元素 (onDragOver)</li>
<li>拖移離開某個元素 (onDragLeave)</li>
<li>結束拖移 (onDragOver)</li>
</ul>
<p>而拖拉期間與元素互動的方式，將會由開發者利用這些事件觸發來決定，詳細可以參考 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API">MDN 官方網站</a>，接下來會試著實作出基本拖放功能範例，以此說明一些常用到的拖拉事件觸發是如何發生。</p>
<h2 id="宣告-draggable-與-droppable-元素"><a class="header-anchor" href="#宣告-draggable-與-droppable-元素"></a>宣告 draggable 與 droppable 元素</h2>
<p>首先我們要先做出一個可拖曳的跟可放置的元素。分別在兩個素上將 <code>draggable</code> 屬性與 <code>dropabble</code> 屬性宣告為 <code>true</code> （這個專案使用 Bootstrap 作為輔助，後面會有範例）。</p>
<pre><code>&lt;div class=&quot;container&quot;&gt; 
  &lt;div class=&quot;row justify-content-center&quot;&gt; 
    &lt;div draggable=&quot;true&quot; class=&quot; box box-dragger&quot;&gt;&lt;/div&gt;
    &lt;div droppable=&quot;true&quot; class=&quot;box box-dropper&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>之後，我們來看看上述提到的每個事件代表的意義與被觸發的時機，才能在實作時知道什麼時候該用什麼事件來搭配完成功能。</p>
<h2 id="可拖曳-draggble-元素上的事件"><a class="header-anchor" href="#可拖曳-draggble-元素上的事件"></a>可拖曳 (Draggble) 元素上的事件</h2>
<h3 id="dragstart-事件"><a class="header-anchor" href="#dragstart-事件"></a>DragStart 事件</h3>
<p>這個事件只會在被拖曳元素<strong>剛開始被拖曳時</strong>被觸發一次，我們可以試著在  <code>.box-dragger</code> 元素上宣告 <code>dragstart</code> 的事件監聽，接著就可以試著拖曳看看。</p>
<pre><code>dragger.addEventListener(&quot;dragstart&quot;,function(){
 console.log(&quot;drag start!!!!&quot;)   
})
</code></pre>
<h3 id="dragend-事件"><a class="header-anchor" href="#dragend-事件"></a>DragEnd 事件</h3>
<p><code>dragend</code> 事件會在<strong>拖曳結束時</strong>被觸發，應該很好理解，利用以下的程式碼片段：</p>
<pre><code>dragger.addEventListener(&quot;dragend&quot;,function(){
 console.log(&quot;drag end!!!!&quot;)   
})
</code></pre>
<p>之後試著拖曳 <code>.box-dragger</code> 元素後再放開就可以看到上述的事件被觸發。</p>
<h3 id="drag-事件"><a class="header-anchor" href="#drag-事件"></a>Drag 事件</h3>
<p><code>drag</code> 事件會在可以拖曳元素<strong>被拖曳期間持續</strong>被觸發：</p>
<pre><code>dragger.addEventListener(&quot;drag&quot;,function(){
 console.log(&quot;draging!!&quot;)   
})
</code></pre>
<p>可以看見一如上面說的 <code>dragstart</code> 事件只會被觸發一次，而 <code>drag</code> 事件會在拖曳期間持續被觸發。</p>
<img src="/2020/02/28/web-dnd-1/dragging.png" title="dragging">
<h2 id="可放置-droppable-元素上的事件"><a class="header-anchor" href="#可放置-droppable-元素上的事件"></a>可放置 (Droppable) 元素上的事件</h2>
<h3 id="dragenter-dragleave-事件"><a class="header-anchor" href="#dragenter-dragleave-事件"></a>DragEnter 、DragLeave 事件</h3>
<p>這兩個事件的觸發分別會在被<strong>拖曳元素進入可放置元素</strong>和<strong>被拖曳元素離開可拖曳元素</strong>時發生：</p>
<pre><code>dragger.addEventListener(&quot;dragenter&quot;,function(){
  console.log(&quot;dragenter&quot;)
})

dragger.addEventListener(&quot;dragleave&quot;,function(){
  console.log(&quot;dragleave&quot;)
})
</code></pre>
<p>試著把元素拖曳進可放置元素再離開，可以發現 <code>dragenter</code> 和 <code>dragleave</code> 分別被觸發了一次。</p>
<h3 id="dragover-事件"><a class="header-anchor" href="#dragover-事件"></a>DragOver 事件</h3>
<p><code>dragover</code> 這個事件名稱代表的意義應該不難理解，意思是當<strong>可放置元素上有拖曳中的元素經過，就會持續觸發</strong>，有點像是 CSS 裡面的  <code>:hover</code> 所代表的使用情境，試著使用下面的程式碼試試看這個事件的綁定吧：</p>
<pre><code>dropper.addEventListener(&quot;dragover&quot;,function(){
  console.log(&quot;dragover&quot;)
})
</code></pre>
<p>順利的話應該會看到以下結果：</p>
<img src="/2020/02/28/web-dnd-1/dragover.png" title="dragover">
<h3 id="drop-事件"><a class="header-anchor" href="#drop-事件"></a>Drop 事件</h3>
<p>在 MDN 裡面， <code>drop</code> 事件的定義是「一個元素或文字選取區塊被放置至一個有效的放置目標時觸發。」，但想要順利的觸發這個事件必須要注意的一點是，在 <code>drop</code>行為發生之前的 <code>dragover</code> 事件的預設行為會阻止 <code>drag</code> 行為的完成，也會讓 <code>drop</code> 事件無法被觸發。</p>
<p>因此必須在 <code>dragover</code>事件裡面停止預設的行為，這可以用 <code>preventDefault</code> 方法來達到。對這個預設行為有興趣的可以先參考<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#dragend">官方說明</a>，這部分預計在下一篇文章會有更詳細的說明。</p>
<pre><code>dropper.addEventListener(&quot;dragover&quot;,function(e){
   e.preventDefault()
})
dropper.addEventListener(&quot;drop&quot;,function(e){
  console.log(&quot;drop!&quot;)
})
</code></pre>
<h2 id="實作-drag-and-drop-範例"><a class="header-anchor" href="#實作-drag-and-drop-範例"></a>實作 Drag and Drop 範例</h2>
<p>現在就讓我以前面的說明為例，來看看如何做出能夠可以把 <code>dragger</code> 拖放到 <code>dropper</code> 元素內的拖曳功能吧，我們已經宣告完 <code>draggable</code> 以及 <code>droppable</code> 的元素了，接下來只要利用事件處理就能夠完成拖拉互動了。</p>
<img src="/2020/02/28/web-dnd-1/2blocks.png" title="2blocks">
<p>現在我們有兩個方塊，左邊藍色方塊是前面提到的 <code>dragger</code> 右邊則是 <code>dropper</code> ，目標是讓藍色方塊可以被拖曳拉到右邊另一個方塊，而一個很基本的構想是在 <code>drop</code> 事件觸發時，<strong>拿掉原本的舊藍色方塊，並把藍色方塊複製一份，放到右邊橘色方塊裡面</strong>。</p>
<p>我們可以用另一個常見的 Web API 叫做 <code>appendChild</code> ，原本是用來在元素內掛載新的元素，不過如果所掛載的對象是一個已經存在的元素，就會變成是移動元素的效果（驚喜不驚喜意外不意外？沒關係我也是現在才發現），可以參考 <a href="https://www.w3schools.com/jsref/met_node_appendchild.asp">W3School 的範例</a>。</p>
<p>所以在 <code>dragstart</code> 發生時，我先試著把藍色方塊的內容暫存到另外一個變數裡面。</p>
<pre><code>let dragger = document.querySelector(&quot;.box-dragger&quot;)
let dropper = document.querySelector(&quot;.box-dropper&quot;)
let dragTemp;

dragger.addEventListener(&quot;dragstart&quot;,function(e){
  dragTemp = e.target
})
</code></pre>
<p>接下來要記得上面提到的，在 <code>dragover</code> 裡面要阻止瀏覽器預設行為。</p>
<pre><code>dropper.addEventListener(&quot;dragover&quot;,function(e){
  e.preventDefault()
})
</code></pre>
<p>這個時候 <code>drop</code> 事件已經可以順利被觸發，只要在 <code>drop</code> 事件觸發時，在 <code>event.target</code> 也就是 <code>dropper</code> 裡面掛載藍色方塊的元素，就可以完成移動。</p>
<img src="/2020/02/28/web-dnd-1/drop_finish.png" title="drop_finish">
<p>上面會看到兩個方塊沒有對齊是因為我一開始有給一些 margin ，不過從開發者工具裡面可以確定藍色方塊已經被拖曳放到橘色方塊之中。</p>
<p>再搭配適合的事件觸發以及適當的樣式調整，像是 <code>dragenter</code> 時改變顏色、 <code>dragleave</code> 時復原，就可以讓拖曳的元素經過可放置元素時產生顏色的改變來提示使用者。</p>
<img src="/2020/02/28/web-dnd-1/drag-hover-color.png" title="drag-hover-color">
<p>最後在 <code>drop</code> 事件觸發並掛載後，調整一下元素的 spacing 可以看到比較好看的效果了。</p>
<img src="/2020/02/28/web-dnd-1/finish.png" title="finish">
<p>想了解完整程式碼的話，我把這個 Demo 放在 <a href="https://codepen.io/monotrack/pen/gOpmyqv">Codepen</a> 。</p>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>其實拖拉互動效果並沒有非常複雜，可以想成瀏覽器提供給我們從拖拉開始到結束，一連串的時間段，讓我們可以在期間自由地做互動效果的調整，只要知道什麼時候該做哪些處理，基本上就是網頁元素的互動而已。</p>
<p>而想要達成拖拉互動效果也並不是只有一種方法，也沒有最正確的答案，只要熟悉DOM 元素的操作，能達到心中想要的效果我相信都是可以的。下一章節一樣會針對瀏覽器這個拖拉功能做稍微深入一點的研究，希望今天的主題能夠帶給你一些新的啟發，那麼下次見啦！</p>
<h2 id="參考資料"><a class="header-anchor" href="#參考資料"></a>參考資料</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#dragend">MDN 文件</a></li>
<li><a href="https://www.w3schools.com/jsref/met_node_appendchild.asp">W3School - appendChild</a></li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-23T15:09:01.000Z">2020-02-23</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    17 分鐘 閱讀文 (大約 2541 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/23/hexo-github-page-2/">個人技術站一把罩！部落格建置大全（二）- 將 Github Page 串上自己的域名</a>
            
        </h1>
        <div class="content">
            <p>上週提到了使用 Hexo 這個工具來架設個人部落格，並放到自己 Github Page 上的方法。這次我們要來看看怎麼把架好部落格的 Github Page ，串上自己擁有的域名( ex. <a href="http://blabla.com">blabla.com</a> ) ，所以在這篇文章內將會對 DNS 與相關設定有一定部分的講解跟介紹。有興趣的人可以先用 <a href="https://www.cowboybebop.space/">https://www.cowboybebop.space/</a> 來觀看設定完成的結果，這個域名應該還會保留 1~2 個月左右。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>域名購買與域名商介紹</li>
<li>什麼是 DNS ?</li>
<li>A Record 與 CNAME</li>
<li>A Record 與 CNAME 設定</li>
<li>Github Page 的域名設定</li>
<li>總結</li>
<li>參考資料</li>
</ul>
<h2 id="域名購買與域名商介紹"><a class="header-anchor" href="#域名購買與域名商介紹"></a>域名購買與域名商介紹</h2>
<p>首先在開始進行串接之前，你要先有域名，而域名可以透過域名商來做購買，這些域名商有很多，相同域名在不同商家的價格也會不太ㄧ樣，或是某些域名只能在某些域名商買得到，這邊推薦幾個我自己用過的：<a href="https://www.gandi.net/en">Gandi</a>、<a href="https://www.net-chinese.com.tw/nc/">網路中文</a>、<a href="https://domains.google/">Google Domains</a> 。這篇文章會用 Gandi 來做示範，但其實這些網站上購買的流程都差不多。</p>
<img src="/2020/02/23/hexo-github-page-2/gandi.png" class="gandi.png.png">
<p>在網站上購買完域名之後，就可以在 Domains 頁面看到自己擁有的域名。點擊進入各個域名就可以前往個別的設定頁面，今天會以我之前買的多出來的域名 <strong><a href="http://cowboybebop.space">cowboybebop.space</a></strong> 為例。</p>
<img src="/2020/02/23/hexo-github-page-2/gandi-domains.png" title="gandi-domains">
<p>找到 「 DNS Records 」的分頁，會看到很多，會看到一堆很像神秘魔法咒語的設定值，今天不會逐一介紹，但這邊我們有必要先了解一下什麼是 DNS。</p>
<img src="/2020/02/23/hexo-github-page-2/gandi-dnssetting.png" title="gandi-dnssetting">
<h2 id="什麼是-dns"><a class="header-anchor" href="#什麼是-dns"></a>什麼是 DNS ?</h2>
<p>DNS (Domain Name Server) ，直翻成中文是網域名稱伺服器，可以理解為「負責處理域名的伺服器」，為什麼域名還會需要處理呢？我們在使用網際網路瀏覽網頁時所看到的內容，其實是從你使用的裝置（手機、電腦或平板）連出去對另外一台裝置（也就是伺服器）索取回來的。而兩者之間的溝通，則是以 IP 位址來找到正確的伺服器，IP 位置就像現實世界的門牌地址ㄧ樣，讓其他人可以順利找到對應的位置。</p>
<p>但是我們每天經常使用的網站這麼多，像是 Facebook 、Gmail 、Dcard、Slack，如果世界上所有的網站，都使用 IP 位置來做位置的辨別，那麼你可以想像，我們可能要熟記好幾種數字組合才能夠維持正常的生活。</p>
<p>DNS 的出現就是為了解決這個問題，如同我們現在在生活中所經歷的，只要在搜尋列上輸入 <a href="http://facebook.com">facebook.com</a> 就能夠快速前往臉書的網站，這是因為 DNS 透過給每個 IP 位置取個名字，把這些原本只有電腦能夠理解的位置數據，變成人類也很好記憶、理解的名稱，讓各種網站應用能夠更加融入我們的生活中。</p>
<img src="/2020/02/23/hexo-github-page-2/DNS-Flow.jpg" title="DNS-Flow">
<h2 id="a-record-與-cname"><a class="header-anchor" href="#a-record-與-cname"></a>A Record 與 CNAME</h2>
<p>DNS 相關的設定其實有很多，我們就是透過這些設定來告訴 DNS 如何將域名配對到正確的 IP 位址。今天會介紹其中最常會碰到的兩個設定值：</p>
<ul>
<li>
<p><strong>A Record</strong> : A 代表 Address ，也就是紀錄 IP Address 與網域名稱的配對，這個紀錄是在設定 Domain Name 時最重要的項目。</p>
</li>
<li>
<p><strong>CNAME</strong> ： CNAME 是網域名稱的別名，用來將子域名指向另外一個主機的域名，最常見的就是將 <strong><a href="http://www.abc.com">www.abc.com</a> (子域名）</strong> 指向 <strong><a href="http://abd.com">abd.com</a>（購買的主域名）</strong> ，避免使用者因為意外而找不到網站（夠買主域名後，就可以從域名商的設定後台，新增子域名，是不需要另外付費的）。</p>
</li>
<li>
<p><strong>ALIAS</strong> : 與 CNAME 記錄很相像，差別在 CNAME 別名只能用於子域名，而 ALIAS 記錄能夠用在主域名，但這麼做會影響對主域名的域名解析，所以不能與 A 紀錄同時使用。</p>
</li>
</ul>
<p>在了解什麼是 A Record 與 CNAME 與 ALIAS 之後，就讓我們繼續往下設定。要達到串接域名的效果其實不只有一種方式，為了幫助理解以下提供兩種可能的方案。</p>
<h2 id="方案一：直接透過-a-record-設定"><a class="header-anchor" href="#方案一：直接透過-a-record-設定"></a>方案一：直接透過 A Record 設定</h2>
<p>因為今天的目標是要將自己的域名可以接到 Github Page。如果只是單純的想要把主域名 ( <strong><a href="http://cowboybebop.space">cowboybebop.space</a></strong> ) 串到 Github Page 上，只要將它指向 <a href="http://github.com">Github</a> 伺服器 的 IP ，也就是：</p>
<pre><code>185.199.108.153
</code></pre>
<p>就可以讓域名順利解析為 Github 主機的位址了，這部分的相關資訊可以在 <a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">Github 官方說明文件</a>內找到。而因為我們不只要找到 <strong><a href="http://github.com">github.</a>io</strong> 還要找到我們的個人頁面 <strong><a href="http://moojitsai.github.com">moojitsai.github.</a>io</strong> ，這部分必須在 Github Page 的 Repo 內做對應的設定，會在接下來的內容中提到。</p>
<img src="/2020/02/23/hexo-github-page-2/gandi-a-record.png" title="gandi-a-record">
<h2 id="方案二：cname-搭配-alias-設定"><a class="header-anchor" href="#方案二：cname-搭配-alias-設定"></a>方案二：CNAME 搭配 ALIAS 設定</h2>
<p>設定 CNAME 的目的是因為有時候我們希望使用者是透過加上 www 前綴（<a href="http://www.cowboybebop.space/">www.cowboybebop.space</a> ) 的網站域名進入我們的網站，在這種情況下只要用戶不記得或不知道要輸入 www. 前綴，就會沒辦法順利找到我們的網站應用，所以我們必須要將這些用戶重新導向到我們想要的域名。</p>
<p>通常會在域名前面加上 www. 當作網站位置是為了提醒用戶，這是一個公開的網站，藉此提升體驗。但其實加或不加，並不影響網站的功能性，只要有對應正確的設定即可，因為加上了 www. 前綴的域名，相對於主域名來說只是子域名而已，只是站在 SEO 或是追蹤流量的角度，一般還是建議兩種方式選一種（要不要加上 www.) 並且統一使用，否則 Google 爬蟲會將這兩種域名視為兩個不同的網站。</p>
<p>在方案二中，我想要以將原來沒有 www. 前綴的主域名統一導向到有 www. 前綴的子域名的方式來完成：</p>
<pre><code>cowboybebop.space/    -----自動導向到-------&gt;    www.cowboybebop.space/
</code></pre>
<p>就像上面提到的，ALIAS 記錄可以用在主域名的別名設定，這個設定剛好可以達成上面提到的導向到具有 www. 前綴域名的效果。因此我們要這麼做：</p>
<ol>
<li>將主域名的 ALIAS 設為加上 www. 前綴的子域名</li>
<li>將加上 www. 前綴的子域名， CNAME 設為 Github Page 的 URL</li>
</ol>
<p>提供下圖做為參考，只要看第一跟最後一筆紀錄就可以了，其他是系統預設的設定。</p>
<img src="/2020/02/23/hexo-github-page-2/gandi-cname-alias.png" title="gandi-cname-alias">
<p>透過這樣的方式，我們就能夠完美的將有 www. 與沒有 www. 前綴的域名都導向到 Github Page 頁面囉！而且統一使用的會是 <strong>www.cowboybebop.space</strong>，也符合前面提到的建議使用方式！</p>
<h2 id="github-page-設定"><a class="header-anchor" href="#github-page-設定"></a>Github Page 設定</h2>
<p>在 Github Page 對應 Repo 內的 Setting 頁面裡的 「 GitHub Pages 區塊」，可以看到 Custom Domain 欄位，在這邊我們必需告訴 Github 我們想要將自己的 Github Page 與哪一個域名串接，才能夠讓我們自己的域名，正確對應到原來個人的 Github Page Url。</p>
<p>設定完之後，記得把 「Enforce Http」的設定打勾，這樣一來，我們的域名就自動有了 https 憑證，不需要在自己簽發，因為 Github 幫你做掉了，這個功能超方便！</p>
<img src="/2020/02/23/hexo-github-page-2/github-setting-domain.png" title="github-setting-domain.png">
<p>設定完成後應該可以在 <a href="https://www.cowboybebop.space/">https://www.cowboybebop.space/</a> 看到頁面了！</p>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>域名相關的設定對於網頁相關工作者來說，初期並不是那麼容易了解，因為其中還有許多細節跟環節，像是 DNS 相關的設定也不只有今天介紹的三種，還有其他適用於特殊使用情境的設定，只不過比較特定。像是 ALIAS 紀錄我也是在寫這篇文章的期間才發現，並知道怎麼設定的。</p>
<p>而因為每次 DNS 設定更新之後，必須等待 DNS 伺服器解析後才會生效，因此來來回回也失敗了好幾次才終於達成目標，這部分是我覺得最麻煩的。也感謝我的顧問團隊 <a href="https://maxchou.dev/">Max</a> 的幫助。那麼這個 Github Page 的部落格系列就暫時到這邊，希望大家都能夠有記錄自己成長過程的專屬頁面囉，那麼就下次見，有發現什麼有趣的東西再來跟大家分享！</p>
<h2 id="參考資料"><a class="header-anchor" href="#參考資料"></a>參考資料</h2>
<p><a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">Managing a custom domain for your GitHub Pages site</a></p>
<p><a href="https://docs.gandi.net/zh-hant/domain_names/faq/record_types/cname_record.html">CNAME 紀錄</a></p>
<p><a href="https://www.zhihu.com/question/20414602">為什麼越來越多的網站域名不加「www」前綴？</a></p>
<p><a href="https://maxchou.dev/">我室友 Max</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2020/02/16/hexo-github-page/" class="image is-7by1">
            <img class="thumbnail" src="/thumbnails/theme.png" alt="個人技術站一把罩！部落格建置大全（一）- 使用 Hexo 搭配 Github Page 建置自己的部落格">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-15T16:54:50.000Z">2020-02-16</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分鐘 閱讀文 (大約 1865 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/16/hexo-github-page/">個人技術站一把罩！部落格建置大全（一）- 使用 Hexo 搭配 Github Page 建置自己的部落格</a>
            
        </h1>
        <div class="content">
            <p>這是我參加<a href="https://www.hexschool.com/2019/11/14/2019-11-14-w3Hexschool-2020-challenge/?fbclid=IwAR2jnd1zwQf14xWUK4J2DztB4XpkkALumb0VS3jSjMKvkqFUhP9xlTICAeU">六角全馬鐵人挑戰的第二週</a>，在比賽的一開始，就讓我來分享如何在 Github Page 上面架設自己的個人頁面，並串上自己購買的網域名稱（如果有的話）。相信各位工程師們多少都會聽過或看過其他工程師們使用  <a href="https://medium.com/@moojing">Medium</a>  當作自己的部落格，對其他人分享自己經歷及技術，或是成長過程中領悟到的見解。</p>
<p>但如果你想對這個屬於自己的空間有更高的掌握度，或是想做一些比較客製化的排版視覺，那麼架設<a href="https://www.muji.dev/">個人專屬的部落</a>會是一個不錯的選擇。因此這邊推薦使用 <a href="https://hexo.io/zh-tw/docs/">Hexo</a> ，作為今天介紹的主角。當然，方法沒有絕對，你也可以選擇自己從零開始開發，但我認為工程師的職涯如此漫長，有很多問題等我們解決，因此在適當的時機使用適合的工具，有時候是必要的。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Hexo 介紹及專案建置</li>
<li>Hexo 專案架構</li>
<li>Github Page</li>
<li>將 Hexo 專案部署到 Github Page 上</li>
<li>總結</li>
</ul>
<h2 id="hexo-介紹及專案建置"><a class="header-anchor" href="#hexo-介紹及專案建置"></a>Hexo 介紹及專案建置</h2>
<p>Hexo 是一套可以快速幫你建置個人部落格的工具，在官方提供的<a href="https://hexo.io/themes/">頁面</a>你可以找到很多別人做好的部落格模板，並直接套用到自己的專案。</p>
<img src="/2020/02/16/hexo-github-page/theme.png" title="hexo-theme">
<p>首先讓我們先把 hexo 的建置工具裝到系統內，使用以下指令：</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<p>之後就可以利用 hexo 指令創造一個新的部落格專案。</p>
<pre><code>npm init &lt;要創造的 Hexo 專案資料夾名稱&gt;
</code></pre>
<p>接下來進入剛剛建好的專案資料夾再用這個指令把 hexo 本地測試 server 架起來。</p>
<pre><code>hexo server 或 hexo s
</code></pre>
<p>沒錯，這樣一來在本地就可以看見即時的變更囉，很方便吧！</p>
<img src="/2020/02/16/hexo-github-page/hexo-local.png" title="hexo-local">
<h2 id="hexo-專案結構"><a class="header-anchor" href="#hexo-專案結構"></a>Hexo 專案結構</h2>
<p>這邊先介紹一下 Hexo 的資料夾分佈，以及功能。首先在根目錄可以看到幾個比較重要資料夾：</p>
<ul>
<li>
<p>public : 存放編譯後的靜態 html 檔案，基本上不會需要改動裡面的內容</p>
</li>
<li>
<p>scaffolds：存放文章模板的地方，新增文章的時候可以選擇要用哪一種模板，以我為例，在寫 JS 文章跟後端 Ruby on Rails 文章的時候就可以用不同模板來產生不同分類與不同標籤的文章，不用每次都另外再改。使用模板來新增文章的參考指令：</p>
<pre><code>  hexo new &lt;&lt;Scaffold Name&gt;&gt;  &lt;&lt;Article Name&gt;&gt;
</code></pre>
  <img src="/2020/02/16/hexo-github-page/hexo-scaffold.png" title="hexo-scaffold">
</li>
<li>
<p>source :  存放部落格文章原始檔案， Hexo 內的文章通常以 Markdonw 來表示內容，而 Markdown 在很多地方都通用，非常方便。</p>
</li>
<li>
<p>themes : Hexo 官網可以選擇許多別人做好的主題，在官網找到喜歡的主題後，就可以下載並放到這個資料夾，然後記得在根目錄的 <code>_config.yml</code> 檔案裡的 theme 設定改為對應的主題名（資料夾名稱） ，以這個範例來說就是 landscape ，而對應的主題資料夾裡面則包含了外觀相關的原始碼（如 HTML / CSS / JS)，建議在必要的時候再去修改這些原始碼，否則盡量修改對應主題資料夾裡面的 <code>_config.yml</code> 檔案（與根目錄的同名設定檔不同）會比較好。</p>
</li>
</ul>
<img src="/2020/02/16/hexo-github-page/hexo-folder.png" title="hexo-folder">
<h2 id="github-page"><a class="header-anchor" href="#github-page"></a>Github Page</h2>
<p>什麼是 Github Page ？ 在對 Hexo 專案內容有了基本的了解後，讓我們繼續往下看。 Github Page 是 Github 提供的、能讓開發者利用 git 的形式直接配置好靜態頁面的功能，非常好用，許多實驗性的作品或專案也都會透過這樣的方式來呈現，而今天我們就會嘗試將 Hexo 用 Github Page 的方式來作部署。</p>
<p>首先在 Github  上創建一個新的 Repository ，Repository的名字依照<a href="https://pages.github.com/">官方說明</a>，必須遵循以下規則</p>
<p>( 記得 <code>username</code> 是你自己的 Github 帳號，不要輸入錯了 )：</p>
<pre><code>&lt;username&gt;.github.io
</code></pre>
<img src="/2020/02/16/hexo-github-page/create-github-page.png" title="create-github-page">
<p>然後就會得的一個新的 Repository ，待會我們 Github Page 就會是以這個 Repository 的內容為主來做對外顯示。</p>
<img src="/2020/02/16/hexo-github-page/github-page-empty.png" title="github-page-empty">
<p>其實剛剛輸入的 Repository 名稱 <code>&lt;username&gt;.gtihub.io</code> 就會是你個人Github Page 的網址，可以直接透過瀏覽器輸入網址找到，但因為目前還是空的，所以還不會有東西，我們先在電腦本地將這份 Repository  clone 下來 :</p>
<pre><code>https://github.com/moojitsai/moojitsai.github.io.git
</code></pre>
<p>並新增 <code>index.html</code> 檔案做個測試，因為 Github 預設會去尋找這個檔名的檔案作為進入點。</p>
<img src="/2020/02/16/hexo-github-page/github_page_index.png" title="github_page_index">
<p>新增完成後只要再用 <code>git push</code> 推回剛剛的 Repository 上，就會有 index.html 檔案，應該就可以從你的個人 Gtihub Page網址看到了（如果沒有看到再來問我）。</p>
<img src="/2020/02/16/hexo-github-page/github_page_init.png" title="github_page_init">
<h2 id="將-hexo-專案部署到-github-page-上"><a class="header-anchor" href="#將-hexo-專案部署到-github-page-上"></a>將 Hexo 專案部署到 Github Page 上</h2>
<p>建立完新 Gtihub Page 後，我們來看看怎麼把這整個部落格專案放到 Github Page 上面，其實不難， Hexo 大多幫你做好了，只要設定檔配置正確就沒問題。</p>
<p>首先找到 <code>_config.yml</code>  這個檔案，然後在 <code>deploy</code> 這個設定下輸入你對應的 Github Page 的 Repo 位置，並把 <code>type</code> 寫為 <code>git</code> ，就完成基本設置了：</p>
<img src="/2020/02/16/hexo-github-page/hexo_deploy_config.png" title="hexo_deploy_config">
<p>然後在部落格專案目錄底下裝上官方提供的 Git 部署套件 <code>hexo-deployer-git</code>：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre>
<p>最後因為我們文章內容並不是網頁可以直接看得懂的格式，像文章內容就是用 Markdown 來撰寫，所以在部署上 Github 之前我們要先產生部落格專案所需要的靜態檔，使用以下指令來產生：</p>
<pre><code>hexo generate 或是 hexo g 
</code></pre>
<p>完成後就可以部署了：</p>
<pre><code>hexo deploy 或 hexo d
</code></pre>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>今天的內容主要是紀錄部落格架設的過程，因為當初在使用 Hexo 的某些設定及功能時，某些官網寫的資料並不是那麼明確，還是要自己實驗過或是去看原始碼才比較會知道怎麼做，因此還是寫了一篇文章記錄下來，順便分享給有興趣的各位，下一篇要分享的是如何把今天設置完放到 Github Page 的網頁與自己購買的域名做串接，應該會蠻有趣的！可以先看看我最近串好的域名： <a href="https://www.muji.dev">https://www.muji.dev</a></p>
<h2 id="參考文章"><a class="header-anchor" href="#參考文章"></a>參考文章</h2>
<p><a href="https://hexo.io/docs/">Hexo 官網</a></p>
<p><a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site">Managing a custom domain for your GitHub Pages site</a></p>
<p><a href="https://pages.github.com/">Github Page 說明</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-04T06:29:22.000Z">2020-02-04</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 分鐘 閱讀文 (大約 2314 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/04/browser-history-state-api/">瀏覽器的時光機—歷史堆疊、 pushState 與 replaceState API</a>
            
        </h1>
        <div class="content">
            <p>或許 <code>pushState</code> 與  <code>replaceState</code> 這兩個詞你可能沒聽過，但是瀏覽器「上一頁、下一頁」功能你一定不陌生，其實這兩個 API 是瀏覽器提供給開發者<strong>操作瀏覽紀錄</strong>用的，透過這兩個 API 並搭配事件處理，我們就可以將瀏覽器預設的「上一頁下一頁」修改成我們想要的客製化結果。</p>
<ul>
<li>使用情境說明</li>
<li>pushState / replaceState 與點擊新連結有什麼不一樣</li>
<li>pushState  / replaceState 與 Stack 結構</li>
<li>pushState  / replaceState 使用方式</li>
<li>onpopstate 事件</li>
<li>一個栗子</li>
</ul>
<h2 id="使用情境說明"><a class="header-anchor" href="#使用情境說明"></a>使用情境說明</h2>
<p>最近接到了必須修改瀏覽器歷史紀錄行為的需求，所以順便寫了篇文章整理下來。 在公司負責的產品是類似 AWS 那樣資源控制的後台介面，前端部分雖然使用了 React 作為主要工具，但架構上有點像是由 Webpack 打包出靜態檔， 之後交由後端 Server 來處理前端內容，所以無法直接將路由控制交給 React 作使用。</p>
<p>什麼意思？一般 SPA 原理是由 JS 產生動態內容並即時掛到 DOM 上，但這個產品流程上是這樣：</p>
<ol>
<li>在開發階段由 Webpack 將源碼打包成瀏覽器看得懂的程式碼，一個工具模組對應一個頁面</li>
<li>在產品運行階段由 Node Server 來處理剛剛 Webpack 打包好的靜態檔案</li>
<li>因此除非在後端做更詳細的路由修改，否則無法作更複雜的路由變化（ex.巢狀路由）</li>
</ol>
<!-- ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fdbc9a88-7e57-4fb8-a259-e90e651c2d76/Company-Structure.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fdbc9a88-7e57-4fb8-a259-e90e651c2d76/Company-Structure.jpg) -->
<img src="/2020/02/04/browser-history-state-api/Company-Structure.jpg" title="Company-Structure">
<p>而在這種情況下如果某一工具模組需要以多個頁面來進行資料的設定流程，就沒辦法像一般我們所習慣的使用框架的 Router 函式庫 —  React-Router 或是 Vue-Router 讓路由與頁面動態地做搭配，因此 pushState 及 replaceState 這兩個 API 就特別適合這個時候拿出來使用。</p>
<p>（可能還是可以，只是在當時沒有太多時間做調查的情況下，我當下所做的決定就是使用這兩個 API 來解決）</p>
<p>首先讓我們先來了解 <code>pushState</code> 與 <code>replaceState</code> 在做什麼事情。</p>
<h2 id="pushstate-replacestate-與點擊連結有什麼不一樣"><a class="header-anchor" href="#pushstate-replacestate-與點擊連結有什麼不一樣"></a>pushState / replaceState 與點擊連結有什麼不一樣</h2>
<p>兩種方式都會改變瀏覽器網址列的內容，但 pushState 與 replaceState 差別在於**會不會發送新的 Http Request，**這點應該不難發現，一般我們點擊新連結時，因為會發送 Request ，對後端重新要求一份的 HTML 內容，因此這個時候會看到瀏覽器重新刷新了頁面。</p>
<p>相對的 pushState 與 replaceState 這兩個 API 則單純只會修改網址列的內容，而不會刷新頁面，只是如果使用者在網址列按下 Enter 或重新整理的話，就一樣會發出 Request 。這與單純點擊的效果相同。</p>
<h2 id="瀏覽器記錄與-stack-結構"><a class="header-anchor" href="#瀏覽器記錄與-stack-結構"></a>瀏覽器記錄與 Stack 結構</h2>
<p>關於今天提到的兩個 API，如果查詢 JS 的 MDN 文件的話，關於 <code>pushState</code> 會得到以下的說明：</p>
<pre><code>In an HTML document, the history.pushState() method adds a state to the browser's session history stack.
</code></pre>
<p>而 <code>replaceState</code> 則是 :</p>
<pre><code>The replaceState() method modifies the current history entry, replacing it with the state objects, title, and URL passed in the method parameters.
</code></pre>
<p>讀完這兩段雖然可能沒辦法馬上弄清楚說明的意思，但從內容我們可以看到一個蠻重要的部分：「  history stack.」這是否說明瀏覽器記錄與資料結構裡的堆疊 ( Stack ) 有關？沒錯，瀏覽器裡的歷史紀錄就是以堆疊的形式儲存下來供使用者作使用，首先讓我們來看看堆疊是什麼，可以看看以下的模型圖。</p>
<img src="/2020/02/04/browser-history-state-api/Stack.jpg" title="Stack">
<p>我們可以使用 <code>push</code> 與 <code>pop</code> 兩種方法分別對堆疊結構加入一筆新的資料或是取出最後一筆資料，因此，關於堆疊有一個很常見的描述就是「先進後出」。其他前端常用到的資料結構可以參考我之前<a href="https://ithelp.ithome.com.tw/articles/10227662">鐵人賽的文章</a>。</p>
<p>所以堆疊套用在歷史紀錄上是怎麼回事呢？每當我們從同一個頁面點擊網址轉到新的頁面時，就是在對歷史紀錄的堆疊使用 <code>push</code> 方法新增一筆新的瀏覽紀錄 ，而當我們執行上一頁往前瀏覽時，就像是在使用 <code>pop</code> 方法取出最後一筆瀏覽紀錄（網頁位置）。</p>
  <img src="/2020/02/04/browser-history-state-api/Browser-Stack.jpg" title="Browser-Stack">
<h2 id="pushstate-replacestate-使用方法"><a class="header-anchor" href="#pushstate-replacestate-使用方法"></a>pushState / replaceState 使用方法</h2>
<pre><code>history.pushState(state, title, url);
</code></pre>
<p>現在讓我們回到這兩個 API 上 ， pushState 與 replaceState 都接受三個參數，分別是：</p>
<ul>
<li>state：每個 history stack 都會可以給一個 state 物件。</li>
<li>title : 更新後頁面的 title 標籤內容設定，不過根據官方文件說明，目前為止大部分瀏覽器都會忽略他，因此最安全的方法是傳入空字串，不做任何修改。</li>
<li>url  : 執行該方法後想要更新的想要更新的 url</li>
</ul>
<p>但是這兩個長得這麼像的方法在使用上有什麼不ㄧ樣呢？首先，前面提到這兩個 API 都只會更改網址列內容而不會發出新的 Request (刷新頁面），而它們在使用上其實也差不多，差別在<strong>改變歷史紀錄堆疊的方式</strong>而已。</p>
<p><code>pushState</code> 在被呼叫之後會真的對瀏覽歷史紀錄堆疊新增一筆紀錄，所以如果用 <code>console.log</code> 把 <code>history.length</code>  （歷史紀錄堆疊的長度）印出來看的話會發現長度多了 1 。</p>
<p>而 <code>replaceState</code> 在呼叫後雖然ㄧ樣會改變網址列內容，但 <code>history.length</code> 的值卻不會有任何改變，這是因為如果用堆疊的方式來看歷史紀錄的話， replaceState 只會修改堆疊的最後一筆紀錄內容，也就是目前的網址列內容。</p>
<h2 id="onpopstate-事件"><a class="header-anchor" href="#onpopstate-事件"></a>onpopstate 事件</h2>
<p>在瀏覽器上一頁按鈕被執行時，堆疊的最上層，也就是最後一筆瀏覽紀錄會被取( pop ) 出，新的一筆紀錄網址會被更改到網址列內，而這時會觸發瀏覽器的內建事件 — popstate 事件。所以如果有些客製化功能想要搭配上一頁按鈕執行，就可以使用這個事件。使用：</p>
<pre><code>window.onpopstate  = (event)=&gt;{ //事件函式內容 }
</code></pre>
<p>就可以寫入自訂的事件內容。</p>
<h2 id="一個栗子"><a class="header-anchor" href="#一個栗子"></a>一個栗子</h2>
<p>說了這麼多，來舉個實際的例子看看運作方式如何吧，現在我有三個按鈕，每個按鈕點擊後各自會呼叫有不同參數的 pushState 方法，而這時因為是第一次進入頁面，所以 history.length 是 1 。</p>
<img src="/2020/02/04/browser-history-state-api/1.png" title="example-step1">
<img src="/2020/02/04/browser-history-state-api/2.png" title="example-step2">
<p>所以如果我依序點擊 first 、second 、 third 按鈕之後，應該會在瀏覽器歷史裡新增三筆紀錄堆疊。</p>
<img src="/2020/02/04/browser-history-state-api/3.png" title="example-step3">
<p>可以從上圖看到目前的網址內容變成 <code>third.html</code> ，但頁面仍然是原本的內容，沒有刷新，而瀏覽紀錄堆疊長度也真的變成 4 。這時的堆疊裡應該分別是：</p>
<pre><code>first.html -&gt; first.html -&gt; second.html -&gt; third.html 
</code></pre>
<p>堆疊裡的最後一筆紀錄是 third.html ，所以現在如果點擊上ㄧ頁按鈕，理論上會回到 second.html 堆疊。</p>
<img src="/2020/02/04/browser-history-state-api/4.png" title="example-step4">
<p>透過上圖可以看出確實如此，而且搭配 <code>onpopstate</code> 事件把 event 物件印出來可以看到在 pushState 時傳入的 <strong>state 物件的內容</strong> 也會隨著被 pop出來。還有一個可以注意的地方是我們在做以上這些操作時，都沒有任何頁面刷新的情況發生，但確實改變了瀏覽紀錄堆疊。</p>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>上面總共提到了 pushState、replaceState 及 onpopstate 事件，也提到歷史紀錄堆疊的存放方式，還有pushState、replaceState 與一般點擊連結的差異，只要好好活用這些 API 方法的特性，就可以達成 主流框架 Router 如 React-Router 或 Vue-Router 那樣不發 Request 就能頁面的效果（其實推測一下的話這些 Router 函式庫裡面應該也是使用這些方法）。</p>
<p>那麼就寫到這邊，最近剛好有這樣的需求需要比較特別的解決方法，剛好看了一下以前沒有深究的部分，覺得蠻有趣的，就順便記錄跟整理下來，下次有不錯的東西再寫下來跟大家分享囉！</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:27.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16 分鐘 閱讀文 (大約 2431 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-30/">JS 原力覺醒 Day30 - 我是怎麼活過這三十天的？</a>
            
        </h1>
        <div class="content">
            <p>總算來到最後一天了，最後一天不會有技術內容，只會有很純的純 Mur Mur，想聽的再請留下。最後我打算記錄一下這三十天的感受，給其他沒參加過鐵人但是正在猶豫要不要參加的朋友參考。</p>
<p>普遍看到參賽方式有幾種情況：</p>
<ul>
<li>精明準備型：囤好囤滿 30 天，完全事先囤貨所以內容超精緻</li>
<li>微囤貨：不事先準備太多，只囤幾天貨用來緩衝</li>
<li>硬派：「 什麼！？不就是要現學現賣才叫做鐵人嗎？ 」的類型</li>
</ul>
<p>老實說我認為如果不事先準備的話，那麼能不能完賽跟主題的選擇還有自身對主題熟悉度會有很大的關係，所以如果你也正在思考要不要參加，可以從這點著手。如果主題是你想寫但不熟，可以考慮現在開始到下次開賽前先慢慢累積文章量；或者你覺得對主題比較上手，可以挑戰看看自己在短時間內對知識的理解程度。</p>
<h2 id="30天連續發文不只考驗技術"><a class="header-anchor" href="#30天連續發文不只考驗技術"></a>30天連續發文不只考驗技術</h2>
<p>經過評估，我走的是微囤貨路線，因為我是在 9/2  開賽前幾天才知道有鐵人賽這個活動，剛好我的下一個近期目標是對 JS 這個語言更有系統性的認識，當時是覺得這個活動可以用來挑戰一下自己，也正好可以之前寫的  <a href="https://medium.com/@moojing/%E5%8E%9F%E5%AD%90%E5%8C%96%E5%AD%B8%E7%BF%92-%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E4%B8%AD%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7-4622ab26934">原子化學習</a>  裡面把知識最小化的學習方式做實作驗證，所以想了一下大概要寫什麼之後就跳坑了。到了開賽期限 9/16 前一天，我硬生出大約 10 來篇準備留著緩衝。</p>
<p>沒想到正式開賽才發現我完全低估每天必須發文所帶來的壓力了，因為事先沒有累積太多文章的關係，我幾乎每天都在想著下一篇文章的內容怎麼寫、大綱怎麼擬定、要怎麼畫出核心概念圖才能讓人比較好理解之類的問題。這樣子的狀況持續到大概第 20 篇的時候是最痛苦的，因為越後面的主題我越不熟，需要越多時間，而前面的幾篇卻也因為思考解說方式跟準備圖例的關係花了不少時間，留下來的緩衝時間所剩無幾。</p>
<p>在這個時間點想繼續寫覺得吃力，想放棄又覺得不太對，瞬間覺得自己好像在跑一場已經完成 2/3 ，明明心裡知道快結束了但眼前就是還看不到終點線的尷尬窘境。所以我深深覺得鐵人賽除了考驗技術熟悉度更考驗筆者的心理耐力。在最後雙十連假那幾天實在是最難受的，雖然咬著牙硬寫完了，但是基本上我是ㄧ邊配獵人邊寫完的（喂</p>
<h2 id="使用工具"><a class="header-anchor" href="#使用工具"></a>使用工具</h2>
<p>工欲善其…咳咳，好廢話不多說，稍微介紹一下我這幾天用來幫助寫文章工具，基本上有三個：</p>
<ol>
<li>
<p>Notion</p>
<p>在正式開賽之前，我先用 Notion 的 Table 整理了三十天的大綱，雖然最後沒有完全ㄧ樣，不過可以讓自己對文章主題有個底，時間的掌握也比較精準，哪些主題自己比較不熟的話就要預留比較多時間。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20191015/20106580Hsbd3FYXSf.png" alt="https://ithelp.ithome.com.tw/upload/images/20191015/20106580Hsbd3FYXSf.png"></p>
</li>
<li>
<p>簡單的流程圖繪製軟體</p>
</li>
</ol>
<p>這種軟體的選擇就比較多，我是選 Sketch，一來之前有學過一點，二來覺得他匯出圖片很方便，雖然他主要是用來前端介面設計的工具，但是拉拉簡單的區塊跟流程箭頭還是很好用的。還有另外一套網頁版繪圖軟體也很推薦：<a href="https://www.draw.io/">Draw.io</a></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191015/20106580m8ATiR1MZH.png" alt="https://ithelp.ithome.com.tw/upload/images/20191015/20106580m8ATiR1MZH.png"></p>
<ol start="3">
<li>瀏覽器開發者工具：</li>
</ol>
<p>因為我寫的主題不是製作產品型的主題，許多範例程式碼只要可以馬上確認結果就好，這個時候整個瀏覽器都是我的實驗場 :D</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191015/2010658095DQqsedJi.png" alt="https://ithelp.ithome.com.tw/upload/images/20191015/2010658095DQqsedJi.png"></p>
<h2 id="是音樂-我加了音樂"><a class="header-anchor" href="#是音樂-我加了音樂"></a>是音樂，我加了音樂</h2>
<p>如果你以為我是像老派英雄主義電影裡的主角ㄧ單單靠著強大的意志力就輕輕鬆鬆寫完 30 篇文章練成鐵人那就錯了，我也希望我可以。 我曾經抱著很中二的想法，覺得如果世界上沒有音樂的話，我們幹嘛活著？老實說我現在還是深深這麼想的，大概今後也會一直這麼中二下去。總之最後來介紹一下陪伴我度過這地獄般 30 天的幾首曲子：</p>
<ul>
<li>
<p>Tauk - Horizon ：</p>
<p>風格上屬於前衛搖滾，我很喜歡他們華麗的效果器加上風格多變的主奏電吉他，雖然沒有人聲，但總能聽得我熱血沸騰，附上近期喜歡的一首曲子：</p>
<p><a href="https://www.youtube.com/watch?v=I0Ju0uIT004"><img src="https://img.youtube.com/vi/I0Ju0uIT004/0.jpg" alt="Yes"></a></p>
</li>
<li>
<p>Takami Nakamoto - Ashes：</p>
<p>這個音樂家的作品風格定位上還是比較偏電子舞曲，一般人聽來可能會覺得比較實驗性或藝術性，但我真的很喜歡各種奇異材質的聲響。想暫時脫離現實生活看一下不ㄧ樣世界樣貌的絕對推薦（建議戴耳機）：</p>
<p><a href="https://www.youtube.com/watch?v=dGyCHP0g3zA"><img src="https://img.youtube.com/vi/dGyCHP0g3zA/0.jpg" alt="Yes"></a></p>
</li>
<li>
<p>Mariya Takeuchi - Plastic Love :</p>
<p>這首毫無疑問是經典，我真的很喜歡遍佈整首的 Disco 元素，前奏剛下沒多久眼前就浮現煙霧彌漫然後雷射燈球光芒四射的場景，查了一下定位屬於 City Pop ，City Pop 是在 1970 日本傳統音樂受到西方音樂文化元素的影響而發展出來的獨特曲風，在當時由山下達郎組成的樂團 SUGAR BABE 帶起風潮。而竹內瑪莉雅就是山下的妻子，也是早期非常有名的音樂家之一，這首歌在前陣子 City PoP 復甦的時候出現在我的推薦歌單內，聽過後立刻愛上。</p>
<p><a href="https://www.youtube.com/watch?v=9Gj47G2e1Jc"><img src="https://img.youtube.com/vi/9Gj47G2e1Jc/0.jpg" alt="Yes"></a></p>
</li>
<li>
<p>The Brand New Heavies :</p>
<p>這個團體是 Acid Jazz (酸爵士)  的經典團體之一，Acid Jazz 緣起於 Disco 文化，在 1980 年代開始變成風潮，當時舞廳的 DJ 嘗試將爵士樂中的樂句加以取樣，融入電子音樂裡面並融合了靈魂樂、Funk、R&amp;B 等曲風，因而吸引了年輕世代跟老年族群的注意，也是一個讓當代大眾重新開始接觸爵士樂的契機。</p>
<p>雖然在  1987 年由知名唱片經營者 Eddie Piller 與 DJ Gilles Peterson 創立同名自有品牌後才正式被命名，不過 Acid Jazz 這種風格受 60 年代迷幻文化影響至深。（ Acid 同時也是迷幻藥的別稱 ）所以你常常能在這種曲風裡面聽見運用電子特效達成的迷幻效果，同時又因為強烈的律動感而忍不住開始擺動身體，讓我們來聽聽看 The Brand  New Heavies 今年出的專輯同名歌曲，你一定會很喜歡：</p>
<p><a href="https://www.youtube.com/watch?v=f7sMuvTLLlU"><img src="https://img.youtube.com/vi/f7sMuvTLLlU/0.jpg" alt="Yes"></a></p>
</li>
</ul>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>原本以為在我整理完過去的學習經驗，寫出原子化學習已經是我自己在今年最有標誌性的里程碑了，沒想到又幹了一件突破自己耐力極限的事情啊 (X。老實說好幾次都以為我沒辦法完賽了，我也不知道是什麼讓我可以支撐到最後，也許是賽期後半段開始陸陸續續有人追蹤，甚至有讀者會參與內容的討論以及告知筆誤，讓我覺得有莫名一股一定要繼續寫下去的責任感。</p>
<p>其實後面還想有寫但來不及寫的主題：演算法跟設計模式，但在我寫這篇文章的當下，已經有些厲害的工程師以演算法當成 30 天的主題並且已經或快要完賽了：</p>
<p><a href="https://ithelp.ithome.com.tw/users/20120643/ironman/2829">透過 LeetCode 解救美少女工程師的演算法人生</a></p>
<p><a href="https://ithelp.ithome.com.tw/users/20106426/ironman/2136">前端工程師用 javaScript 學演算法</a></p>
<p><a href="https://ithelp.ithome.com.tw/users/20092025/ironman/2606">模組化設計</a></p>
<p>上面稍微推薦一下幾個很棒的相關系列，接下來完賽後我陸陸續續也會去看之前沒時間看的那些主題，如 神Q超人的 TypeScript 或是 六角校長的職場教學，讀者有興趣的話之後也可以跟我一起惡補回來 ( X 。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:24.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    14 分鐘 閱讀文 (大約 2079 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-29/">JS 原力覺醒 Day29 - Set / Map</a>
            
        </h1>
        <div class="content">
            <p>ES6 之後加入兩種新的資料結構：Map  跟 Set 。 Map 與 Set 都是像字串跟陣列這樣可以被尋訪的類型，也就是說可以使用 for 迴圈去一個一個查找跟操作他們的值。今天就來說明一下這兩個類別跟使用方式吧！<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Set</li>
<li>Map</li>
<li>Map 與 Object</li>
</ul>
<h2 id="set"><a class="header-anchor" href="#set"></a>Set</h2>
<p>Set 的中文翻譯與數學裡面的「集合」相同，「集合」是某個定義好並且具有相同性質的元素的集合，講白話一點就是「一堆東西」。在 JS 內的集合當然代表「一堆值」，他跟陣列有點像，差別在 Set 能夠讓開發者可以<strong>方便快速的儲存不重複、獨特的數值</strong>。至於 <code>Set</code> 內儲存的元素內容沒有型別限制，可以是純值也可以是物件型別。</p>
<p><code>Set</code> 除了具有儲存不重複數值的性質外，在上面還有一些很方便的方法可以直接處理數值，讓我們陸續來看看，首先創造一個新的 <code>Set</code> ，創造新的 <code>Set</code> 很簡單，只要在 <code>Set</code> 的建構子傳入一個陣列即可：</p>
<pre><code> let set = new Set([1,2,3,'Hello','World',true]) 
</code></pre>
<p>在 Set 類別上有許多方法讓我們可以用比較語意化的方式操作 Set 內容：</p>
<ul>
<li>add( value ) : 新增一個元素到 <code>Set</code> 內</li>
<li>clear()  ：刪除所有 <code>Set</code> 內的元素</li>
<li>delete( value) ：刪除 <code>Set</code> 內特定的某個元素</li>
<li>forEach() ： 跟 array 上的 <code>forEach</code> 功能相同</li>
<li>has( value ) ：檢查 <code>Set</code> 內有沒有對應值的元素，這個功能如果在陣列內，必須透過 <code>indexOf</code> 來檢查才能達成。</li>
<li>values() ：會回傳 Set 內所有數值</li>
<li>size ：回傳 <code>Set</code> 元素長度</li>
</ul>
<p>就像前面說過的， <code>Set</code> 內儲存的是不重複的元素，因此如果有相同數值的元素再次被傳入，這個數值就會直接被忽略。</p>
<pre><code>	set.size //6
  set.add('Hello') 
  set.size //6
</code></pre>
<p>對 Set 做巡訪的方式跟陣列很相似，一樣可以用 <code>forEach</code> 方法，甚至 <code>Set</code> 可以很方便的直接轉為陣列 ：</p>
<pre><code> let setArr = [...set]
</code></pre>
<p>這個特性非常好用，利用這點我們就可以很快速的過濾出陣列內的重複值！</p>
<pre><code> let duplicatedValueArr = [1,2,3,5,10,19,10,4,5,6,3,1,2]
 let uniqueArr  = [...new Set(duplicatedValueArr)]
</code></pre>
<p>這樣子是不是既方便快速又簡潔？ 如果單純使用陣列可能還需要透過 <code>filter</code> 跟外部變數來儲存重複值輔助檢查，使用 <code>Set</code> 的話，這些功夫都可以省去。</p>
<h2 id="map"><a class="header-anchor" href="#map"></a>Map</h2>
<p><code>Map</code> 也是跟陣列、跟 <code>Set</code> 具有相同特性且可被巡訪的物件型別，差別在於， <code>Map</code> 跟物件ㄧ樣是鍵值的組合，也就是說，<code>Map</code> 同時具有跟陣列ㄧ樣可以被巡訪的特色，同時也有物件儲存任意屬性跟數值的能力。</p>
<p><code>Map</code> 類型上的方法也與 <code>Set</code> 大同小異，差別在 Set 新增元素的方法是使用 <code>add</code> ，而 <code>Map</code> 內必須用 <code>set</code> 方法 ，且新增元素時必須傳入兩個參數，第一個是要儲存的鍵 ( key )，另外一個是要儲存的數值內容 ( value )。</p>
<p>創造新的 <code>Map</code> 的方式與創造 <code>Set</code> 相同，但由於 <code>Map</code> 是鍵-值對的結構，傳入建構子內的陣列內不能夠像 Set 那樣只是個單一元素，而必須要是個鍵-值的組合，所以我們可以用二維陣列來達成，大概像是這樣：</p>
<pre><code> let map = new Map([['name','Luke'],['Hello','World']]) 
</code></pre>
<p>取得 Map 元素 ：</p>
<pre><code>  map.get('name') // Luke 
</code></pre>
<p>新增元素 ：</p>
<pre><code> map.set('Greeting','I am Anakin') // { ... 'Hello'=&gt;'World', 'Greeting'=&gt; 'I am Anakin'}
</code></pre>
<p>其他像是刪除特定元素或是刪除所有 Map 內元素則都跟 Set 上的方法差不多：</p>
<pre><code> map.delete('Hello')  
 map.clear()
 map.size
</code></pre>
<h2 id="map-與-object"><a class="header-anchor" href="#map-與-object"></a>Map 與 Object</h2>
<p>Map 其實跟物件ㄧ樣都是 鍵-值 的組合，事實上這些結構相似的類型有許多種，如，那麼使用 Map 相比於使用物件有什麼好處呢？還記得前面提到在 JS 內除了原始型別以外的型別都是物件型別嗎？這代表除了物件以外像是 <code>Array</code> 以及<code>Function</code> 這樣的型別都是繼承自 <code>Object</code>，這其中當然包含 <code>Map</code> 。</p>
<p>所以這兩種型別才有這麼相似的結構 ，性質相同的部分就不用多說了，但是這兩者還是有一些不差異，這些差異可能足以影響資料存取的複雜度以及程式碼閱讀的難易度，所以我們可以認識一下究竟兩者有什麼不同的地方：</p>
<ul>
<li>
<p>鍵值的類型：</p>
<p>在物件內的鍵值（或屬性名稱） 必須是字串或是 <code>Symbol</code>。而在 <code>Map</code> 內，鍵值可以是任何型別，這包含任何其他的物件或是陣列 。你當然可以試試看用物件來當作另外一個物件的屬性名稱，不過這個物件會被 JS 強制轉型變成 <code>[object Object]</code> 而變成另外一個字串屬性。</p>
<pre><code>  let o = {} 
  let anotherObj = {} 
  o[anotherObj] = 'anotherObject' // {'[object Object]' : anotherObject}
  
  let theThirdObj = {} 
  o [theThirdObj] = 'theThirdObj' //  {'[object Object]' : anotherObject}
</code></pre>
</li>
<li>
<p>元素的順序，在 <code>Map</code> 裡面，元素被新增進去之後，順序就會被固定下來。而在 Object 內則無法保證。</p>
</li>
<li>
<p>繼承關係：<code>Map</code> 繼承於物件 （ Object ) ，而反過來則否，因此在 <code>Map</code> 上那些方便的方法，在 Object 上無法使用。</p>
<pre><code>  let newMap = new Map()
  console.log(newMap instanceof Object) //true
  console.log(Object instanceof newMap) //false
</code></pre>
</li>
<li>
<p>可被巡訪：這大概是最大的差別了，因為一般物件上並沒有提供可以直接巡訪的方法，只能透過 <code>for .. in</code>  迴圈達成，或是必須透過 <code>Object.keys</code> 方法把屬性轉為陣列，但是在陣列 、 Set 跟 Map 上都有 <code>forEach</code> 方法可以直接對裡面的元素做巡訪。</p>
</li>
</ul>
<h2 id="map-與-object-使用時機"><a class="header-anchor" href="#map-與-object-使用時機"></a>Map 與 Object 使用時機</h2>
<p><code>Ｍap</code> 在操作元素上雖然提供了許多語意化的方法，但有時候我們還是會需要像一般物件那樣方便新增元素的方式，最後我們就來看看兩者各適合怎樣的使用情境：</p>
<ul>
<li>屬性值：這也是兩種型別最大的差別。在知道屬性值都單純只是字串時，使用一般物件就好，因為 Map 雖然可以儲存任何型別的數值，但是因為使用函式建構子創造物件，且在新增、修改元素時必須透過 <code>get</code> 、 <code>set</code> 函式幫忙，因此速度上會比單純使用物件還要慢。</li>
<li>JSON 格式：在需要以 JSON 格式來進行開發作業時，選擇一般物件。因為 JS 內的物件可以很直接的被轉為 JSON 格式，這在進行 API 溝通時非常好用。</li>
<li>順序性： 在 <code>Map</code> 內的元素順序會被保留，因此在處理資料時，如果維持順序的穩定很重要，就可以考慮使用 <code>Map</code> 。</li>
<li>需要一些特定功能：有時候我們會需要某個函式來取得其他屬性資訊，物件因為存取方便的關係，在物件內的屬性如果是函式，就可以直接被執行，<code>Map</code> 就比較麻煩。</li>
</ul>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>除了前面我們提到的幾個基本資料結構，今天我們又認識了 JS 內新的 Map 跟 Set 兩種新的資料型別。在資料結構選擇上永遠是根據你的需求而定，雖然用簡單的物件或陣列組合或許就可以達到，多認識一些這樣子的資料結構不一定會大幅度增加開發速度，但絕對會讓你在開發時有更多其他潛在更好的選擇來達成你的需求。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:22.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    24 分鐘 閱讀文 (大約 3553 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-28/">JS 原力覺醒 Day28 - JS 裡的資料結構</a>
            
        </h1>
        <div class="content">
            <p>隨著硬體規格條件的提升， 網站商業邏輯的運作也慢慢從以往的後端伺服器轉移到客戶端，因此前端領域的專業知識就變得越來越重要，隨著前端技術被重視，也開始慢慢出現 React 、 Vue 、 之類前端框架的生態圈出現，而後端則慢慢演變為單純的 API 伺服器負責提供資料的存取端口。同樣的，畫面的互動也是另一個越來越被注重的部分，<strong>因此怎麼實作出更精緻優雅的前端介面以及互動邏輯也是前端工程師們面臨的新挑戰之一</strong>。這些在在的都考驗了工程師們對 JS 這個語言本身更全面的了解。</p>
<p>如同前面所說，隨著商業邏輯慢慢著重在前端，<strong>許多資料的規格訂定也常常會跟隨著介面的結構而有所不同</strong>，這些隨著前端邏輯而被暫存在前端的資料，變得有點像是後端伺服器放在前端的副 @本。所以，前端工程師的經驗跟專業，就會在<strong>資料結構的選擇與判別使用的時機的能力上顯現出差異</strong>，而某些資料結構我們在前面的文章多多少少都有提到一些了。在這篇文章內，我想較全面的，對在開發上，常使用到或常見的資料結構做一些說明。</p>
<p>基本上有三種類型資料結構：</p>
<ul>
<li>陣列型態的資料結構 ：Stack 、Queue</li>
<li>以「節點」為基礎的：Linked Lists、 Trees</li>
<li>在資料查找上非常方便的： Hash Tables</li>
</ul>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Stack</li>
<li>Queue</li>
<li>Linked Lists</li>
<li>Trees</li>
<li>Hash Tables</li>
<li>總結</li>
<li>參考文章</li>
</ul>
<h2 id="stack"><a class="header-anchor" href="#stack"></a>Stack</h2>
<p>Stack 具有後進後出的特性，堆疊的概念我相信各位 JS 工程師都已經非常熟悉了，而這大概也是 JS 內最重要的資料結構了，在之前講到執行環境堆疊的時候有提過。以程式的方式來說，堆疊的結構就是一個具有 <code>push</code> 跟 <code>pop</code> 兩個方法的陣列，<code>push</code> 可以把元素放到堆疊的最上層，而 <code>pop</code> 可以把元素從堆疊的最上層拿出來。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580fh2OZ6eKkv.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580fh2OZ6eKkv.jpg"></p>
<h2 id="queue"><a class="header-anchor" href="#queue"></a>Queue</h2>
<p>Queue，序列 也是 JS 語言的核心部分之一，Queue 具有「先進先出」的特性，還記得我們之前提到的 Event Queue 、 MacroTask Queue 以及 MicroTask Queue 嗎？因為有了 Queue 這種樣子的資料結構，JS 才能夠具有非同步這麼具有識別度的特性。那麼以程式的角度來看，Queue ㄧ樣是有兩種方法的陣列：<code>unshift</code> 與 <code>pop</code>。 <code>unshift</code> 可以把元素放到 Queue 的最尾端，而 <code>pop</code> 則是把元素從最前端取出來，Queue 也可以反向操作，只要把 <code>unshift</code> 與 <code>pop</code> 換成 <code>shift</code> 與 <code>push</code>。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580JRDdzjisVa.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580JRDdzjisVa.jpg"></p>
<h2 id="linked-list"><a class="header-anchor" href="#linked-list"></a>Linked List</h2>
<p>Linked List ，鏈結串列是一種有序的、且線性的資料結構，在 Linked List 上每一筆資料都可以被看作是一個節點 ( Node )，每個節點上都包含了兩個資訊：一個是要儲存的數值、一個是指向其他節點位置的指標。Linked List 具有以下特性：</p>
<ul>
<li>是被一個一個指標串連起來的</li>
<li>第一個節點被稱為 <code>head</code> ，是一個指向第一個節點的參考指標</li>
<li>最後一個節點被稱為 <code>tail</code> 節點，是指向最後一個節點的參考指標</li>
<li>最後一個指摽指向的是 <code>null</code></li>
</ul>
<p>Linked List 基本上有 單向（ singly ） 跟 雙向 ( doubly )  兩種類型，在單向的鏈結串列中，只存在一個指向下一個節點的指標。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580Jh38FNHdmU.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580Jh38FNHdmU.jpg"></p>
<p>而在雙向的鏈結串列中，則會有兩個指標，一個指向上一個節點，一個指向下一個節點。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580nZx8X7Mikl.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580nZx8X7Mikl.jpg"></p>
<p>Linked List 由於結構的關係，可以在頭、尾，任何地方插入節點，因為只要改變指標的指向就可以了，所以只要搞懂運作方式，他也能實現前面提到的 Queue  跟 Stack 結構的行爲。Linked List 在前後端開發上也很有幫助，在前端 React 框架常常搭配使用的狀態管理器 Redux  中，從畫面到 Action 到 Reducer 這樣子的資料流，就使用了 Linked List 的思考方式，來決定資料的下一個目標（ 函式 )。在後端 Express 框架上則用 Linked List 來處理 Http Request 與 Middleware 層的資料流動。</p>
<p>接下來讓我們以雙向的鍊結串列來看看實際上在 JS 內是怎麼使用的，首先我們會需要節點的類別，這樣我們就可以自己指定節點跟下一個節點：</p>
<pre><code>class LinkedNode {
		constructor(value,prev,next){
				this.value = value;
        this.next = next;
        this.prev = prev;
		} 
} 
let head = new LinkedNode(null,null,null)
let node1 = new LinkedNode(1,head,null)

let node2 = new LinkedNode(2,node1,null) 
let node3 = new LinkedNode(3,node2,null) 

node1.next = node2
node2.next = node3
</code></pre>
<p>然後我們可以再創一個 LinkedList 類別來記錄這些節點間的關係，</p>
<pre><code>class LinkList {
	constructor(value,prev,next){
		this.head = null 
		this.tail = null
		this.lenght = 1
	} 
	addToHead(){
	} 
}
</code></pre>
<p>Linked List 要能再頭地方加入新的節點成為新的 head，因此加入輔助函式看看：</p>
<pre><code>class LinkedNode {
		constructor(value,prev,next){
				this.value = value;
        this.next = next;
        this.prev = prev;
		} 
} 

class LinkList {
	constructor(value){
		this.head = null 
		this.tail = null
		this.addToHead(value)
		this.lenght = 0
	} 
	addToHead(value){
		const newNode = new LinkedNode(value);
		newNode.next = this.head; // 讓原本的 head 成為新節點的 next
		newNode.prev = null // head 並沒有前一個節點 
		this.head = newNode // 最後把原來的 head 換成新的節點
		
		this.lenght += 1
		return this.head
	} 
}

let newList = new LinkList('first')
newList.addToHead('second')
newList.addToHead('third') 

newList.head.value // third 
newList.head.next.value  //second
newList.head.next.next.value //first
</code></pre>
<p>接下來我們再實作一個可以從中間刪除任意節點的方法，要找到 Linked List 的某一個數值並且刪除，就只能用尋訪的方式一個一個尋找，這裡我們用 while 回圈以一個類似遞迴的方式來尋找：</p>
<pre><code>class LinkList {
	constructor(value){
		this.head = null 
		this.tail = null
		this.addToHead(value)
		this.lenght = 0
	} 
	addToHead(value){ ...	} 
	removeFromHead(){
			if(!this.head.next) this.head.next = null
			const value = this.head.value;
			this.head = this.head.next 
			this.length-- 
			return value
	} 
	remove(val) {
    if(this.length === 0) {
        return undefined;
    }
    
    if (this.head.value === val) {
        this.removeFromHead();
        return this;
    }
    
    let previousNode = this.head;
    let thisNode = previousNode.next;
    
    while(thisNode) { 
				// thisNode 的參考會隨著 while 而不斷的往 next 去尋找
        if(thisNode.value === val) {
            break;
        }
        
        previousNode = thisNode; // 同時也會不斷紀錄前一個節點
        thisNode = thisNode.next;
    }
    
    if (thisNode === null) {
        return undefined;
    }
    
    previousNode.next = thisNode.next; // 一旦成功找到要刪除的節點，才能夠順利銜接前後節點，達到刪除的效果
    this.length--;
    return this;
}
}
</code></pre>
<p>示範實做跟說明幾個函式到這邊，基本上只要知道怎麼修改節點的指向，就可以了解怎麼實作這些操作 Linked List 的方法，包括從 head 刪除節點、從中間新增、刪除節點，以及從最後面新增、刪除，讀者可以自己練習完成看看。</p>
<h2 id="tree"><a class="header-anchor" href="#tree"></a>Tree</h2>
<p>樹的結構跟 Linked List 有點像，也是從一個節點開始往下長，差別在於 Linked List 裡一個節點只能對到另一個節點，而在樹狀結構內，一個節點可以對到好幾個其他節點，也稱為子節點（ Child Node ) ，之前我們講到的 DOM ，正是一種樹狀結構，最上層的 <code>html</code> 是上層節點，而往下延伸出 <code>body</code> 與 <code>head</code> 等下層子節點。</p>
<p>而樹的結構也可以被加上特殊的規則，例如常聽見的<strong>二元樹結構，</strong> 就是從樹狀結構演變而來，因為在二元樹裡面，每個節點被規定只能擁有另外兩個子節點。而且左邊子節點的數值只能小或等於父節點的數值，而右邊子節點的數值必須大於父節點的數值，以這樣子排列方式，我們就可以有規律的去搜尋或是操作我們需要的節點，例如，整個二元樹的最小值可以在最左邊且最後代的子節點被找到，反之在最右邊後代節點則可以找到最大值。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580EJC2fUxHnF.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580EJC2fUxHnF.jpg"></p>
<p>在樹的搜尋上則有兩種相似的方式：</p>
<ol>
<li>
<p>深先搜尋 ( Depth-First Traversal, DFT ) ：</p>
<p>把樹想成由最上面開始往下生長的結構，深先搜尋就是從最上面的根節點，往下垂直的搜尋，深先搜尋裡又分為三種走訪順序，以上面的二元樹圖為例，分別是：</p>
<ul>
<li>
<p>前序 （ Pre Oreder ) ：</p>
<p>順序：訪問根節點 → 訪問左子樹 → 訪問右子樹</p>
<p>上圖順序： A → B → D → G → C → E → F → H</p>
</li>
<li>
<p>中序 ( In Order ) ：</p>
<p>順序：訪問左子樹 → 訪問根節點 →訪問右子樹</p>
<p>上圖順序： D → G → B → A → E → C → F → H</p>
</li>
<li>
<p>後序 （ Post Order ）：</p>
<p>順序：訪問左子樹 → 訪問右子樹 → 訪問根節點</p>
<p>上圖順序： G → D → B →  E → H → F  → C → A</p>
</li>
</ul>
</li>
<li>
<p>廣先搜尋 Breadth-First Traversal , BFT )</p>
<p>廣先搜尋則跟深先搜尋相反，是以水平方向為主的搜尋方式，在樹狀結構裡面，每往下長出一個子節點，就會被視為一層。深先搜尋在執行時是先查看節點有無子節點，如果有的話就盡量往下去搜尋，而廣先搜尋則是在搜尋時先檢查子節點有無其他同一層的節點，然後將這些同層子節點記錄下來，一個一個去搜尋，因此在執行廣先搜尋時，必須用到 Queue 來輔助。</p>
<p>上圖順序： A → B → C → D → E → F → G → H</p>
</li>
</ol>
<p>樹狀結構與前面鍊狀串列結構實作方法相似，而且樹狀結構若要往下探討可以有很多種變形，例如把不同層的節點串在一下之後就會變成複雜的圖 ( Graph )，這些內容多到可以再寫一篇文章，因此在這邊先不提供範例。</p>
<h2 id="hash-table"><a class="header-anchor" href="#hash-table"></a>Hash Table</h2>
<p>雜湊表是根據鍵值 （ Key ) 來查找對應記憶體位置的資料結構。陣列就是一個很類似 Hash Table 的結構，只不過陣列是利用「索引」來查找資料，因此只能是數字。</p>
<p>可以把 Hash Table 想成是建立在陣列上，透過將不同字串轉成對應的陣列索引來查找，而達到比較靈活的鍵值查找，要達到這樣子的效果，我們會需要實作一個 Hash Function ，來把字串轉換成索引。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580GqUPG5Zh4e.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580GqUPG5Zh4e.jpg"></p>
<p>Hash Function 的運作方式大概會是給每個字元對應的可運算數值，當要查找的時候就把字串內所有字元的數值加起來然後給陣列當成索引值，如果加起來的數值太大，陣列沒有那麼多空間，就必需透過另外的規則簡化（如：加完的數值 mod 10 ) 來取得對應、可行的索引。</p>
<pre><code>getCharNum(char){
	return charCodeAt(char)
}
hashFunction (key) {
	let hashCode = 0 	
	key.split('').forEach(char=&gt;{
		hashCode  += getCharNum(char)		
	}) 	
	return hashCode % 10 
} 
</code></pre>
<p>上面是一個 hash function 的實作，當然這只是簡化的範例而已，真正應用在現代系統環境的實作邏輯複雜非常多。透過 Hash Table 的運作方式我們可以利用字串來存取對應的數值，有沒有覺得很熟悉，想到什麼？沒錯就是 JS 的物件！從結果來看 JS 的物件非常像是 Hash Table 的結構，不過根據我的調查結果，有一說是這點會根據 JS 引擎的實作而有所差異，有些引擎裡面是透過混合 Linked List 跟 Hash Table 兩種資料結構來實作物件。</p>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>終於講完了這些常見的資料結構，看完之後你應該可以發現這些資料結構大概有一半在前面 JS 相關內容都有提到，分別是：</p>
<ul>
<li><strong>Stack</strong> ：Call Stack</li>
<li><strong>Queue</strong> ：Task Queue</li>
<li><strong>Linked Lists</strong> ：原型鍊</li>
<li><strong>Tree</strong> : DOM</li>
<li><strong>Hash Table</strong> : 物件的 鍵 -值 結構</li>
</ul>
<p>這些部分如果不深入去看這個語言運作方式的話是不會發覺的，這些資料結構也可以應用在許多系統資料的運算。雖然這個章節只能很粗淺的介紹，但我希望讓原本不熟悉資料結構的人，下次再看到類似的東西可以不會那麼害怕，也能夠更冷靜地往下研究原本要鑽研的知識細節。</p>
<h2 id="參考文章"><a class="header-anchor" href="#參考文章"></a>參考文章</h2>
<p><a href="%5Bhttps://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c%5D(https://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c)">Data Structures in JavaScript</a></p>
<p><a href="%5Bhttps://codeburst.io/objects-and-hash-tables-in-javascript-a472ad1940d9%5D(https://codeburst.io/objects-and-hash-tables-in-javascript-a472ad1940d9)">Objects and Hash Tables in Javascript</a></p>
<p><a href="%5Bhttps://www.hackerearth.com/zh/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/%5D(https://www.hackerearth.com/zh/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/)"> Basics of Hash Tables </a></p>
<p><a href="%5Bhttps://www.interviewcake.com/concept/java/hash-map%5D(https://www.interviewcake.com/concept/java/hash-map)">Hash Table </a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:20.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分鐘 閱讀文 (大約 1773 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-27/">JS 原力覺醒 Day27 - JS 常用 API - Object.assign &amp;&amp; Object.defineProperty</a>
            
        </h1>
        <div class="content">
            <p>今天要講的是是兩個在操作物件時常用到的 JS API ，有時候我們會需要做一些比較進階的操作，例如對物件屬性做一些比較細節的微調；還有複製物件，但是複製物件的話，因為物件傳參考的特性的關係，在結構複雜的物件上，往往需要特別處理，例如物件內的屬性是另外一個物件。所以我們也會帶到「深拷貝」和「淺拷貝」的概念。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Object.defineProperty</li>
<li>Object.assign</li>
<li>深拷貝</li>
<li>淺拷貝</li>
</ul>
<h2 id="object-defineproperty"><a class="header-anchor" href="#object-defineproperty"></a>Object.defineProperty</h2>
<p><code>Object.defineProperty</code> 其實是 <code>Object</code> 函式建構子上的靜態方法（還記得 Obejct  其實是一個函式？），用來對某個物件直接定義一個新的屬性，用法如下：</p>
<pre><code>const object1 = {};

Object.defineProperty(object1, 'property1', {
  value: 42,
  writable: false
}); 
</code></pre>
<p>這個方法接受三個參數，<strong>第一個是要新增屬性的目標物件，第二個是屬性名稱，第三個是這個屬性的描述器設定。</strong> 屬性的描述器？那是什麼？</p>
<p>JS 內物件屬性的描述器有兩種類型，每一種各有不同設定值：</p>
<ul>
<li>
<p><strong>資料描述器 ( Data descriptor )：</strong></p>
<p>資料描述器是一個帶有值的屬性，其實也就是你要定義屬性的 <code>value</code> 啦。這個屬性有可能是可修改、或是不可被修改的。</p>
</li>
<li>
<p><strong>存取描述器 ( Accessor descriptor )：</strong></p>
<p>存取描述器定義的內容包含的 <code>getter</code> 與 <code>setter</code> 兩個函式。要怎麼存、取這個屬性，就是由存取描述器來負責的。</p>
</li>
</ul>
<p>兩種描述器都有屬於自己的屬性設定值，先分別介紹：</p>
<ol>
<li>資料描述器上，有兩個可選值：</li>
</ol>
<ul>
<li><strong>value ( undefined )</strong> : 定義這個屬性對應的值。</li>
<li><strong>writable （ false ）</strong>:  定義這個屬性是某可以被指派，如果為 <code>true</code> 就代表這個屬性可以透過  如 <code>ob.name= 'new value'</code> 被更新。</li>
</ul>
<ol start="2">
<li>存取描述器上也有兩個可選值：</li>
</ol>
<ul>
<li><strong>get ( undefined )</strong> : 即物件的 <code>getter</code> 函式，是一個定義物件如何被取用的函式，當物件屬性被取用的時候會被呼叫。</li>
<li><strong>set ( undefined )</strong>  : 即物件的 <code>setter</code> 函式，是一個定義物件如何被指派的函式。</li>
</ul>
<p>剩下的幾個設定值是兩種描述器都能夠使用且可選、非必須的。分別是（ 括號內的是預設值 ）：</p>
<ul>
<li><strong>configurable ( false )</strong> : 定義了這個物件屬性的描述器設定是否可以被修改，如<code>enumerable</code> 、 <code>writable</code> 、 或是自己本身 <code>configurable</code> 。</li>
<li><strong>enumerable  ( false )</strong> : 定義這個屬性在物件裡就屬於可以被巡訪的，也就是使用 <code>Object.keys</code> 或是 <code>for...in</code> 來對物件作遍歷的時候能不能夠存取到。</li>
</ul>
<p><strong>而要定義的物件屬性的描述器必須一定要是上述兩者中的其中一種，兩者無法同時屬於兩者。</strong></p>
<h3 id="example-描述器預設值"><a class="header-anchor" href="#example-描述器預設值"></a>Example - 描述器預設值</h3>
<pre><code>var o = {}; // 創造新物件 

Object.defineProperty(o, 'a', {}); // empty descriptor setting

Object.getOwnPropertyDescriptor(o,'a')  
//預設描述器值：
// configurable : false 
// value : undefined 
// writable : false 
// enumable : false 
</code></pre>
<p>剛剛說描述器無法同時是資料描述器跟存取描述器，也就是說在 ****<code>defineProperty</code> 的第三個參數描述器設定內，如果有 <code>get</code> 這個設定值出現，就不能再有 <code>value</code> ，否則就會報錯：</p>
<pre><code>var o = {}; // 創造新物件 

Object.defineProperty(o, 'a', {
  value: 37,
  writable: true,
  enumerable: true,
  configurable: true,
	get(){
		return 123
	}
});

//Invalid property descriptor. Cannot both specify accessors and a value or writable attribute
</code></pre>
<h3 id="example-自訂-getter-與-setter-函式"><a class="header-anchor" href="#example-自訂-getter-與-setter-函式"></a>Example - 自訂 <code>getter</code> 與 <code>setter</code> 函式</h3>
<p>自訂 <code>getter</code> 與 <code>setter</code> 一樣是在  <code>Object.defineProperty</code> 裡面的第三個參數自訂屬性的行為：</p>
<pre><code>var o = {}; 
Object.defineProperty(o, 'a', {
		get() {
        return 'It will return this value if I access o.a' ;
    },
    set() {
        this.myname = 'this is my name string';
    }
});
</code></pre>
<h2 id="object-assign"><a class="header-anchor" href="#object-assign"></a>Object.assign</h2>
<p><code>Object.assign</code> 用來複製所有物件內可被尋訪 (Enumable) 的屬性，而且複製的來源不限於某個物件，可以多個物件一起進行屬性的複製，這個方法的第一個參數跟 <code>defineProperty</code> ㄧ樣都是目標物件，後面可以有複數個參數，就是要被複製屬性的來源。而使用 <code>Object.assign</code> 來進行複製的時候，後面的相同物件屬性會蓋掉前面相同的物件屬性：</p>
<pre><code>let b = Object.assign({foo: 0}, {foo: 1}, {foo: 2});
ChromeSamples.log(b)
// {foo: 2}
</code></pre>
<p>所以，如果我想要複製某一物件的內容到一個全新的物件上的話，只要這麼寫：</p>
<pre><code>let oldObject = {
	a:'a', 
	b:{
		c:'cinsideb'
	}
} 

let newObject = Object.assign({},oldObject)

console.log(newObject) //{a: &quot;a&quot;, b: {…}}
</code></pre>
<p>另外，如果只是單純要把某個物件內容複製到另外一個物件，可以用 ES6 後的新的、比較簡潔好閱讀的寫法 Spread ，也可以達到一樣的效果：</p>
<pre><code>let newObject = { ...oldObject }
</code></pre>
<h2 id="淺拷貝-shallow-copy"><a class="header-anchor" href="#淺拷貝-shallow-copy"></a>淺拷貝 ( Shallow Copy )</h2>
<p>在使用 <code>Object.assign</code> 時有一個要注意的地方，就是他雖然可以複製屬性，但要是物件屬性的內容也是另外一個物件時，從這個屬性複製到新物件上的，也只會是這個內層物件的參考，而不是這個物件的拷貝，這個現象就稱為淺拷貝（可以理解為，只複製最外層屬性，往下被複製的都只有參考）。</p>
<pre><code>let oldObject = {
	a:'a', 
	b:{
		c:'c'
	}
} 

let newObject = Object.assign({},oldObject)

newObject.b.c = 'modified c' 

console.log(oldObject) 
/* {
	a:'a', 
	b:{
		c:'modified c'
	}
} */
</code></pre>
<p>由上就可以看出，當我修改新的物件的內層屬性物件時，被複製的物件的內層屬性物件 (<code>b.c</code>)，也會跟著一起被改動。</p>
<h2 id="深拷貝-deep-clone"><a class="header-anchor" href="#深拷貝-deep-clone"></a>深拷貝 （ Deep Clone )</h2>
<p>相對於淺拷貝，深拷貝就是完全的複製整個物件內容了。那麼如果要達到這個效果，我們可能要自己動手處理，檢查要複製物件的某屬性是不是物件，如果是的話，就要再以<code>Object.assgn</code> 複製一次，並且這個檢查要搭配遞迴的概念來檢查，才能確保完全的複製。</p>
<pre><code>function cloneDeep(obj){
            if( typeof obj !== 'object'  ){
                return obj
            }
            let resultData = {}
            return recursion(obj, resultData)
        }

function recursion(obj, data={}){
						//對物件屬性做巡訪
            for(key in obj){
                if( typeof obj[key] === 'object'){
										// 如果是物件就繼續往下遞迴
                    data[key] = recursion(obj[key])
                }else{
										// 如果不是物件的話就直接指派
                    data[key] = obj[key]
                }
            }
            return data
        }
let player = {name:'Anakin',friend:{robot:'R2D2'}}
let player2 = cloneDeep(player)
obj.name = 'Darth Vader!!!'
player2.friend.robot = 'no!!!'
console.log(player) // {name:'Anakin猿',friend:{robot:'R2D2'}}
</code></pre>
<h2 id="參考文件"><a class="header-anchor" href="#參考文件"></a>參考文件</h2>
<p><a href="%5Bhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description%5D(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description)"> MDN 官方文件的說明 </a></p>
<p><a href="%5Bhttp://arqex.com/967/javascript-properties-enumerable-writable-configurable%5D(http://arqex.com/967/javascript-properties-enumerable-writable-configurable)"> Javascript properties are enumerable, writable and configurable</a></p>
<p><a href="%5Bhttps://kanboo.github.io/2018/01/27/JS-ShallowCopy-DeepCopy/%5D(https://kanboo.github.io/2018/01/27/JS-ShallowCopy-DeepCopy/)">JS-淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy)</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:18.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    9 分鐘 閱讀文 (大約 1322 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-26/">JS 原力覺醒 Day26 - 常用 API： setTimeout / setTimeInterval</a>
            
        </h1>
        <div class="content">
            <p>來講一下常用到的瀏覽器 API ，其實前面在講 Event Queue 的時候就已經提過 setTimeout 了，不過這邊就讓我們從更具實用性的層面來看這些方法。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>setTimeout / setInterval  使用</li>
<li>setTimeout / setInterval  清除</li>
<li><code>this</code> in  setTimeout / setInterval callback</li>
<li>解決回呼函式內 this 的問題</li>
<li>setTimeout / setInterval 、迴圈與 Closure</li>
</ul>
<h2 id="settimeout-setinterval-使用"><a class="header-anchor" href="#settimeout-setinterval-使用"></a>setTimeout / setInterval  使用</h2>
<h3 id="settimeout"><a class="header-anchor" href="#settimeout"></a>setTimeout</h3>
<p>前面有提到 setTimeout 的基本使用方式，而第一個參數傳入的 callback 會被推送到 Event Queue ，待主執行環境堆疊清空以後，才會被執行 ，所以就算第二個參數設定的時間是 0 秒，也不會立刻執行。</p>
<pre><code>function step(stepNum){
	console.log(`step${stepNum}`)
}

step('1') 
setTimeout(function(){step('2')},0)
step('3')

// will print: step1 --&gt; step3 --&gt; step2
</code></pre>
<h3 id="setinterval"><a class="header-anchor" href="#setinterval"></a>setInterval</h3>
<p>setInterval 使用方式與 setTimeout 的語法相同，差在 setTimeout 只會執行一次，而 setInterval 則會根據開發者給的時間間隔，每隔一段時間執行一次。</p>
<pre><code> setInterval(function(){console.log('da')  },1000)
// print : da -&gt; da -&gt; da
</code></pre>
<h2 id="settimeout-setinterval-清除"><a class="header-anchor" href="#settimeout-setinterval-清除"></a>setTimeout / setInterval  清除</h2>
<p>由於 <code>setTimeout</code> /  <code>setInterval</code> 函式本身會回傳一個計時器 id ，我們就可以把這個 id 記錄下來，當頁面要離開用不到的時候使用 <code>clearTimeout</code> / <code>clearInterval</code> 將他們清除：</p>
<pre><code>let timerId = setInterval(function(){
	console.log('do something') 
},1000) 
</code></pre>
<p>清除計時器在以前可能還不是會非常被注重的問題，但是像現在主流前端框架把渲染工作交給 JS ，如果使用虛擬路由來控制頁面切換的話，就算頁面切換了，JS 檔案也不會重新載入，主執行環境會一直存在，因此前面設定的計時器在不需要時如果沒有清除，就可能會造成頁面運算的負擔。</p>
<h2 id="this-in-settimeout-setinterval-callback"><a class="header-anchor" href="#this-in-settimeout-setinterval-callback"></a><code>this</code> in  setTimeout / setInterval callback</h2>
<p><code>setTimeout</code> / <code>setInterval</code> 裡第一個回呼函式內的 <code>this</code> 如果沒有經過處理的話，預設都是指向全域環境 <code>window</code> ，因為這兩個都是屬於 <code>window</code> 物件底下的函式，我們可以推斷我們傳進去的回呼函式是在裡面被執行。雖然沒辦法直接看到 setTimeout 裡面的原始碼，不過可以推斷內容大概是像這樣 ，下面以 Pseudo code 示意：</p>
<pre><code> window  = {
		... 
		setTimeout:function(timerFunc,time){
			//several minutes later...
			timerFunc() 
		} 
}
</code></pre>
<p>之前提過在思考 <code>this</code> 的連結的時候，有提到，「如何呼叫」函式將會影響 <code>this</code> 的指向，想一想「隱含」的繫結， 再對比上面的 <code>setTimeout</code> 內容，可以看出我們傳入的回呼函式在 <code>setTimeout</code> 被呼叫，但因為是直接呼叫，沒有隱含繫結，因此在內的 <code>this</code> 會指向全域。</p>
<h2 id="解決回呼函式內-this-的指向問題"><a class="header-anchor" href="#解決回呼函式內-this-的指向問題"></a>解決回呼函式內 this 的指向問題</h2>
<p>承上一段，那要怎麼樣才能讓 <code>this</code>  指向目前所屬的執行環境，讓開發者在撰寫程式碼的時候更不容易誤解？</p>
<h3 id="方法一"><a class="header-anchor" href="#方法一"></a>方法一</h3>
<p>有一個方法是：使用箭頭函式，因為箭頭函式內沒有 <code>this</code> ，更準確來說， 箭頭函式內的 <code>this</code> 與他外部語彙範疇的 <code>this</code> 相等。</p>
<pre><code>let boss = 'Yoda'
let user = {
	name:'Luke',
	introduce:function(){
		setTimeout(()=&gt;{
			console.log('hey, ' + this.name) 
		},1000) 
	} 
} 
user.introduce() // print : hey,Luke
</code></pre>
<h3 id="方法二"><a class="header-anchor" href="#方法二"></a>方法二</h3>
<p>另外一個方法是，使用 <code>Function.bind</code>，這個方法跟 <code>call</code> 或 <code>apply</code> 都可以指定函式執行環境內要綁定的 <code>this</code> ，差別在呼叫 <code>bind</code> 後會回傳一個全新、綁定過 <code>this</code> 的函式。</p>
<pre><code>let user = {
	name:'Luke',
	introduce:function(){
		setTimeout(getName.bind(this),1000) 
	} 
} 

function getName(){
	console.log('hey, '+ this.name)	
} 

user.introduce() // print : hey,Luke
</code></pre>
<h2 id="settimeout-setinterval-迴圈與-closure"><a class="header-anchor" href="#settimeout-setinterval-迴圈與-closure"></a>setTimeout / setInterval 、迴圈與 Closure</h2>
<p>這段要講的大概是最經典的面試考題，只要講到跟 Closure 有關的問題，通常一定會提到迴圈。<br>
先來看這段例子：</p>
<pre><code>for(var i =0;i&lt;10;i++){
	setTimeout(
		function (){
			console.log(i)
	},1000) 
}
</code></pre>
<p>在一秒過後我們就很驚訝的會發現， JS 吐出了 10 個 <code>10</code> 給我們，這是因為 <code>var</code> 宣告是屬於 <code>function scope</code> 但是 <code>for</code> 迴圈並不是 <code>function</code> ，所以在之內宣告的變數 <code>i</code> 就等於是全域變數。也因此無法透過 <code>fucntion</code> 產生函式執行堆疊或閉包，於是這個回呼函式會被推到 Event Queue，待時間到要執行，去獲取<code>i</code> 的時候，全域的 <code>i</code> 早就已經被 <code>for</code> 迴圈修改而成為<code>10</code>了 ，所以才會有這樣子的結果</p>
<h3 id="解方："><a class="header-anchor" href="#解方："></a>解方：</h3>
<p>要解決這個問題我們只要想辦法讓維持 setTimeout 回呼函式與每個 i 的聯繫即可，還記得 <code>let</code> 屬於 <code>block scope</code>  ？所以用 <code>let</code> 產生的變數是綁在會在不同的 block 上 ，對 <code>for</code> 回圈來說，每次 <code>i+1</code> 的迴圈迭代之後的，都是一個新的 block，再搭配 <code>block scope</code> 的特性，就可以在每個 <code>block</code> 留下與每個 <code>i</code> 的連結：</p>
<pre><code>for(let i =0;i&lt;10;i++){
	setTimeout(
		function (){
			console.log(i)
	},1000) 
}

// print : 1,2....10
</code></pre>
<p>或是ㄧ樣利用 <code>function scope</code> 的特性：</p>
<pre><code>for(var i=0;i &lt; 10; i++){
	getValueOf_i(i)
}

function getValueOf_i(i){
	setTimeout(function(){
		console.log(i)
	},1000) 
} 
</code></pre>
<p>這樣一來當 <code>i</code> 以參數形式傳入另外一個函式時，就會被函式執行環境保留而產生閉包。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:16.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分鐘 閱讀文 (大約 1864 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-25/">JS 原力覺醒 Day25 - CRP : 關鍵渲染路徑</a>
            
        </h1>
        <div class="content">
            <p>當使用者進入頁面、瀏覽器收到請求並回傳前端相關檔案後，到最後使用者看到的畫面呈現之前，還有很多步驟會被執行，這一連串步驟的總和就稱為 Critical Rendering Path ( 中譯：關鍵渲染路徑），了解關鍵渲染路徑，在網站前端頁面需要做效能優化時，就可以比較容易知道，要從哪裡下手。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<p>關鍵渲染路徑（以下簡稱 CRP ) 大致上會執行以下六個步驟：</p>
<ol>
<li>建構 DOM Tree</li>
<li>建構 CSSOM Tree</li>
<li>執行 JavaScript</li>
<li>創造渲染樹</li>
<li>產生畫面佈局</li>
<li>繪製、產生畫面</li>
</ol>
<p>下面就讓我們一個步驟一個步驟詳細來看：</p>
<h2 id="step1-建構-dom-tree"><a class="header-anchor" href="#step1-建構-dom-tree"></a>Step1. 建構 DOM Tree</h2>
<p>前一章節有講到網頁的 DOM 是根據 HTML 內容而來，這個轉換的過程有點像這個系列一開頭我們討論 JS 語法解析那段，瀏覽器會根據 HTML Tag 將內容轉為一個一個 Token （標記）</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191010/201065802PnTTlOshi.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191010/201065802PnTTlOshi.jpg"></p>
<p>之後會根據這些 Token 將對應的標籤轉換成節點，之後根據 Token 的前後關係產生出 DOM Tree  。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191010/20106580peW9V1tTe4.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191010/20106580peW9V1tTe4.jpg"></p>
<h2 id="step2-建構-cssom-tree"><a class="header-anchor" href="#step2-建構-cssom-tree"></a>Step2.  建構 CSSOM Tree</h2>
<p>CSSOM ( CSS Object Model ) 是代表跟 DOM 元素對應樣式的物件。他的表現形式跟 DOM 很像，只是 CSSOM 是依附著每個節點，各個節點都會有對應的樣式 ( Style )，所以基本上 CSSOM Tree 跟 DOM Tree 長的會很像。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191010/20106580iAbwkUacyT.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191010/20106580iAbwkUacyT.jpg"></p>
<p>這邊要注意的是，CSS 在頁面載入行為裡，是屬於鎖定渲染的資源( Render Blocking Resource ），意思是，在頁面仔入時，只要還沒有拿到所有的 CSS 檔案並成功載入，那瀏覽器就會等到完成載入為止，這意味著，每個網頁上的  CSS 檔案，都會拖到載入速度。</p>
<p>除了 Render Blocking ，也有人說 CSS 是 「Script Blocking 」，因為在瀏覽器載入所有的 CSS 檔案之後，瀏覽器才會進入的我們的下一步「執行 JS」。 在產生 CSSOM 時，越多層的選擇器，在元素與樣式的匹配上會需要更多時間來進行。以下面這兩個 CSS 類別為例：</p>
<pre><code>A : p {  color:red; } 

B : div h1 { font-size:22px;}
</code></pre>
<p>第二種 B 情況的 CSS 會需要更多時間來做匹配，首先瀏覽器會先找到頁面上所有的 <code>h1</code> 元素，而後在看這個元素的父類別是不是一個 <code>div</code> 元素 ，因此瀏覽器在匹配樣式時其實是以「從右邊到左邊」的順序來進行的，所以現在你就了解，如果你有加速前端渲染速度的請求，就要減少 CSS 選擇器層級的長度，在這方面，BEM 的 CSS 命名撰寫風格就把層級關係透過命名的方式來表達，同時也大幅度的減少選擇器的少用次數，建議對 CSS 有興趣鑽研的人一定要看一下。</p>
<p>類似的命名風格或規範，除了 BEM 之外還有 OOCSS 跟 SMACSS ，這些規範都是透過一些原則，來達到最大程度的減少重複，除了好維護之外，其實也能提升畫面渲染的效率，這也是為什麼這些規範常常被資深前端人員提起、並視為圭臬的原因。</p>
<h2 id="step3-執行-js"><a class="header-anchor" href="#step3-執行-js"></a>Step3.  執行 JS</h2>
<p>JS 則是鎖定轉譯，在 JS 執行完之前，瀏覽器都不會繼續做 HTML 文件的轉譯跟建構。當瀏覽器轉譯時碰到 <code>&lt;script&gt;</code> ，他會停下來等到 JS 執行完成之後才會再往下。這也是為什麼我們常常說要把 &lt;<code>script&gt;</code> 標籤放到整個網頁最後面的原因。</p>
<h2 id="step4-創造渲染樹"><a class="header-anchor" href="#step4-創造渲染樹"></a>Step4.  創造渲染樹</h2>
<p>渲染樹 (Rendering Tree) 其實就是 DOM 搭配 CSSOM 的結果，在用白話一點的方式來說，就是「<strong>最後會被渲染在畫面上」的結構樹</strong>，所以如果 CSS 樣式導致某個 Node 沒辦法顯示，（ 如<code>display:none</code> )，那麼他就不會出現在渲染樹上。</p>
<h2 id="step-5-產生畫面編排-layout"><a class="header-anchor" href="#step-5-產生畫面編排-layout"></a>Step.5 產生畫面編排 ( Layout )</h2>
<p>我們已經取得代表元素層級關係的 DOM 樹結構，也匹配了個元素對應的樣式，最終搭配兩者產生出了渲染樹，現在我們離最後產生可視畫面的階段已經不遠了，但是還差一個步驟，我們還必須弄清楚所有元素的實際位置，以及元素該如何呈現，那就是產生畫面編排 ( Layout ) 的步驟。</p>
<p>Layout 產生的方式，會跟 <code>meta tag</code>  裡面的 viewpoint 屬性有很大的關係：</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
</code></pre>
<p><code>viewpoint</code> 的 <code>meta</code> tag 用來告訴瀏覽器，頁面要怎麼縮放，還有維度，就是指畫面像素（瀏覽器畫面）跟螢幕像素（硬體）的比例，<code>content</code> 之中，<code>width</code> 用來設定瀏覽器畫面寬度是多少，把他設定成 <code>device-width</code> 的話就是在告訴瀏覽器，畫面顯示的螢幕寬度要跟硬體裝置相同（手機、電腦），如果沒給 <code>width</code> 值的話，瀏覽器就會使用預設的 <code>980px</code> 來當作預設的畫面顯示寬度。這個屬性在 HTML5 後出現，常用在 RWD 的設計實作之中。 <code>initial-scale=1.0</code> 是指預設的縮放程度，最常見的值也是預設值，就是 <code>1</code> 。</p>
<h2 id="step6-繪製-產生畫面"><a class="header-anchor" href="#step6-繪製-產生畫面"></a>Step6. 繪製、產生畫面</h2>
<p>到最後一個步驟，瀏覽器進入到了繪製階段，前面提到一連串很抽象的設定跟結構，終於可以被轉換成一個個像素，繪製階段所花的時間會跟 DOM 結構樹 與 CSSOM 樹的大小、規模有關，越複雜的結構或是樣式就會需要更多時間，應該不難理解。</p>
<h2 id="從開發者工具看渲染順序"><a class="header-anchor" href="#從開發者工具看渲染順序"></a>從開發者工具看渲染順序</h2>
<p>我們透過瀏覽器的檢查工具，也能看出上面講的 CRP 六個步驟，是不是真的依照順序進行，以 Chrome 為例子，打開開發者工具，並切換到 Performance 之後，按下錄影，重新整理之後結束錄影，就能夠看到這段時間內瀏覽器是怎麼產生畫面的：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191010/20106580UtQhk3zM67.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191010/20106580UtQhk3zM67.jpg"></p>
<p>對應前面步驟說明：</p>
<p>1、2： 拉取資源並解析 DOM 樹</p>
<ol start="3">
<li>
<p>為 index.css 解析 CSSOM 樹</p>
</li>
<li>
<p>執行 JavaScript 檔案 （ index.js )</p>
</li>
<li>
<p>根據 viewpoint 的 meta tag 產生layout</p>
</li>
<li>
<p>繪製螢幕</p>
</li>
</ol>
<h2 id="參考資源"><a class="header-anchor" href="#參考資源"></a>參考資源</h2>
<p>Google 在 Udacity 的教學真的講的蠻仔細的，搭配圖文也能更讓學習者一目瞭然：</p>
<ul>
<li><a href="%5Bhttps://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=zh-tw%5D(https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=zh-tw)">Google 的教學</a></li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:13.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    9 分鐘 閱讀文 (大約 1354 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-24/">JS 原力覺醒 Day24 -  DOM</a>
            
        </h1>
        <div class="content">
            <p>今天要講的是瀏覽器的 DOM 的概念，內容雖然跟 JS 語言比較沒有關係，但是除非你只寫後端 <code>node.js</code> ，否則只要跟介面相關一定會碰到需要處理 DOM 元素的情況出現，今天就讓我們學著好好跟 DOM 相處。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>DOM 是什麼？</li>
<li>畫面是如何透過 DOM 被產生的？</li>
<li>DOM Tree</li>
<li>與 DOM 互動</li>
<li>總結</li>
</ul>
<h2 id="dom-是什麼？"><a class="header-anchor" href="#dom-是什麼？"></a>DOM 是什麼？</h2>
<p>在我們漫長的前端職涯中，每位前端開發者心中都一定曾經出現過、或是被問過這個問題，那就是到底什麼什麼是 DOM 呢？我們都知道 HTML 是透過標籤式的語法來描述網頁中元素與元素的關係，一對標籤通常就代表一個元素，而且標籤又可以放在另外一個標籤之內，因此元素之間是會有上下層級的，而 DOM 呢，就是透過<strong>把這樣子的層級結構轉換為對應的「物件」而成的關係模型</strong>。</p>
<p>DOM 並不是只能透過 HTML 產生，其他類似的語法像是 SVG、XML 這裡的物件並不一定要是 JS 的物件，因為，但是在瀏覽器裡面，是的，這裡我們討論的物件就是 JS 裡的物件，例如我們在操作 DOM 元素時最常用到的 <code>document</code> 物件。</p>
<pre><code> document.createElement('div')
</code></pre>
<p>所以，我認為DOM 是：</p>
<blockquote>
<p>將HTML文本的複雜層級關係，轉換成以物件結構的方式來表現 ，讓程式語言得以與之溝通。</p>
</blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191009/201065801mBHZYtbqQ.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191009/201065801mBHZYtbqQ.jpg"></p>
<h2 id="畫面是如何透過-dom-被產生的？"><a class="header-anchor" href="#畫面是如何透過-dom-被產生的？"></a>畫面是如何透過 DOM 被產生的？</h2>
<p>因為 HTML 語法大部分都是是成雙成對且有層級關係的標籤，而在使用者透過瀏覽器進入網頁，瀏覽器開始讀取 html 檔案，<strong>就會開始把開發者寫的 HTML 程式碼（即指  Document ) 內容轉成對應的層級關係結構</strong>，所以這種結構才會被稱為 Document Object Model （文件-物件模型）。從使用者進入網頁，到顯示最後使用者的畫面之前，會經歷許多步驟，不過大致上可分為兩個階段：</p>
<ul>
<li>第一階段：瀏覽器會先讀取 HTML 程式碼，並決定最後要渲染在網頁上的內容</li>
<li>第二階段：瀏覽器實際開始渲染，形成最後看得見的畫面</li>
</ul>
<p>第一階段執行玩後的結果稱為「渲染樹 ( Render Tree )」，渲染樹就是用來表現會被渲染到最終畫面上的 HTML 元素，還有他們的關係與 CSS 樣式，要完成渲染樹，瀏覽器會需要兩樣東西：</p>
<ol>
<li>DOM ：用來表現 HTML 元素的層級關係</li>
<li>CSSOM： 整個網頁內HTML 元素對應樣式的關聯</li>
</ol>
<h2 id="dom-tree"><a class="header-anchor" href="#dom-tree"></a>DOM Tree</h2>
<p>DOM 裡面用來表現元素層級關係的物件又稱為「 節點樹 ( Node Tree) 」，他會有這樣子的名稱是因為結構都是從最上層的某個元素，例如  <code>&lt;body&gt;</code> ，往下慢慢延伸、長出許多的分支，整個結構就像是樹一樣，透過這樣子的關係表現形式，程式語言（JS) 與畫面表現 (HTML) ，才得以互相溝通。以下面這個 <code>html</code> 內容為例：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;DOM Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
		&lt;h1&gt;	It's All About DOM &lt;/h1&gt;
		&lt;p&gt;Hello World!!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191009/20106580zqwZaavHgD.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191009/20106580zqwZaavHgD.jpg"></p>
<p>HTML 中，在另外一個元素標籤裡面的元素就是該元素的子元素，如 <code>&lt;html&gt;</code> 元素在最上層，所以其他包含在這個元素裡面的都是他的子元素，而這些元素內又會有其他包含的元素，如此重複、不斷往下堆疊，**而把每個元素都看成一個節點的話，就會形成 DOM 的結構樹 ( DOM Tree) 。而每個樹的節點在也都對應為一個物件，**如此一來 JS 才能透過 瀏覽器的 API 如 <code>document. querySelector</code> 跟每個元素互動或溝通。</p>
<h2 id="與-dom-互動"><a class="header-anchor" href="#與-dom-互動"></a>與 DOM 互動</h2>
<p>透過 JS 我們可以跟 DOM 互動來改變畫面的呈現，或是新增一些互動的功能，像是：</p>
<ul>
<li>改變或刪除 DOM 元素</li>
<li>修改元素的 CSS 樣式</li>
<li>讀取及修改 DOM 元素上的屬性 ( id 、 class 、 src 這些標記性的內容）</li>
<li>創造新的 HTML 元素到 DOM 裡面</li>
<li>在 DOM 元素上新增監聽事件（如：點擊）</li>
</ul>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>## 總結</h2>
<p>今天我們了解了什麼是 DOM ，DOM 是從開發者寫的 HTML 程式碼轉換而來，但 HTML 語法本身並不是 DOM ，而瀏覽器就是因為透過 DOM ，才能讓 JS 跟畫面的元素溝通。下一篇，我會講解從使用者進入畫面後，瀏覽器是怎麼從生成 DOM ，然後透過一連串的處理，最後才顯示畫面的。</p>
<h2 id="參考資源"><a class="header-anchor" href="#參考資源"></a>參考資源</h2>
<p><a href="https://www.youtube.com/watch?v=FIORjGvT0kk">JavaScript DOM Tutorial #1 - Introduction</a></p>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Document_Object_Model"> MDN官方說明 </a></p>
<p><a href="%5Bhttps://javascript.info/dom-nodes%5D(https://javascript.info/dom-nodes)">DOM Nodes</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:11.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分鐘 閱讀文 (大約 1780 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-23/">JS 原力覺醒 Day23 - Class 語法糖</a>
            
        </h1>
        <div class="content">
            <p>講完了原型鍊，現在我們知道如何透過建構函式去做到類似類別的效果，也透過設定物件的 <code>prototype</code> 屬性達到物件的繼承效果， ES6  之後，甚至出現了 <code>class</code> 關鍵字，讓我們可以用更物件導向的方式去撰寫 JS。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Class 基本用法</li>
<li>class 宣告式的防呆機制</li>
<li>透過 class 宣告來達成類別繼承</li>
<li>原型物件方法</li>
<li><code>static</code> 靜態方法</li>
<li>類別建構子內的 <code>super</code></li>
</ul>
<h2 id="class-基本用法"><a class="header-anchor" href="#class-基本用法"></a>Class 基本用法</h2>
<p>原本我們必須要透過建構函式來來模擬類別產生物件，但是因為函式子實在太像是函式了，所以很容易被搞混。在 ES6 後出現了 class 宣告的方式，讓相關功能的程式碼整體變得更物件導向且直觀、更好閱讀許多。使用 class 宣告類別的寫法會要使用比較多一點語法，但與建構函式不會相差太多：</p>
<ul>
<li>建構函式：</li>
</ul>
<pre><code>    function User(name){
    	this.name = name 
    }  
    let user1 = new User(name) 
    
    User.prototype.getName = function (){
    	return this.name
    } 
</code></pre>
<ul>
<li>class 宣告式</li>
</ul>
<pre><code>    class User{
    	constructor (name){
    		this.name = name 
    	}
    	getName(){
    		return this.name
    	}   
    } 
</code></pre>
<p>可以看出使用了 class 宣告以後，原本建構函式的內容還是一樣，只是被移動到 constructor 函式內而已。而原本我們要取用 <code>prototype</code> 才能達成方法的共享，現在也只要直接在 class 內直接宣告就可以了( 是不是真的乾淨很多 ），注意在 <code>class</code> 內的方法宣吿方式跟一般物件屬性的宣告不太一樣，那是 ES6 後出現、用來宣告函式屬性的縮寫，且方法與方法之間不需要以逗號相隔。</p>
<h2 id="class-宣告式的防呆機制"><a class="header-anchor" href="#class-宣告式的防呆機制"></a>class 宣告式的防呆機制</h2>
<p>為什麼前面說使用函式宣告式很容易讓開發者把他跟一般函式搞混呢？因為使用 new 運算子搭配函式來創造實體 ( instance ) 的時候，基本上也是一種<strong>函式呼叫，而且就算沒有加上 <code>new</code> 運算子，函式呼叫還是有效，</strong> JS 不會有提示**，**因此就算真的寫錯了也不容易找到錯誤。而使用 <code>class</code> 來宣告的時候，則只有在使用 <code>new</code> 呼叫的時候，才會有效。</p>
<h2 id="透過建構函式來達成類別繼承"><a class="header-anchor" href="#透過建構函式來達成類別繼承"></a>透過建構函式來達成類別繼承</h2>
<p>還記得前面提過，想要用建構函式來達成繼承的話，有幾個步驟我們必須自己進行：</p>
<ol>
<li>
<p>建構函式的繼承：</p>
<p>為了繼承「前代」建構函式的內容，所以我們必須自己在「後代」建構函式內呼叫前代建構函式 ：</p>
</li>
</ol>
<pre><code>        function Human(race){
        		this.race = race
        }
        
        function User(name,race){
        	this.name = name 
        	Human.call(this,race)
        } 
</code></pre>
<ol start="2">
<li>原型物件的繼承</li>
</ol>
<p>修改「後代」建構函式的原型物件使原本存在其中的 <strong>proto</strong>，屬性從參考 <code>Object</code> 改為參考到前代物件，然後再把原型物件內的函式建構子指回「後代」建構函式，完成原型鍊的串接：</p>
<pre><code>    let User.prototype = Object.create(Human.prototype) 
    User.prototype.constructor = Human
</code></pre>
<h2 id="透過-class-宣告來達成類別繼承"><a class="header-anchor" href="#透過-class-宣告來達成類別繼承"></a>透過 class 宣告來達成類別繼承</h2>
<p><code>class</code> 是 ES6 後出現的語法糖，語法糖簡化了整個類別宣告的過程，透過 <code>class</code> 宣告類別，讓這一切複雜的設定都變得簡單許多！我們不需要再去修改原型物件，也能直接完成繼承的效果了。使用 <code>class</code> 來實現繼承，會需要搭配另外一個關鍵字 <code>extends</code> ，步驟如下：</p>
<ol>
<li>創造要被繼承的類別 <code>Human</code>：</li>
</ol>
<pre><code>    class Human{
    	constructor (race){
    		this.race = race 
    	}
    	getRace(){
    		return this.race
    	}   
    } 
</code></pre>
<ol start="2">
<li>創造後代類別 <code>User</code> ，並搭配 <code>extends</code> 指向 <code>Human</code> ，代表 User 繼承 <code>Human</code> ：</li>
</ol>
<pre><code>    class User extends Human{
    			constructor (name, race) {
            // invoke our parent constructor function. 
            super(race);
    				this.name = name
          }
    } 
</code></pre>
<p>類別建構子<code>constructor</code> 的內容就是原本建構函式的內容；而還記得前面有提到我們必須自己在「後代」建構函式內呼叫「前代」建構函式嗎？現在也不需要這麼麻煩， <code>constructor</code> 內的 <code>super</code> 函式就代表了 被 <code>extends</code> 的 <code>Human</code> 建構函式，所以我只要直接呼叫 <code>super</code> 就可以了。</p>
<h2 id="原型物件方法"><a class="header-anchor" href="#原型物件方法"></a>原型物件方法</h2>
<p>使用建構函式，我們可以在原型物件上新增共享的方法，在 <code>class</code> 宣告中當然也做得到，其實就是在 <code>constructor</code> 外定義的方法，其實前面已經有提過了：</p>
<pre><code>    class Human{
    	constructor (race){
    		this.race = race 
    	}
    	getRace(){ // will be set on the prototype object
    		return this.race
    	}   
    } 
</code></pre>
<h2 id="static-靜態方法"><a class="header-anchor" href="#static-靜態方法"></a><code>static</code> 靜態方法</h2>
<p>靜態方法是物件導向裡面的概念。靜態方法只能由類別本身取得的方法，在產生出來的實例 ( instance ）中是無法取得的。<code>static</code> 和 <code>class</code> ㄧ樣是語法糖，使用 <code>static</code> 關鍵字定義的方法，會直接被指派到該 <code>class</code> 上，所以就只能從該類別上直接取得，像是這樣：</p>
<pre><code>    class User {
    	constructor(name){
    		this.name = name
    	}
    	static getUserType (){
    		return 'technical'
    	}
    } 
    
    User.getUsertype() //'techical'
</code></pre>
<p>對應前面的建構函式，就有一點像是這樣：</p>
<pre><code>    function User (name){
    	this.name = name
    }
    User.getUserType  = function(){
    		return 'technical'
    }
</code></pre>
<p>如果從建構函式來看靜態方法的話可能會稍微有一點奇怪，不過畢竟函式本身也是物件嘛，要在之上新增屬性本來就是合法的。</p>
<h2 id="類別建構子內的-super"><a class="header-anchor" href="#類別建構子內的-super"></a>類別建構子內的 <code>super</code></h2>
<p>剛剛說到類別建構子與建構函式內容相同，而裡面的 <code>super</code> 又代表了被繼承類別（或稱前代類別），所以在「後代」類別建構子內一定要呼叫 <code>super</code> 才能有效完成屬性繼承，而在 <code>class</code> 內定義的其他方法則會被定義到原型物件內，所以如果想要取得「前代」建構函式原型物件內的函式，可以直接用 <code>super</code> 來取用，以前面 <code>Human</code> 類別為例子，在 <code>User</code> 類別內就可以這樣做：</p>
<pre><code>    class User {
    	constructor(name){
    		super() 
    		this.name = name
    	} 
    	getRace(){
    		return super.getRace()
    	}
    } 
</code></pre>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>在我們了解了 JS 內，原型的運作方式之後，我們利用原型達成了繼承的效果，了解了什麼是原型鍊，之後在今天的這篇文章裡面我們又結合了上述提到的所有知識了解了 <code>class</code>  語法糖的使用方式，還有跟舊版建構函式寫法的對應。儘管一切很複雜，相信讀到這裡的你一定有不少收穫。</p>
<p>雖然快結束了，不過如果你對我寫的系列文有興趣，歡迎訂閱，已經訂閱我的人，也非常感謝你們，你們的閱讀就是我寫下去的最大動力，希望我可以把 30 天都撐完！</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:08.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    17 分鐘 閱讀文 (大約 2508 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-22/">JS 原力覺醒 Day22 -  原型共享與原型繼承</a>
            
        </h1>
        <div class="content">
            <p>前一天我們提到 JS 的原型，以及為什麼會有原型的出現 ：為了模擬物件導向的行為。 那麼原型實際上帶來什麼好處？又是透過什麼方式達到繼承的目的？</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>原型共享：原型的運作方式</li>
<li>原型鍊</li>
<li>原型繼承</li>
</ul>
<h2 id="原型共享：原型的運作方式"><a class="header-anchor" href="#原型共享：原型的運作方式"></a>原型共享：原型的運作方式</h2>
<p><code>__proto__</code> 屬性會在物件產生的時候被加到這個物件上，這個 <code>__proto__</code> 就是透過參考的方式，將「被生成物件」與函式的「原型物件」做連結 (  看到 <strong>proto</strong> 前後的「＿」有沒有把他跟「連結」做聯想，是不是覺得這個變數取的很好？ )。這個自動產生 <code>__proto__</code> 參考的行為是 JS 預設的動作，有一點像是這樣：</p>
<pre><code>let user1 = new User() 
user1.__proto__ = User.prototype 
</code></pre>
<p>當然因為這件事情是自動發生的，所以我們不需要手動去做這件事情，在開發上也不建議操作 <code>__proro__</code> 這個變數，請讓他自由，所以整理一下提到的兩個名詞。</p>
<ol>
<li><strong>proto</strong> ：會在物件被生成時一起被指派到物件上的屬性，他決定這個物件的原型物件是誰。</li>
<li>prototype ：會一直存在於建構函式上的屬性，所有透過該函式產生的物件都有能力存取。</li>
</ol>
<p>當我們想要取用物件中的某個屬性時，JS 會先去物件中尋找該屬性，如果沒有，就會轉而透過<code>__proto__</code> 往原型物件屬性，也就是 <code>prototype</code> 原型物件，去尋找這個屬性。由於原型物件 <code>prototype</code> 本身也是物件，所以我們在這個物件內也可以另外新增屬性，而透過前面的說明我們也可以知道原型物件是在被生成物件之間被共享的，所以我們就可以把一些共用的變數或是方法，放到這個共用的物件之內。</p>
<pre><code>let defaultName = 'Darth Vader'
User.prototype.name = defaultName

let user1  = new User() 
let user2  = new User() 

user1.name // 'Darth Vader'
user2.name // 'Darth Vader'
</code></pre>
<p>這麼做有什麼好處？ 把共用函式放在函式建構子裡面的話，每個被生成物件還是會有一樣的函式阿？是這樣沒錯，但是這樣等於是把同樣的數值或函式複製好幾次，生成幾個物件，JS 就會需要幾個記憶體空間；而要同樣的目的，其實只要放在 <code>prototype</code> 原型物件內就可以用較低成本的方式達成。</p>
<h2 id="原型鍊"><a class="header-anchor" href="#原型鍊"></a>原型鍊</h2>
<p>剛剛說到當 JS 引擎在物件內找不到某個屬性時會透過 <code>__proto__</code> 去往 <code>prototype</code>  原型物件去搜尋這個屬性，如果原型物件裡還是找不到，這個原型物件上也還會有一個 <code>__proto__</code>，指向他所屬前代類別的原型物件，例如 JS 內 Array 其實也是物件，所以可以說他的前代就是 Object 物件：</p>
<pre><code>Array.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>因此 JS 引擎會再透過原型物件裡的 <code>__proto__</code> 屬性往上一個原型物件尋找，直到真的找不到為止 ( 會找到 JS 內 Object 物件的原型物件為止，你可以再透過 <code>__proto__</code> 往上找找，最後會發現他是 <code>null</code> )。這個行為跟當初我們講到範圍鍊 ( Scope Chain ) 的行為類似，所以也稱為「原型鍊 ( Prototype Chain )」。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20106580PmyBG9ONck.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20106580PmyBG9ONck.jpg"></p>
<h2 id="原型繼承"><a class="header-anchor" href="#原型繼承"></a>原型繼承</h2>
<p>最後這個部分就讓我實際的程式碼範例來實作繼承，順便藉此說明原型鍊概念的實用性，在繼承的行為裡，透過被繼承的「後代類別」，所產生出來的物件，一開始就應該要直接具有「前代類別」的屬性跟方法，我們來嘗試看看有沒有辦法透過 JS 達到這個目的。</p>
<p>現在假設：</p>
<ul>
<li>我們有一個 <code>Human</code> 類別跟 <code>User</code> 類別</li>
<li>在 Human 類別的物件上有一個 getRace 方法</li>
<li>在 User 類別的物件上有一個 getUserName 方法</li>
</ul>
<p>我們的目標是：透過原型鍊實現 Human 與 User 兩者的繼承關係。</p>
<pre><code>function Human (action, height,race){
	this.action = action 
	this.height = height 
	this.race = race
}


function User(fisrtname,lastname){
	this.fisrtname = fisrtname 
	this.lastname = lastname 
}
 

Human.prototype.getHumanRace = function(){
	return this.race
} 

User.prototype.getFullName = function(){
	return this.firstname + this.lastname
}
</code></pre>
<p>在正式開始之前我們要先思考一下有哪些部分要處理，才能夠讓要繼承的函式建構子與被繼承的函式建構子共享屬性跟方法，主要有兩個方向：</p>
<h3 id="1-前後代類別原型物件繼承"><a class="header-anchor" href="#1-前後代類別原型物件繼承"></a>1. 前後代類別<strong>原型物件繼承</strong></h3>
<p>因為透過 <code>new</code> 運算子生成物件的時候，這兩個建構函式上都會各有一個 <code>protorype</code> 物件，一般情況下他們各自為政 ，但是在處理繼承的時候我們必須同時考慮兩者之間的連結。</p>
<p>前面提到物件在找不到屬性時，就會往原型物件找，如果原型物件裡還是找不到，就會再透過原型物件裡的 <code>__proto__</code> 屬性往上一個原型物件尋找，形成原型鍊。原型物件之間要做到繼承就代表了：</p>
<blockquote>
<p>透過「後代類別」產生的物件，其上有屬性不管在物件內還是在原型物件上都無法找到時，會轉而往「前代類別」的原型物件尋找</p>
</blockquote>
<p>能夠做到這樣子的行為，我們才能說我們透過建立原型屬性的原型鍊，而做到繼承的效果。為了達到這樣子的效果，很顯見的我們必須修改物件上的 <code>__proto__</code> 連結，但是前面也有提過再開發上不建議直接修改<code>__proto__</code> 的參考，因為會破壞物件的預設行為，儘管如此，我們還是可以用比較曖昧的方式來修改這個連結：</p>
<pre><code>User.prototype = Object.create(Human.prototype)
</code></pre>
<p>我只用一個之前沒看過的 JS 內建方法 <code>Object.create</code> 修改了繼承物件 User 的 <code>prototype</code> ，<code>Object.create</code> 可以用來創在一個全新的物件，而且他把第一個參數傳入的物件拿來當作這個新物件的 <code>prototype</code> ，之後我們就可以發現 <code>User</code> 的原型物件，被我們修改成一個新的空物件，而這個物件的原型，正是指向 <code>Human</code> ，  透過這樣的方式 ，我們就把兩者之間繼承的原型鍊串起來了。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20106580jQaA3vn2o0.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20106580jQaA3vn2o0.png"></p>
<p>但是如果你有注意到的話，原本在原型物件上都會有個指回建構函式的<code>prototype.constructor</code> 已經不見了，因此我們需要手動把他加回來，JS 才能夠查找到正確的建構函式。</p>
<pre><code>User.prototype.constructor = User
</code></pre>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20106580jaRrWOjwPH.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20106580jaRrWOjwPH.jpg"></p>
<h3 id="2-前後代建構函式內容繼承"><a class="header-anchor" href="#2-前後代建構函式內容繼承"></a>2. 前後代建構函式內容<strong>繼承</strong></h3>
<p>透過原型物件確實可以達成共享，但如果透過這個方法來共享某些特定屬性，因為屬性的記憶體空間只有一個，這麼一來如果是像「姓名」、「年齡」這種每個人（實體）都會有不同數值的資料，就不適合放在原型物件內，所以我們要想辦法讓我們在「後代」建構函式內可以直接取得「前代」建構函式內容。</p>
<p>簡單來說就是讓前代類別的內容出現在透過後代類別的建構函式所產生的物件上，這裡有一個很經典的辦法，那就是在後代 ( 繼承類別 ) 建構函式裡面執行前代( 被繼承類別 ) 建構函式：</p>
<pre><code>function Human (height,race){
	this.height = height 
	this.race = race
}


function User(fisrtname,lastname,race,height){
	this.fisrtname = fisrtname 
	this.lastname = lastname 
  Human(height,race) // This is not totally correct
}
</code></pre>
<p>這麼一來當 User 透過 <code>new</code> 被呼叫的時候，除了會將 <code>User</code> 內的 <code>this</code> 繫結綁到新生成物件上，還會有另外一個充滿使用 <code>this</code> 繫結來設定物件屬性的 <code>Human</code> 方法被執行，如此一來，前代類別的屬性設置就能夠與後代共用，而前兩行定義的 <code>firstname</code> 與 <code>lastname</code> ，也正好是 <code>User</code> 專屬，<code>Human</code> 不會有的資料屬性，當然我們也可以直接把 <code>Human</code>內定義的屬性搬到 User 內，不過這樣就會變成是重新定義一整個物件屬性，就失去繼承的意義了：</p>
<pre><code>// dont do this if you want to make an inheritance.
//THIS IS AN ANTI-PATERN
function User(fisrtname,lastname,race,height){
	this.fisrtname = fisrtname 
	this.lastname = lastname 
	this.height = height 
	this.race = race
}
</code></pre>
<p>但是還沒有完，這邊有一個前面提過很重要的觀念，那就是當我們 執行 <code>Human</code> 方法時，裡面的 <code>this</code> 繫結並非透過 <code>new</code> 被觸發，所以並不是指向剛剛透過 <code>User</code> 函式建構子被生成的新物件，這個時候我們要透過「明確的繫結」來修改 <code>this</code> 的指向，來把 User 內的 <code>this</code> 連結到 <code>Human</code> 函式的 <code>this</code> 上，這樣子我們就達成了所有物件屬性的繼承：</p>
<pre><code>function Human (height,race){
	this.height = height 
	this.race = race
}

function User(fisrtname,lastname,race,height){
	this.fisrtname = fisrtname 
	this.lastname = lastname 
  Human.call(this,height,race) 
}

Human.prototype.getHumanRace = function(){
	return this.race
} 

User.prototype.getFullName = function(){
	return this.firstname + this.lastname
} 

User.prototype = new Human()

let user1 = new User('John','Kai','black','179')   
</code></pre>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20106580dVHNzBM7ks.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20106580dVHNzBM7ks.png"></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:06.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 分鐘 閱讀文 (大約 1665 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-21/">JS 原力覺醒 Day21 -  原型</a>
            
        </h1>
        <div class="content">
            <hr>
<p>上一篇提到 JS 是物件原型導向，而非物件導向的語言，如果想要像物件導向那樣達成物件之間屬性的共用，就需要借助原型的幫忙，所以了解「原型」的概念，對於我們後續想要活用 JS  的物件，或是在 JS 裡面撰寫物件導向風格的程式碼的話是非常重要的。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>物件導向：類別與物件</li>
<li>物件導向：繼承的概念</li>
<li>函式上的原型物件屬性</li>
<li>透過函式建構子產生的物件</li>
<li>總結：原型物件屬性</li>
</ul>
<h2 id="物件導向：類別與物件"><a class="header-anchor" href="#物件導向：類別與物件"></a>物件導向：類別與物件</h2>
<p>在物件導向語言裡面，類別定義了描述某件事或某個功能的基本概念，就像一件商品或是建築物的設計圖ㄧ樣；而物件則是透過類別裡所描述的的概念實現出來的東西，對比於建築設計圖，就是建築物：</p>
<ul>
<li>類別 ←→ 建築設計圖</li>
<li>物件 ←→ 建築物</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580XxkBIolrjB.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580XxkBIolrjB.jpg"></p>
<p>當然上面的比喻只能說是非常非常粗淺的描述，完整的物件導向概念是非常博大精深的。這邊是想讓各位讀者了解它的原理，以及從什麼出發點被創造出來的，知道物件導向的根本概念後，後面我們解說 JS 原型的時候，就不會那麼不知所以然。</p>
<h2 id="物件導向：繼承的概念"><a class="header-anchor" href="#物件導向：繼承的概念"></a>物件導向：繼承的概念</h2>
<p>前面也提過原型存在的目的是為了達到繼承，那麼我們先來看看繼承是怎樣的概念，在物件導向裡的繼承是指類別可以以另一個類別為基礎，再往上進行擴充、或是修改，這樣一來就可以用很方便且較低成本的方式創造新的類別，因此，姑且說繼承的目的是為了讓「某些屬性可以共用」且可以減少重複。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580UZUALPHjdm.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580UZUALPHjdm.jpg"><br>
用生活化的方式比喻的話繼承與被繼承物件之間的關係，有點像圖片內的「動物」這個總稱與「鳥」這樣更明確的稱呼，鳥也是動物的一種，所有動物都有特定共用的行為例如呼吸，但是有些行為可能只有鳥類做得出來例如飛行，因此可以知道，繼承可以讓物件同時具有共用的部分與較為特定的部分。</p>
<h2 id="函式上的原型物件屬性"><a class="header-anchor" href="#函式上的原型物件屬性"></a>函式上的原型物件屬性</h2>
<p>在物件導向裡面有類別的概念讓物件得以用很快速清楚的方式擴充，而 JS 裡面只有「物件」，所以只能用模擬的方式來達成類似的效果 — 那就要透過原型的幫忙。</p>
<p>前面在講繫結的時候我們提到，函式可以搭配 <code>new</code> 運算子成為「函式建構子」來產生物件，我們先來討論函式建構子的概念是什麼。在 JS 裡面，函式建構子其實與一般函式呼叫沒有差別，只是前面多了 <code>new</code> 這個關鍵字而已。</p>
<p>而在 JS 裡面，一個函式被創造出來的時候，JS 引擎會新增一個 <code>prototype</code> 屬性到這個函式上面，這個 <code>prototype</code> 是一個物件，我們姑且稱之為「原型物件」，在原型物件裡面我們可以找到一個指回該函式的<code>constructor</code> 屬性。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580QnyFbprfLV.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580QnyFbprfLV.jpg"></p>
<p>我們用下面的程式碼來當作例子：</p>
<pre><code> function User(firstName, lastName) {
	this.firstName = firstName,
	this.lastName = lastName,
	this.fullName = function() {
		return this.firstName + &quot; &quot; + this.lastName;
	}
}

var user1 = new User(&quot;Gin&quot;, &quot;Tsai&quot;);

console.log(user1) 
</code></pre>
<p>我們用 <code>User</code> 函式當作函式建構子來產生物件，這個函式上面會有一個 <code>prototype</code> 屬性，且他是一個物件，裡面有另外兩個屬性：</p>
<ul>
<li>剛剛提到的 <code>constructor</code> 屬性，指向回該建構函式 ( User )</li>
<li><code>＿proto__</code> 屬性 ，裡面又是另外一個物件，這一點後面會再詳談</li>
</ul>
<h2 id="透過函式建構子產生的物件"><a class="header-anchor" href="#透過函式建構子產生的物件"></a>透過函式建構子產生的物件</h2>
<p>那麼，當物件透過這個函式建構子被產生之後，會不會有什麼特別的地方呢？相對於 JS 引擎在 function 上面加上 <code>prototype</code> 屬性，在這個新生成的物件上則是會被加上一個 <code>__proto__</code> 屬性，這個屬性恰好是指向剛剛函式建構子的 <code>prototype</code> 物件。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580aINQGXfUmW.png" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580aINQGXfUmW.png"></p>
<pre><code>User.prototype === user1.__proto__  //true
</code></pre>
<p>因此我們透過上面的例子可以得出這樣子一個結論：透過函式建構子生成的物件，其上面會有一個指向該物件所屬函式建構子 <code>prototype</code> 屬性的 <code>__proto__</code> 屬性，也就是<strong>該新生成物件的「原型」。</strong></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580sg56q0rUHF.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580sg56q0rUHF.jpg"></p>
<p>現在讓我們用同樣的方式創造第二個使用者 <code>user2</code> ，因為一樣都是透過函式建構子所產生的物件，因此在這個物件上照理說也會有一個 <code>__proto__</code> 屬性並指向產生這個物件的函式建構子上的原型物件，所以我們可以知道<strong>只要是透過函式建構子被生成的物件，他們之間都有一個共享的原型物件（ <code>prototype</code> ）</strong>，先知道這一點很重要。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580UpsGcXBrmb.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580UpsGcXBrmb.jpg"></p>
<h2 id="總結：原型物件屬性"><a class="header-anchor" href="#總結：原型物件屬性"></a>總結：原型物件屬性</h2>
<p>現在我們知道了被生成物件與建構函式之間的關係：</p>
<blockquote>
<p>所有透過函式建構子生成的物件，都透過 <code>__proto__</code> 屬性與函式建構子上的 <code>prototype</code> 屬性做連結，或是說共享這個屬性。</p>
</blockquote>
<p>但是光知道這些還沒有辦法知道實際的應用，下一章節我們會介紹這個部分，就讓我們往下看看 JS 是怎麼透過原型來達到繼承以及減少相同函式宣告的重複性的。</p>
<h2 id="參考資源"><a class="header-anchor" href="#參考資源"></a>參考資源</h2>
<p><a href="https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b">Prototypes in JavaScript </a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:34.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7 分鐘 閱讀文 (大約 1093 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-20/">JS 原力覺醒 Day20 -  物件</a>
            
        </h1>
        <div class="content">
            <p>今天要提到 JS 裡面物件的概念，「物件」的概念在 JS 裡面是非常重要的，也是 JS 的基本元素。但是相對於物件導向語言的物件，意義上又有一點不一樣。就像前面提到在 JS 裡面函式也是屬於物件，這樣子的行為在一般物件導向的語言裡面是沒有的。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>JS 的物件</li>
<li>創造物件的方式</li>
<li>取用物件的方式</li>
<li>物件原型導向</li>
</ul>
<h2 id="js-的物件"><a class="header-anchor" href="#js-的物件"></a>JS 的物件</h2>
<p>在 JS 裡，物件代表一連串「屬性名稱」與「數值」的組合 ( name-value pair )。這些組合湊在一起就形成了對某件事情的描述，就像一本書有許多資訊像是書名、作者、出版日期ㄧ樣，你可以用 JS 物件輕鬆的表示現實世界的許多物品：</p>
<pre><code>{
 title: 'Le Petit Prince', 
 author:'Antoine de Saint-Exupery', 
 pages: '331', 
 ...
} 
</code></pre>
<h2 id="創造物件的方式"><a class="header-anchor" href="#創造物件的方式"></a>創造物件的方式</h2>
<p>最基本的用來創造物件的方式有幾種：</p>
<ul>
<li>物件實字 （ Object Literal ）</li>
<li>函式建構子</li>
</ul>
<h3 id="物件實字-object-literal"><a class="header-anchor" href="#物件實字-object-literal"></a>物件實字 （ Object Literal ）</h3>
<p>物件實字應該是你最長用到的創造物件方式，使用物件實字創造物件的寫法，跟在 API 傳遞、溝通的時候會用到的 JSON 格式長得很像，都是使用大括號逗號來區分屬性，其實我在文章的開頭就已經使用過了：</p>
<pre><code>let object = { propertyName : 'value', ...} 
</code></pre>
<h3 id="函式建構子-function-constructor"><a class="header-anchor" href="#函式建構子-function-constructor"></a>函式建構子 （ Function Constructor ）</h3>
<p>在許多物件導向語言裡面，因為以類別為主的語言特性，通常是以  <code>class</code> 創造物件藍圖，並搭配使用 <code>new</code> 關鍵字來產生新的物件，這也是物件導向的基本概念。雖然 JS 並不是物件導向的語言，但早期為了吸引那些習慣使用物件導向語言的工程師來使用，也創造了使用 <code>new</code> 關鍵字，屬於自己獨特的產生物件的方式，稱為「函式建構子」，也就是把函式內容視為其他物件導向語言的建構子（ constructor ) 來使用：</p>
<pre><code>function book  (name,price) {
	this.name = name; 
	this.price = price  
} 

let starWar = new book('star war', 500) 

console.log(starWar) // book {name: &quot;star war&quot;, price: 500} 
</code></pre>
<p>如果你要產生一個空物件，那麼除了物件實字，你也可以透過下面的方式：</p>
<pre><code> let obj  = new Object(); 
</code></pre>
<p>這是什麼意思？我們都知道 JS 裡面有一個物件叫做 Object，裡面有很多好用的 API 例如 <code>Object.keys</code> 可以取得物件的所有屬性名，但是根據上面的說明，<code>new</code>  應該要搭配函式來使用才對啊？難道 <code>Object</code> 是函式不成？</p>
<p>是的！  在 JS 裡面 Object 就是一個函式，你可以對他使用 typeof 來驗證這個說法：</p>
<pre><code> typeof Object // function 
</code></pre>
<p>既然 <code>Object</code> 本身也是函數，那麼這個說法就合理了，至於為什麼 <code>typeof Object</code> 結果不是 Object ，我想那又是另外一個層面的問題了。</p>
<h2 id="取用物件屬性的方式"><a class="header-anchor" href="#取用物件屬性的方式"></a>取用物件屬性的方式</h2>
<p>取用物件有兩種方式：</p>
<ul>
<li>最常見的<code>.</code>運算子</li>
<li>使用中括號 <code>[]</code></li>
</ul>
<p>使用中括號取用物件來取用屬性，因為能夠使用字串的關係，在取用屬性的時候可以比較有彈性：</p>
<pre><code>let user = {
	name:'Yoda'
} 
user.name // Yoda
user['name'] //Yoda
</code></pre>
<h2 id="物件原型導向"><a class="header-anchor" href="#物件原型導向"></a>物件原型導向</h2>
<p>雖然許多人在 JavaScript  撰寫物件導向風格的程式碼，但 JS 並不是像 JAVA 或是 C# 那樣物件導向的語言，而相對的，JS 是物件原型導向（ Object-Prototype Oriented ）的語言，在 JS 裡面的每個物件都有一個可以用來與其他物件共用屬性跟方法，或是進行複製的隱藏屬性 : <code>[[ Prototype ]]</code>。</p>
<p>這種繼承的行為也稱為原型繼承 ( prototypical inheritance )，相對於其他像是 PHP、JAVA、Python 這種以類別 ( class ) 為基礎的物件導向語言，這算是比較特別的，在後面的章節我會繼續說明 JS 的物件是如何透過原型來共用屬性的。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:31.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 分鐘 閱讀文 (大約 945 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-19/">JS 原力覺醒 Day19 - 一級函式與高階函式</a>
            
        </h1>
        <div class="content">
            <p>今天要提到的是讓 JS 很適合用來撰寫 Functional Programming 的兩個特性的名詞解釋：「 一級函式」與「高階函式」，如果你寫 JS 一段時間，一定會聽過他，高階函式與一級函式可能聽起來有點複雜，其實並不會，只是字面上意思比較不好理解而已。這兩個特性，讓 JS 可以把函式在其他函式之間互傳，所以也是為什麼有人說 JS 很適合用來寫 Functional Programming 的原因。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>一級函式</li>
<li>高階函式</li>
</ul>
<h2 id="一級函式-first-class-functions"><a class="header-anchor" href="#一級函式-first-class-functions"></a>一級函式 （ First-class functions ）</h2>
<p>當我們說一個語言具有一級函式的特性時，代表這個語言把函式當作其他物件一樣看待，也因此可以將函式當作參數一樣傳入另外一個函式裡面。在 Functional Programming 裡面，也是因為這個特性，才有辦法做到複合函式 （Function Composition），</p>
<p>而在 JS 內，函式本身也是一個特殊的物件（就是 Function 物件），在一些使用到 callback 概念的程式碼中，你就會看到這個概念是如何被應用的：</p>
<pre><code>function doSomething(fn, data) { 
   return fn(data);
}
</code></pre>
<p>我們可以試試下面的程式碼來確認上面的描述 ：</p>
<pre><code> function hello (){
		console.log('hello') 
	} 

hello.a = 'a'
console.log(hello.a) //'a' 
</code></pre>
<p>雖然上面的程式碼完全是合法的，因為函式本來就也是物件，但是在實務上請不要這麼做，否則同事或是跟你一起合作的人可能會崩潰，請使用一般的物件。</p>
<p>而既然將函式當作物件一樣看待，那就代表也可以把這個函式指派給變數，這就是我們之前提到的「函式表達式」 （ Function Expression ) 。</p>
<pre><code>let hello = function (){
	//do  some thing 
} 
</code></pre>
<h2 id="高階函式-high-order-function"><a class="header-anchor" href="#高階函式-high-order-function"></a>高階函式 （ High Order Function )</h2>
<p>只要是可以接收函式作為參數，或是回傳函式作為輸出的函式，我們就稱為高階函式，例如，JS 裡面很常用的一些對陣列操作的內建API：</p>
<ul>
<li>Array.map( ()⇒{…} )</li>
<li>Array.filter( ()⇒{…} )</li>
<li>Array.reduce( ()⇒{…} )</li>
</ul>
<p>也可以被稱為是高階函式，因為他們能夠接收函式作為他們的參數。雖然上述幾個 API 的使用方式乍看之下可能會讓人覺得難以理解，但我們可以試著思考看看他們是怎麼被實作的，其實並沒有那麼複雜，下面就以 Array.map 為例，邊實作、邊思考他的運作方式吧！</p>
<p>由於 Arrray.map 是對陣列元素做巡訪，然後做某些操作之後回傳，所以可能的步驟如下：</p>
<ol>
<li>將函式傳入 map 內</li>
<li>執行一個以陣列長度為執行次數的迴圈</li>
<li>每次帶入不同的 array id 以表示目前尋訪的進度</li>
<li>取得陣列元素、逐個進行修改</li>
<li>逐個放入新的陣列並回傳</li>
</ol>
<p>自己實際實作 map function 的話看起來會像是這樣：</p>
<pre><code>function arrayMap(fn,array){
	let length = array.length
	let newArray = [] 
	for(let i=0 ; i&lt;length ; i++){
		newArray.push(fn(array[i]))
	}
	return newArray
}
</code></pre>
<p>透過上面的程式碼我們自己就實作了高階函式 arrayMap ，可以看到我們自己做的 arrayMap 會在陣列傳入之後，逐個訪問每個元素並傳入我們自己寫的函式 fn ，這個 fn 會根據我們寫的內容將該值做處理之後回傳，然後會直接透過 Array.push 將結果推入新的函式（ 看到了嗎？這裡我們用到複合函式的概念 ）</p>
<pre><code>arrayMap((item)=&gt;{
	return item * 2 	
},[1,2,3,4])
</code></pre>
<h2 id="結論"><a class="header-anchor" href="#結論"></a>結論</h2>
<p>透過今天對兩個名詞的說明我們知道了一級函式與高階函式這兩個名詞的意義，然後我們也自己試著實作了自己的高階函式：</p>
<ul>
<li>一級函式是指在一個語言內，函式本身也是物件，因此能夠將函式當成參數傳給另一函式</li>
<li>高階函式則是指一個函式能不能接收函式當作參數，或是回傳函式作為回傳值</li>
</ul>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/tags/frontend/page/0/">上一頁</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/tags/frontend/page/2/">下一頁</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/tags/frontend/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/tags/frontend/page/2/">2</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/tags/frontend/page/3/">3</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/tags/frontend/page/4/">4</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-4-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="/images/avatar.png" alt="Mujing Tsai">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Mujing Tsai
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        -
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Taipei, Taiwan</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            64
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分類
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            10
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        標籤
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            20
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://www.facebook.com/mujing" target="_blank" rel="noopener">
                追蹤</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Github" href="https://github.com/moojing">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Facebook" href="https://www.facebook.com/mujing">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Twitter" href="https://www.linkedin.com/in/mu-jing-tsai/">
                
                <i class="fab fa-linkedin"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            連結
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://ithelp.ithome.com.tw/users/20106580/ironman/2503" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">11th鐵人賽</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">ithelp.ithome.com.tw</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分類
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Canvas/">
            <span class="level-start">
                <span class="level-item">Canvas</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/FullStack/">
            <span class="level-start">
                <span class="level-item">FullStack</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/IThome-鐵人賽30天/">
            <span class="level-start">
                <span class="level-item">IThome - 鐵人賽30天</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">30</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Javascript/">
            <span class="level-start">
                <span class="level-item">Javascript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">7</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Javascript-React/">
            <span class="level-start">
                <span class="level-item">Javascript React</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/TypeScript/">
            <span class="level-start">
                <span class="level-item">TypeScript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Webpack/">
            <span class="level-start">
                <span class="level-item">Webpack</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/devOps/">
            <span class="level-start">
                <span class="level-item">devOps</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/w3HexSchool-2020-年度鐵人賽/">
            <span class="level-start">
                <span class="level-item">w3HexSchool 2020 年度鐵人賽</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/走在漫漫長路-工作心得/">
            <span class="level-start">
                <span class="level-item">走在漫漫長路 - 工作心得</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            彙整
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2021/04/">
                <span class="level-start">
                    <span class="level-item">四月 2021</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/09/">
                <span class="level-start">
                    <span class="level-item">九月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/03/">
                <span class="level-start">
                    <span class="level-item">三月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">二月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/01/">
                <span class="level-start">
                    <span class="level-item">一月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">30</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/05/">
                <span class="level-start">
                    <span class="level-item">五月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/04/">
                <span class="level-start">
                    <span class="level-item">四月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">三月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">二月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">17</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            標籤雲
        </h3>
        <a href="/tags/backend/" style="font-size: 15.71px;">backend</a> <a href="/tags/canvas/" style="font-size: 10px;">canvas</a> <a href="/tags/compound-component/" style="font-size: 10px;">compound component</a> <a href="/tags/devOps/" style="font-size: 11.43px;">devOps</a> <a href="/tags/frontend/" style="font-size: 20px;">frontend</a> <a href="/tags/frontend-force/" style="font-size: 17.14px;">frontend-force</a> <a href="/tags/ironman30/" style="font-size: 17.14px;">ironman30</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/rails/" style="font-size: 15.71px;">rails</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/ruby/" style="font-size: 15.71px;">ruby</a> <a href="/tags/ruby-on-rails/" style="font-size: 15.71px;">ruby on rails</a> <a href="/tags/typeScript/" style="font-size: 11.43px;">typeScript</a> <a href="/tags/typescript/" style="font-size: 12.86px;">typescript</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/vue-js/" style="font-size: 10px;">vue.js</a> <a href="/tags/w3HexSchool/" style="font-size: 14.29px;">w3HexSchool</a> <a href="/tags/working/" style="font-size: 11.43px;">working</a> <a href="/tags/地下城/" style="font-size: 14.29px;">地下城</a> <a href="/tags/鐵人賽30天/" style="font-size: 17.14px;">鐵人賽30天</a>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2021/04/03/react-compound-component/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="React 設計模式 - 複合元件">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2021-04-03T10:14:38.000Z">2021-04-03</time></div>
                    <a href="/2021/04/03/react-compound-component/" class="title has-link-black-ter is-size-6 has-text-weight-normal">React 設計模式 - 複合元件</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Javascript-React/">Javascript React</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/09/06/working-reward/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/thumbnails/reward-cover.JPG" alt="每個衝擊都是一次學習的機會 - 近期的一點心得">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-09-06T09:36:53.000Z">2020-09-06</time></div>
                    <a href="/2020/09/06/working-reward/" class="title has-link-black-ter is-size-6 has-text-weight-normal">每個衝擊都是一次學習的機會 - 近期的一點心得</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/走在漫漫長路-工作心得/">走在漫漫長路 - 工作心得</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/09/working-environment/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/thumbnails/work-life.jpg" alt="寫給職場工作者：工作環境是否會影響一個人的思考方式？">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-08T20:54:46.000Z">2020-03-09</time></div>
                    <a href="/2020/03/09/working-environment/" class="title has-link-black-ter is-size-6 has-text-weight-normal">寫給職場工作者：工作環境是否會影響一個人的思考方式？</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/走在漫漫長路-工作心得/">走在漫漫長路 - 工作心得</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/07/web-dnd-2/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/thumbnails/DragnDrop.jpg" alt="就是要一起拖拖拉拉！(二) - 利用 DataTransfer API 實作拖拉元素間的資料傳遞">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-07T08:39:14.000Z">2020-03-07</time></div>
                    <a href="/2020/03/07/web-dnd-2/" class="title has-link-black-ter is-size-6 has-text-weight-normal">就是要一起拖拖拉拉！(二) - 利用 DataTransfer API 實作拖拉元素間的資料傳遞</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/02/28/web-dnd-1/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/thumbnails/DragnDrop.jpg" alt="就是要一起拖拖拉拉！(一) - 瀏覽器 Drag and Drop API 操作">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-28T02:04:03.000Z">2020-02-28</time></div>
                    <a href="/2020/02/28/web-dnd-1/" class="title has-link-black-ter is-size-6 has-text-weight-normal">就是要一起拖拖拉拉！(一) - 瀏覽器 Drag and Drop API 操作</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                標籤
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/backend/">
                        <span class="tag">backend</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/canvas/">
                        <span class="tag">canvas</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/compound-component/">
                        <span class="tag">compound component</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/devOps/">
                        <span class="tag">devOps</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/frontend/">
                        <span class="tag">frontend</span>
                        <span class="tag is-grey">62</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/frontend-force/">
                        <span class="tag">frontend-force</span>
                        <span class="tag is-grey">30</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ironman30/">
                        <span class="tag">ironman30</span>
                        <span class="tag is-grey">30</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/javascript/">
                        <span class="tag">javascript</span>
                        <span class="tag is-grey">56</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/rails/">
                        <span class="tag">rails</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/react/">
                        <span class="tag">react</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ruby/">
                        <span class="tag">ruby</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ruby-on-rails/">
                        <span class="tag">ruby on rails</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/typeScript/">
                        <span class="tag">typeScript</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/typescript/">
                        <span class="tag">typescript</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/vue/">
                        <span class="tag">vue</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/vue-js/">
                        <span class="tag">vue.js</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/w3HexSchool/">
                        <span class="tag">w3HexSchool</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/working/">
                        <span class="tag">working</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/地下城/">
                        <span class="tag">地下城</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/鐵人賽30天/">
                        <span class="tag">鐵人賽30天</span>
                        <span class="tag is-grey">30</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="Moojing&#39;s Blog" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2021
                 <!-- Moojing&nbsp; -->
                
                <!-- Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> -->
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-TW");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://www.muji.dev',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到頁首" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="請輸入關鍵字..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '頁面',
                CATEGORIES: '分類',
                TAGS: '標籤',
                UNTITLED: '(無標題)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>
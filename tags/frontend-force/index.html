<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>標籤: frontend-force - Moojing&#39;s Blog</title>


    <meta name="keywords" content="frontend,backend,javascript">
<meta property="og:type" content="website">
<meta property="og:title" content="Moojing&#39;s Blog">
<meta property="og:url" content="https://www.muji.dev/tags/frontend-force/index.html">
<meta property="og:site_name" content="Moojing&#39;s Blog">
<meta property="og:locale" content="zh-TW">
<meta property="og:image" content="https://www.muji.dev/images/og_image_name.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Moojing&#39;s Blog">
<meta name="twitter:image" content="https://www.muji.dev/images/og_image_name.png">







<link rel="icon" href="/images/favicon.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-134605527-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-134605527-1');
</script>
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="Moojing&#39;s Blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About Me</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜尋" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-8-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/tags">標籤</a></li>
            <li class="is-active"><a href="#" aria-current="page">frontend-force</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:27.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16 分鐘 閱讀文 (大約 2431 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-30/">JS 原力覺醒 Day30 - 我是怎麼活過這三十天的？</a>
            
        </h1>
        <div class="content">
            <p>總算來到最後一天了，最後一天不會有技術內容，只會有很純的純 Mur Mur，想聽的再請留下。最後我打算記錄一下這三十天的感受，給其他沒參加過鐵人但是正在猶豫要不要參加的朋友參考。</p>
<p>普遍看到參賽方式有幾種情況：</p>
<ul>
<li>精明準備型：囤好囤滿 30 天，完全事先囤貨所以內容超精緻</li>
<li>微囤貨：不事先準備太多，只囤幾天貨用來緩衝</li>
<li>硬派：「 什麼！？不就是要現學現賣才叫做鐵人嗎？ 」的類型</li>
</ul>
<p>老實說我認為如果不事先準備的話，那麼能不能完賽跟主題的選擇還有自身對主題熟悉度會有很大的關係，所以如果你也正在思考要不要參加，可以從這點著手。如果主題是你想寫但不熟，可以考慮現在開始到下次開賽前先慢慢累積文章量；或者你覺得對主題比較上手，可以挑戰看看自己在短時間內對知識的理解程度。</p>
<h2 id="30天連續發文不只考驗技術"><a class="header-anchor" href="#30天連續發文不只考驗技術"></a>30天連續發文不只考驗技術</h2>
<p>經過評估，我走的是微囤貨路線，因為我是在 9/2  開賽前幾天才知道有鐵人賽這個活動，剛好我的下一個近期目標是對 JS 這個語言更有系統性的認識，當時是覺得這個活動可以用來挑戰一下自己，也正好可以之前寫的  <a href="https://medium.com/@moojing/%E5%8E%9F%E5%AD%90%E5%8C%96%E5%AD%B8%E7%BF%92-%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E4%B8%AD%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7-4622ab26934">原子化學習</a>  裡面把知識最小化的學習方式做實作驗證，所以想了一下大概要寫什麼之後就跳坑了。到了開賽期限 9/16 前一天，我硬生出大約 10 來篇準備留著緩衝。</p>
<p>沒想到正式開賽才發現我完全低估每天必須發文所帶來的壓力了，因為事先沒有累積太多文章的關係，我幾乎每天都在想著下一篇文章的內容怎麼寫、大綱怎麼擬定、要怎麼畫出核心概念圖才能讓人比較好理解之類的問題。這樣子的狀況持續到大概第 20 篇的時候是最痛苦的，因為越後面的主題我越不熟，需要越多時間，而前面的幾篇卻也因為思考解說方式跟準備圖例的關係花了不少時間，留下來的緩衝時間所剩無幾。</p>
<p>在這個時間點想繼續寫覺得吃力，想放棄又覺得不太對，瞬間覺得自己好像在跑一場已經完成 2/3 ，明明心裡知道快結束了但眼前就是還看不到終點線的尷尬窘境。所以我深深覺得鐵人賽除了考驗技術熟悉度更考驗筆者的心理耐力。在最後雙十連假那幾天實在是最難受的，雖然咬著牙硬寫完了，但是基本上我是ㄧ邊配獵人邊寫完的（喂</p>
<h2 id="使用工具"><a class="header-anchor" href="#使用工具"></a>使用工具</h2>
<p>工欲善其…咳咳，好廢話不多說，稍微介紹一下我這幾天用來幫助寫文章工具，基本上有三個：</p>
<ol>
<li>
<p>Notion</p>
<p>在正式開賽之前，我先用 Notion 的 Table 整理了三十天的大綱，雖然最後沒有完全ㄧ樣，不過可以讓自己對文章主題有個底，時間的掌握也比較精準，哪些主題自己比較不熟的話就要預留比較多時間。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20191015/20106580Hsbd3FYXSf.png" alt="https://ithelp.ithome.com.tw/upload/images/20191015/20106580Hsbd3FYXSf.png"></p>
</li>
<li>
<p>簡單的流程圖繪製軟體</p>
</li>
</ol>
<p>這種軟體的選擇就比較多，我是選 Sketch，一來之前有學過一點，二來覺得他匯出圖片很方便，雖然他主要是用來前端介面設計的工具，但是拉拉簡單的區塊跟流程箭頭還是很好用的。還有另外一套網頁版繪圖軟體也很推薦：<a href="https://www.draw.io/">Draw.io</a></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191015/20106580m8ATiR1MZH.png" alt="https://ithelp.ithome.com.tw/upload/images/20191015/20106580m8ATiR1MZH.png"></p>
<ol start="3">
<li>瀏覽器開發者工具：</li>
</ol>
<p>因為我寫的主題不是製作產品型的主題，許多範例程式碼只要可以馬上確認結果就好，這個時候整個瀏覽器都是我的實驗場 :D</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191015/2010658095DQqsedJi.png" alt="https://ithelp.ithome.com.tw/upload/images/20191015/2010658095DQqsedJi.png"></p>
<h2 id="是音樂-我加了音樂"><a class="header-anchor" href="#是音樂-我加了音樂"></a>是音樂，我加了音樂</h2>
<p>如果你以為我是像老派英雄主義電影裡的主角ㄧ單單靠著強大的意志力就輕輕鬆鬆寫完 30 篇文章練成鐵人那就錯了，我也希望我可以。 我曾經抱著很中二的想法，覺得如果世界上沒有音樂的話，我們幹嘛活著？老實說我現在還是深深這麼想的，大概今後也會一直這麼中二下去。總之最後來介紹一下陪伴我度過這地獄般 30 天的幾首曲子：</p>
<ul>
<li>
<p>Tauk - Horizon ：</p>
<p>風格上屬於前衛搖滾，我很喜歡他們華麗的效果器加上風格多變的主奏電吉他，雖然沒有人聲，但總能聽得我熱血沸騰，附上近期喜歡的一首曲子：</p>
<p><a href="https://www.youtube.com/watch?v=I0Ju0uIT004"><img src="https://img.youtube.com/vi/I0Ju0uIT004/0.jpg" alt="Yes"></a></p>
</li>
<li>
<p>Takami Nakamoto - Ashes：</p>
<p>這個音樂家的作品風格定位上還是比較偏電子舞曲，一般人聽來可能會覺得比較實驗性或藝術性，但我真的很喜歡各種奇異材質的聲響。想暫時脫離現實生活看一下不ㄧ樣世界樣貌的絕對推薦（建議戴耳機）：</p>
<p><a href="https://www.youtube.com/watch?v=dGyCHP0g3zA"><img src="https://img.youtube.com/vi/dGyCHP0g3zA/0.jpg" alt="Yes"></a></p>
</li>
<li>
<p>Mariya Takeuchi - Plastic Love :</p>
<p>這首毫無疑問是經典，我真的很喜歡遍佈整首的 Disco 元素，前奏剛下沒多久眼前就浮現煙霧彌漫然後雷射燈球光芒四射的場景，查了一下定位屬於 City Pop ，City Pop 是在 1970 日本傳統音樂受到西方音樂文化元素的影響而發展出來的獨特曲風，在當時由山下達郎組成的樂團 SUGAR BABE 帶起風潮。而竹內瑪莉雅就是山下的妻子，也是早期非常有名的音樂家之一，這首歌在前陣子 City PoP 復甦的時候出現在我的推薦歌單內，聽過後立刻愛上。</p>
<p><a href="https://www.youtube.com/watch?v=9Gj47G2e1Jc"><img src="https://img.youtube.com/vi/9Gj47G2e1Jc/0.jpg" alt="Yes"></a></p>
</li>
<li>
<p>The Brand New Heavies :</p>
<p>這個團體是 Acid Jazz (酸爵士)  的經典團體之一，Acid Jazz 緣起於 Disco 文化，在 1980 年代開始變成風潮，當時舞廳的 DJ 嘗試將爵士樂中的樂句加以取樣，融入電子音樂裡面並融合了靈魂樂、Funk、R&amp;B 等曲風，因而吸引了年輕世代跟老年族群的注意，也是一個讓當代大眾重新開始接觸爵士樂的契機。</p>
<p>雖然在  1987 年由知名唱片經營者 Eddie Piller 與 DJ Gilles Peterson 創立同名自有品牌後才正式被命名，不過 Acid Jazz 這種風格受 60 年代迷幻文化影響至深。（ Acid 同時也是迷幻藥的別稱 ）所以你常常能在這種曲風裡面聽見運用電子特效達成的迷幻效果，同時又因為強烈的律動感而忍不住開始擺動身體，讓我們來聽聽看 The Brand  New Heavies 今年出的專輯同名歌曲，你一定會很喜歡：</p>
<p><a href="https://www.youtube.com/watch?v=f7sMuvTLLlU"><img src="https://img.youtube.com/vi/f7sMuvTLLlU/0.jpg" alt="Yes"></a></p>
</li>
</ul>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>原本以為在我整理完過去的學習經驗，寫出原子化學習已經是我自己在今年最有標誌性的里程碑了，沒想到又幹了一件突破自己耐力極限的事情啊 (X。老實說好幾次都以為我沒辦法完賽了，我也不知道是什麼讓我可以支撐到最後，也許是賽期後半段開始陸陸續續有人追蹤，甚至有讀者會參與內容的討論以及告知筆誤，讓我覺得有莫名一股一定要繼續寫下去的責任感。</p>
<p>其實後面還想有寫但來不及寫的主題：演算法跟設計模式，但在我寫這篇文章的當下，已經有些厲害的工程師以演算法當成 30 天的主題並且已經或快要完賽了：</p>
<p><a href="https://ithelp.ithome.com.tw/users/20120643/ironman/2829">透過 LeetCode 解救美少女工程師的演算法人生</a></p>
<p><a href="https://ithelp.ithome.com.tw/users/20106426/ironman/2136">前端工程師用 javaScript 學演算法</a></p>
<p><a href="https://ithelp.ithome.com.tw/users/20092025/ironman/2606">模組化設計</a></p>
<p>上面稍微推薦一下幾個很棒的相關系列，接下來完賽後我陸陸續續也會去看之前沒時間看的那些主題，如 神Q超人的 TypeScript 或是 六角校長的職場教學，讀者有興趣的話之後也可以跟我一起惡補回來 ( X 。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:24.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    14 分鐘 閱讀文 (大約 2079 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-29/">JS 原力覺醒 Day29 - Set / Map</a>
            
        </h1>
        <div class="content">
            <p>ES6 之後加入兩種新的資料結構：Map  跟 Set 。 Map 與 Set 都是像字串跟陣列這樣可以被尋訪的類型，也就是說可以使用 for 迴圈去一個一個查找跟操作他們的值。今天就來說明一下這兩個類別跟使用方式吧！<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Set</li>
<li>Map</li>
<li>Map 與 Object</li>
</ul>
<h2 id="set"><a class="header-anchor" href="#set"></a>Set</h2>
<p>Set 的中文翻譯與數學裡面的「集合」相同，「集合」是某個定義好並且具有相同性質的元素的集合，講白話一點就是「一堆東西」。在 JS 內的集合當然代表「一堆值」，他跟陣列有點像，差別在 Set 能夠讓開發者可以<strong>方便快速的儲存不重複、獨特的數值</strong>。至於 <code>Set</code> 內儲存的元素內容沒有型別限制，可以是純值也可以是物件型別。</p>
<p><code>Set</code> 除了具有儲存不重複數值的性質外，在上面還有一些很方便的方法可以直接處理數值，讓我們陸續來看看，首先創造一個新的 <code>Set</code> ，創造新的 <code>Set</code> 很簡單，只要在 <code>Set</code> 的建構子傳入一個陣列即可：</p>
<pre><code> let set = new Set([1,2,3,'Hello','World',true]) 
</code></pre>
<p>在 Set 類別上有許多方法讓我們可以用比較語意化的方式操作 Set 內容：</p>
<ul>
<li>add( value ) : 新增一個元素到 <code>Set</code> 內</li>
<li>clear()  ：刪除所有 <code>Set</code> 內的元素</li>
<li>delete( value) ：刪除 <code>Set</code> 內特定的某個元素</li>
<li>forEach() ： 跟 array 上的 <code>forEach</code> 功能相同</li>
<li>has( value ) ：檢查 <code>Set</code> 內有沒有對應值的元素，這個功能如果在陣列內，必須透過 <code>indexOf</code> 來檢查才能達成。</li>
<li>values() ：會回傳 Set 內所有數值</li>
<li>size ：回傳 <code>Set</code> 元素長度</li>
</ul>
<p>就像前面說過的， <code>Set</code> 內儲存的是不重複的元素，因此如果有相同數值的元素再次被傳入，這個數值就會直接被忽略。</p>
<pre><code>	set.size //6
  set.add('Hello') 
  set.size //6
</code></pre>
<p>對 Set 做巡訪的方式跟陣列很相似，一樣可以用 <code>forEach</code> 方法，甚至 <code>Set</code> 可以很方便的直接轉為陣列 ：</p>
<pre><code> let setArr = [...set]
</code></pre>
<p>這個特性非常好用，利用這點我們就可以很快速的過濾出陣列內的重複值！</p>
<pre><code> let duplicatedValueArr = [1,2,3,5,10,19,10,4,5,6,3,1,2]
 let uniqueArr  = [...new Set(duplicatedValueArr)]
</code></pre>
<p>這樣子是不是既方便快速又簡潔？ 如果單純使用陣列可能還需要透過 <code>filter</code> 跟外部變數來儲存重複值輔助檢查，使用 <code>Set</code> 的話，這些功夫都可以省去。</p>
<h2 id="map"><a class="header-anchor" href="#map"></a>Map</h2>
<p><code>Map</code> 也是跟陣列、跟 <code>Set</code> 具有相同特性且可被巡訪的物件型別，差別在於， <code>Map</code> 跟物件ㄧ樣是鍵值的組合，也就是說，<code>Map</code> 同時具有跟陣列ㄧ樣可以被巡訪的特色，同時也有物件儲存任意屬性跟數值的能力。</p>
<p><code>Map</code> 類型上的方法也與 <code>Set</code> 大同小異，差別在 Set 新增元素的方法是使用 <code>add</code> ，而 <code>Map</code> 內必須用 <code>set</code> 方法 ，且新增元素時必須傳入兩個參數，第一個是要儲存的鍵 ( key )，另外一個是要儲存的數值內容 ( value )。</p>
<p>創造新的 <code>Map</code> 的方式與創造 <code>Set</code> 相同，但由於 <code>Map</code> 是鍵-值對的結構，傳入建構子內的陣列內不能夠像 Set 那樣只是個單一元素，而必須要是個鍵-值的組合，所以我們可以用二維陣列來達成，大概像是這樣：</p>
<pre><code> let map = new Map([['name','Luke'],['Hello','World']]) 
</code></pre>
<p>取得 Map 元素 ：</p>
<pre><code>  map.get('name') // Luke 
</code></pre>
<p>新增元素 ：</p>
<pre><code> map.set('Greeting','I am Anakin') // { ... 'Hello'=&gt;'World', 'Greeting'=&gt; 'I am Anakin'}
</code></pre>
<p>其他像是刪除特定元素或是刪除所有 Map 內元素則都跟 Set 上的方法差不多：</p>
<pre><code> map.delete('Hello')  
 map.clear()
 map.size
</code></pre>
<h2 id="map-與-object"><a class="header-anchor" href="#map-與-object"></a>Map 與 Object</h2>
<p>Map 其實跟物件ㄧ樣都是 鍵-值 的組合，事實上這些結構相似的類型有許多種，如，那麼使用 Map 相比於使用物件有什麼好處呢？還記得前面提到在 JS 內除了原始型別以外的型別都是物件型別嗎？這代表除了物件以外像是 <code>Array</code> 以及<code>Function</code> 這樣的型別都是繼承自 <code>Object</code>，這其中當然包含 <code>Map</code> 。</p>
<p>所以這兩種型別才有這麼相似的結構 ，性質相同的部分就不用多說了，但是這兩者還是有一些不差異，這些差異可能足以影響資料存取的複雜度以及程式碼閱讀的難易度，所以我們可以認識一下究竟兩者有什麼不同的地方：</p>
<ul>
<li>
<p>鍵值的類型：</p>
<p>在物件內的鍵值（或屬性名稱） 必須是字串或是 <code>Symbol</code>。而在 <code>Map</code> 內，鍵值可以是任何型別，這包含任何其他的物件或是陣列 。你當然可以試試看用物件來當作另外一個物件的屬性名稱，不過這個物件會被 JS 強制轉型變成 <code>[object Object]</code> 而變成另外一個字串屬性。</p>
<pre><code>  let o = {} 
  let anotherObj = {} 
  o[anotherObj] = 'anotherObject' // {'[object Object]' : anotherObject}
  
  let theThirdObj = {} 
  o [theThirdObj] = 'theThirdObj' //  {'[object Object]' : anotherObject}
</code></pre>
</li>
<li>
<p>元素的順序，在 <code>Map</code> 裡面，元素被新增進去之後，順序就會被固定下來。而在 Object 內則無法保證。</p>
</li>
<li>
<p>繼承關係：<code>Map</code> 繼承於物件 （ Object ) ，而反過來則否，因此在 <code>Map</code> 上那些方便的方法，在 Object 上無法使用。</p>
<pre><code>  let newMap = new Map()
  console.log(newMap instanceof Object) //true
  console.log(Object instanceof newMap) //false
</code></pre>
</li>
<li>
<p>可被巡訪：這大概是最大的差別了，因為一般物件上並沒有提供可以直接巡訪的方法，只能透過 <code>for .. in</code>  迴圈達成，或是必須透過 <code>Object.keys</code> 方法把屬性轉為陣列，但是在陣列 、 Set 跟 Map 上都有 <code>forEach</code> 方法可以直接對裡面的元素做巡訪。</p>
</li>
</ul>
<h2 id="map-與-object-使用時機"><a class="header-anchor" href="#map-與-object-使用時機"></a>Map 與 Object 使用時機</h2>
<p><code>Ｍap</code> 在操作元素上雖然提供了許多語意化的方法，但有時候我們還是會需要像一般物件那樣方便新增元素的方式，最後我們就來看看兩者各適合怎樣的使用情境：</p>
<ul>
<li>屬性值：這也是兩種型別最大的差別。在知道屬性值都單純只是字串時，使用一般物件就好，因為 Map 雖然可以儲存任何型別的數值，但是因為使用函式建構子創造物件，且在新增、修改元素時必須透過 <code>get</code> 、 <code>set</code> 函式幫忙，因此速度上會比單純使用物件還要慢。</li>
<li>JSON 格式：在需要以 JSON 格式來進行開發作業時，選擇一般物件。因為 JS 內的物件可以很直接的被轉為 JSON 格式，這在進行 API 溝通時非常好用。</li>
<li>順序性： 在 <code>Map</code> 內的元素順序會被保留，因此在處理資料時，如果維持順序的穩定很重要，就可以考慮使用 <code>Map</code> 。</li>
<li>需要一些特定功能：有時候我們會需要某個函式來取得其他屬性資訊，物件因為存取方便的關係，在物件內的屬性如果是函式，就可以直接被執行，<code>Map</code> 就比較麻煩。</li>
</ul>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>除了前面我們提到的幾個基本資料結構，今天我們又認識了 JS 內新的 Map 跟 Set 兩種新的資料型別。在資料結構選擇上永遠是根據你的需求而定，雖然用簡單的物件或陣列組合或許就可以達到，多認識一些這樣子的資料結構不一定會大幅度增加開發速度，但絕對會讓你在開發時有更多其他潛在更好的選擇來達成你的需求。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:22.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    24 分鐘 閱讀文 (大約 3553 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-28/">JS 原力覺醒 Day28 - JS 裡的資料結構</a>
            
        </h1>
        <div class="content">
            <p>隨著硬體規格條件的提升， 網站商業邏輯的運作也慢慢從以往的後端伺服器轉移到客戶端，因此前端領域的專業知識就變得越來越重要，隨著前端技術被重視，也開始慢慢出現 React 、 Vue 、 之類前端框架的生態圈出現，而後端則慢慢演變為單純的 API 伺服器負責提供資料的存取端口。同樣的，畫面的互動也是另一個越來越被注重的部分，<strong>因此怎麼實作出更精緻優雅的前端介面以及互動邏輯也是前端工程師們面臨的新挑戰之一</strong>。這些在在的都考驗了工程師們對 JS 這個語言本身更全面的了解。</p>
<p>如同前面所說，隨著商業邏輯慢慢著重在前端，<strong>許多資料的規格訂定也常常會跟隨著介面的結構而有所不同</strong>，這些隨著前端邏輯而被暫存在前端的資料，變得有點像是後端伺服器放在前端的副 @本。所以，前端工程師的經驗跟專業，就會在<strong>資料結構的選擇與判別使用的時機的能力上顯現出差異</strong>，而某些資料結構我們在前面的文章多多少少都有提到一些了。在這篇文章內，我想較全面的，對在開發上，常使用到或常見的資料結構做一些說明。</p>
<p>基本上有三種類型資料結構：</p>
<ul>
<li>陣列型態的資料結構 ：Stack 、Queue</li>
<li>以「節點」為基礎的：Linked Lists、 Trees</li>
<li>在資料查找上非常方便的： Hash Tables</li>
</ul>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Stack</li>
<li>Queue</li>
<li>Linked Lists</li>
<li>Trees</li>
<li>Hash Tables</li>
<li>總結</li>
<li>參考文章</li>
</ul>
<h2 id="stack"><a class="header-anchor" href="#stack"></a>Stack</h2>
<p>Stack 具有後進後出的特性，堆疊的概念我相信各位 JS 工程師都已經非常熟悉了，而這大概也是 JS 內最重要的資料結構了，在之前講到執行環境堆疊的時候有提過。以程式的方式來說，堆疊的結構就是一個具有 <code>push</code> 跟 <code>pop</code> 兩個方法的陣列，<code>push</code> 可以把元素放到堆疊的最上層，而 <code>pop</code> 可以把元素從堆疊的最上層拿出來。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580fh2OZ6eKkv.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580fh2OZ6eKkv.jpg"></p>
<h2 id="queue"><a class="header-anchor" href="#queue"></a>Queue</h2>
<p>Queue，序列 也是 JS 語言的核心部分之一，Queue 具有「先進先出」的特性，還記得我們之前提到的 Event Queue 、 MacroTask Queue 以及 MicroTask Queue 嗎？因為有了 Queue 這種樣子的資料結構，JS 才能夠具有非同步這麼具有識別度的特性。那麼以程式的角度來看，Queue ㄧ樣是有兩種方法的陣列：<code>unshift</code> 與 <code>pop</code>。 <code>unshift</code> 可以把元素放到 Queue 的最尾端，而 <code>pop</code> 則是把元素從最前端取出來，Queue 也可以反向操作，只要把 <code>unshift</code> 與 <code>pop</code> 換成 <code>shift</code> 與 <code>push</code>。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580JRDdzjisVa.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580JRDdzjisVa.jpg"></p>
<h2 id="linked-list"><a class="header-anchor" href="#linked-list"></a>Linked List</h2>
<p>Linked List ，鏈結串列是一種有序的、且線性的資料結構，在 Linked List 上每一筆資料都可以被看作是一個節點 ( Node )，每個節點上都包含了兩個資訊：一個是要儲存的數值、一個是指向其他節點位置的指標。Linked List 具有以下特性：</p>
<ul>
<li>是被一個一個指標串連起來的</li>
<li>第一個節點被稱為 <code>head</code> ，是一個指向第一個節點的參考指標</li>
<li>最後一個節點被稱為 <code>tail</code> 節點，是指向最後一個節點的參考指標</li>
<li>最後一個指摽指向的是 <code>null</code></li>
</ul>
<p>Linked List 基本上有 單向（ singly ） 跟 雙向 ( doubly )  兩種類型，在單向的鏈結串列中，只存在一個指向下一個節點的指標。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580Jh38FNHdmU.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580Jh38FNHdmU.jpg"></p>
<p>而在雙向的鏈結串列中，則會有兩個指標，一個指向上一個節點，一個指向下一個節點。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580nZx8X7Mikl.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580nZx8X7Mikl.jpg"></p>
<p>Linked List 由於結構的關係，可以在頭、尾，任何地方插入節點，因為只要改變指標的指向就可以了，所以只要搞懂運作方式，他也能實現前面提到的 Queue  跟 Stack 結構的行爲。Linked List 在前後端開發上也很有幫助，在前端 React 框架常常搭配使用的狀態管理器 Redux  中，從畫面到 Action 到 Reducer 這樣子的資料流，就使用了 Linked List 的思考方式，來決定資料的下一個目標（ 函式 )。在後端 Express 框架上則用 Linked List 來處理 Http Request 與 Middleware 層的資料流動。</p>
<p>接下來讓我們以雙向的鍊結串列來看看實際上在 JS 內是怎麼使用的，首先我們會需要節點的類別，這樣我們就可以自己指定節點跟下一個節點：</p>
<pre><code>class LinkedNode {
		constructor(value,prev,next){
				this.value = value;
        this.next = next;
        this.prev = prev;
		} 
} 
let head = new LinkedNode(null,null,null)
let node1 = new LinkedNode(1,head,null)

let node2 = new LinkedNode(2,node1,null) 
let node3 = new LinkedNode(3,node2,null) 

node1.next = node2
node2.next = node3
</code></pre>
<p>然後我們可以再創一個 LinkedList 類別來記錄這些節點間的關係，</p>
<pre><code>class LinkList {
	constructor(value,prev,next){
		this.head = null 
		this.tail = null
		this.lenght = 1
	} 
	addToHead(){
	} 
}
</code></pre>
<p>Linked List 要能再頭地方加入新的節點成為新的 head，因此加入輔助函式看看：</p>
<pre><code>class LinkedNode {
		constructor(value,prev,next){
				this.value = value;
        this.next = next;
        this.prev = prev;
		} 
} 

class LinkList {
	constructor(value){
		this.head = null 
		this.tail = null
		this.addToHead(value)
		this.lenght = 0
	} 
	addToHead(value){
		const newNode = new LinkedNode(value);
		newNode.next = this.head; // 讓原本的 head 成為新節點的 next
		newNode.prev = null // head 並沒有前一個節點 
		this.head = newNode // 最後把原來的 head 換成新的節點
		
		this.lenght += 1
		return this.head
	} 
}

let newList = new LinkList('first')
newList.addToHead('second')
newList.addToHead('third') 

newList.head.value // third 
newList.head.next.value  //second
newList.head.next.next.value //first
</code></pre>
<p>接下來我們再實作一個可以從中間刪除任意節點的方法，要找到 Linked List 的某一個數值並且刪除，就只能用尋訪的方式一個一個尋找，這裡我們用 while 回圈以一個類似遞迴的方式來尋找：</p>
<pre><code>class LinkList {
	constructor(value){
		this.head = null 
		this.tail = null
		this.addToHead(value)
		this.lenght = 0
	} 
	addToHead(value){ ...	} 
	removeFromHead(){
			if(!this.head.next) this.head.next = null
			const value = this.head.value;
			this.head = this.head.next 
			this.length-- 
			return value
	} 
	remove(val) {
    if(this.length === 0) {
        return undefined;
    }
    
    if (this.head.value === val) {
        this.removeFromHead();
        return this;
    }
    
    let previousNode = this.head;
    let thisNode = previousNode.next;
    
    while(thisNode) { 
				// thisNode 的參考會隨著 while 而不斷的往 next 去尋找
        if(thisNode.value === val) {
            break;
        }
        
        previousNode = thisNode; // 同時也會不斷紀錄前一個節點
        thisNode = thisNode.next;
    }
    
    if (thisNode === null) {
        return undefined;
    }
    
    previousNode.next = thisNode.next; // 一旦成功找到要刪除的節點，才能夠順利銜接前後節點，達到刪除的效果
    this.length--;
    return this;
}
}
</code></pre>
<p>示範實做跟說明幾個函式到這邊，基本上只要知道怎麼修改節點的指向，就可以了解怎麼實作這些操作 Linked List 的方法，包括從 head 刪除節點、從中間新增、刪除節點，以及從最後面新增、刪除，讀者可以自己練習完成看看。</p>
<h2 id="tree"><a class="header-anchor" href="#tree"></a>Tree</h2>
<p>樹的結構跟 Linked List 有點像，也是從一個節點開始往下長，差別在於 Linked List 裡一個節點只能對到另一個節點，而在樹狀結構內，一個節點可以對到好幾個其他節點，也稱為子節點（ Child Node ) ，之前我們講到的 DOM ，正是一種樹狀結構，最上層的 <code>html</code> 是上層節點，而往下延伸出 <code>body</code> 與 <code>head</code> 等下層子節點。</p>
<p>而樹的結構也可以被加上特殊的規則，例如常聽見的<strong>二元樹結構，</strong> 就是從樹狀結構演變而來，因為在二元樹裡面，每個節點被規定只能擁有另外兩個子節點。而且左邊子節點的數值只能小或等於父節點的數值，而右邊子節點的數值必須大於父節點的數值，以這樣子排列方式，我們就可以有規律的去搜尋或是操作我們需要的節點，例如，整個二元樹的最小值可以在最左邊且最後代的子節點被找到，反之在最右邊後代節點則可以找到最大值。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580EJC2fUxHnF.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580EJC2fUxHnF.jpg"></p>
<p>在樹的搜尋上則有兩種相似的方式：</p>
<ol>
<li>
<p>深先搜尋 ( Depth-First Traversal, DFT ) ：</p>
<p>把樹想成由最上面開始往下生長的結構，深先搜尋就是從最上面的根節點，往下垂直的搜尋，深先搜尋裡又分為三種走訪順序，以上面的二元樹圖為例，分別是：</p>
<ul>
<li>
<p>前序 （ Pre Oreder ) ：</p>
<p>順序：訪問根節點 → 訪問左子樹 → 訪問右子樹</p>
<p>上圖順序： A → B → D → G → C → E → F → H</p>
</li>
<li>
<p>中序 ( In Order ) ：</p>
<p>順序：訪問左子樹 → 訪問根節點 →訪問右子樹</p>
<p>上圖順序： D → G → B → A → E → C → F → H</p>
</li>
<li>
<p>後序 （ Post Order ）：</p>
<p>順序：訪問左子樹 → 訪問右子樹 → 訪問根節點</p>
<p>上圖順序： G → D → B →  E → H → F  → C → A</p>
</li>
</ul>
</li>
<li>
<p>廣先搜尋 Breadth-First Traversal , BFT )</p>
<p>廣先搜尋則跟深先搜尋相反，是以水平方向為主的搜尋方式，在樹狀結構裡面，每往下長出一個子節點，就會被視為一層。深先搜尋在執行時是先查看節點有無子節點，如果有的話就盡量往下去搜尋，而廣先搜尋則是在搜尋時先檢查子節點有無其他同一層的節點，然後將這些同層子節點記錄下來，一個一個去搜尋，因此在執行廣先搜尋時，必須用到 Queue 來輔助。</p>
<p>上圖順序： A → B → C → D → E → F → G → H</p>
</li>
</ol>
<p>樹狀結構與前面鍊狀串列結構實作方法相似，而且樹狀結構若要往下探討可以有很多種變形，例如把不同層的節點串在一下之後就會變成複雜的圖 ( Graph )，這些內容多到可以再寫一篇文章，因此在這邊先不提供範例。</p>
<h2 id="hash-table"><a class="header-anchor" href="#hash-table"></a>Hash Table</h2>
<p>雜湊表是根據鍵值 （ Key ) 來查找對應記憶體位置的資料結構。陣列就是一個很類似 Hash Table 的結構，只不過陣列是利用「索引」來查找資料，因此只能是數字。</p>
<p>可以把 Hash Table 想成是建立在陣列上，透過將不同字串轉成對應的陣列索引來查找，而達到比較靈活的鍵值查找，要達到這樣子的效果，我們會需要實作一個 Hash Function ，來把字串轉換成索引。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191013/20106580GqUPG5Zh4e.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191013/20106580GqUPG5Zh4e.jpg"></p>
<p>Hash Function 的運作方式大概會是給每個字元對應的可運算數值，當要查找的時候就把字串內所有字元的數值加起來然後給陣列當成索引值，如果加起來的數值太大，陣列沒有那麼多空間，就必需透過另外的規則簡化（如：加完的數值 mod 10 ) 來取得對應、可行的索引。</p>
<pre><code>getCharNum(char){
	return charCodeAt(char)
}
hashFunction (key) {
	let hashCode = 0 	
	key.split('').forEach(char=&gt;{
		hashCode  += getCharNum(char)		
	}) 	
	return hashCode % 10 
} 
</code></pre>
<p>上面是一個 hash function 的實作，當然這只是簡化的範例而已，真正應用在現代系統環境的實作邏輯複雜非常多。透過 Hash Table 的運作方式我們可以利用字串來存取對應的數值，有沒有覺得很熟悉，想到什麼？沒錯就是 JS 的物件！從結果來看 JS 的物件非常像是 Hash Table 的結構，不過根據我的調查結果，有一說是這點會根據 JS 引擎的實作而有所差異，有些引擎裡面是透過混合 Linked List 跟 Hash Table 兩種資料結構來實作物件。</p>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>終於講完了這些常見的資料結構，看完之後你應該可以發現這些資料結構大概有一半在前面 JS 相關內容都有提到，分別是：</p>
<ul>
<li><strong>Stack</strong> ：Call Stack</li>
<li><strong>Queue</strong> ：Task Queue</li>
<li><strong>Linked Lists</strong> ：原型鍊</li>
<li><strong>Tree</strong> : DOM</li>
<li><strong>Hash Table</strong> : 物件的 鍵 -值 結構</li>
</ul>
<p>這些部分如果不深入去看這個語言運作方式的話是不會發覺的，這些資料結構也可以應用在許多系統資料的運算。雖然這個章節只能很粗淺的介紹，但我希望讓原本不熟悉資料結構的人，下次再看到類似的東西可以不會那麼害怕，也能夠更冷靜地往下研究原本要鑽研的知識細節。</p>
<h2 id="參考文章"><a class="header-anchor" href="#參考文章"></a>參考文章</h2>
<p><a href="%5Bhttps://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c%5D(https://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c)">Data Structures in JavaScript</a></p>
<p><a href="%5Bhttps://codeburst.io/objects-and-hash-tables-in-javascript-a472ad1940d9%5D(https://codeburst.io/objects-and-hash-tables-in-javascript-a472ad1940d9)">Objects and Hash Tables in Javascript</a></p>
<p><a href="%5Bhttps://www.hackerearth.com/zh/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/%5D(https://www.hackerearth.com/zh/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/)"> Basics of Hash Tables </a></p>
<p><a href="%5Bhttps://www.interviewcake.com/concept/java/hash-map%5D(https://www.interviewcake.com/concept/java/hash-map)">Hash Table </a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:20.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分鐘 閱讀文 (大約 1773 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-27/">JS 原力覺醒 Day27 - JS 常用 API - Object.assign &amp;&amp; Object.defineProperty</a>
            
        </h1>
        <div class="content">
            <p>今天要講的是是兩個在操作物件時常用到的 JS API ，有時候我們會需要做一些比較進階的操作，例如對物件屬性做一些比較細節的微調；還有複製物件，但是複製物件的話，因為物件傳參考的特性的關係，在結構複雜的物件上，往往需要特別處理，例如物件內的屬性是另外一個物件。所以我們也會帶到「深拷貝」和「淺拷貝」的概念。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Object.defineProperty</li>
<li>Object.assign</li>
<li>深拷貝</li>
<li>淺拷貝</li>
</ul>
<h2 id="object-defineproperty"><a class="header-anchor" href="#object-defineproperty"></a>Object.defineProperty</h2>
<p><code>Object.defineProperty</code> 其實是 <code>Object</code> 函式建構子上的靜態方法（還記得 Obejct  其實是一個函式？），用來對某個物件直接定義一個新的屬性，用法如下：</p>
<pre><code>const object1 = {};

Object.defineProperty(object1, 'property1', {
  value: 42,
  writable: false
}); 
</code></pre>
<p>這個方法接受三個參數，<strong>第一個是要新增屬性的目標物件，第二個是屬性名稱，第三個是這個屬性的描述器設定。</strong> 屬性的描述器？那是什麼？</p>
<p>JS 內物件屬性的描述器有兩種類型，每一種各有不同設定值：</p>
<ul>
<li>
<p><strong>資料描述器 ( Data descriptor )：</strong></p>
<p>資料描述器是一個帶有值的屬性，其實也就是你要定義屬性的 <code>value</code> 啦。這個屬性有可能是可修改、或是不可被修改的。</p>
</li>
<li>
<p><strong>存取描述器 ( Accessor descriptor )：</strong></p>
<p>存取描述器定義的內容包含的 <code>getter</code> 與 <code>setter</code> 兩個函式。要怎麼存、取這個屬性，就是由存取描述器來負責的。</p>
</li>
</ul>
<p>兩種描述器都有屬於自己的屬性設定值，先分別介紹：</p>
<ol>
<li>資料描述器上，有兩個可選值：</li>
</ol>
<ul>
<li><strong>value ( undefined )</strong> : 定義這個屬性對應的值。</li>
<li><strong>writable （ false ）</strong>:  定義這個屬性是某可以被指派，如果為 <code>true</code> 就代表這個屬性可以透過  如 <code>ob.name= 'new value'</code> 被更新。</li>
</ul>
<ol start="2">
<li>存取描述器上也有兩個可選值：</li>
</ol>
<ul>
<li><strong>get ( undefined )</strong> : 即物件的 <code>getter</code> 函式，是一個定義物件如何被取用的函式，當物件屬性被取用的時候會被呼叫。</li>
<li><strong>set ( undefined )</strong>  : 即物件的 <code>setter</code> 函式，是一個定義物件如何被指派的函式。</li>
</ul>
<p>剩下的幾個設定值是兩種描述器都能夠使用且可選、非必須的。分別是（ 括號內的是預設值 ）：</p>
<ul>
<li><strong>configurable ( false )</strong> : 定義了這個物件屬性的描述器設定是否可以被修改，如<code>enumerable</code> 、 <code>writable</code> 、 或是自己本身 <code>configurable</code> 。</li>
<li><strong>enumerable  ( false )</strong> : 定義這個屬性在物件裡就屬於可以被巡訪的，也就是使用 <code>Object.keys</code> 或是 <code>for...in</code> 來對物件作遍歷的時候能不能夠存取到。</li>
</ul>
<p><strong>而要定義的物件屬性的描述器必須一定要是上述兩者中的其中一種，兩者無法同時屬於兩者。</strong></p>
<h3 id="example-描述器預設值"><a class="header-anchor" href="#example-描述器預設值"></a>Example - 描述器預設值</h3>
<pre><code>var o = {}; // 創造新物件 

Object.defineProperty(o, 'a', {}); // empty descriptor setting

Object.getOwnPropertyDescriptor(o,'a')  
//預設描述器值：
// configurable : false 
// value : undefined 
// writable : false 
// enumable : false 
</code></pre>
<p>剛剛說描述器無法同時是資料描述器跟存取描述器，也就是說在 ****<code>defineProperty</code> 的第三個參數描述器設定內，如果有 <code>get</code> 這個設定值出現，就不能再有 <code>value</code> ，否則就會報錯：</p>
<pre><code>var o = {}; // 創造新物件 

Object.defineProperty(o, 'a', {
  value: 37,
  writable: true,
  enumerable: true,
  configurable: true,
	get(){
		return 123
	}
});

//Invalid property descriptor. Cannot both specify accessors and a value or writable attribute
</code></pre>
<h3 id="example-自訂-getter-與-setter-函式"><a class="header-anchor" href="#example-自訂-getter-與-setter-函式"></a>Example - 自訂 <code>getter</code> 與 <code>setter</code> 函式</h3>
<p>自訂 <code>getter</code> 與 <code>setter</code> 一樣是在  <code>Object.defineProperty</code> 裡面的第三個參數自訂屬性的行為：</p>
<pre><code>var o = {}; 
Object.defineProperty(o, 'a', {
		get() {
        return 'It will return this value if I access o.a' ;
    },
    set() {
        this.myname = 'this is my name string';
    }
});
</code></pre>
<h2 id="object-assign"><a class="header-anchor" href="#object-assign"></a>Object.assign</h2>
<p><code>Object.assign</code> 用來複製所有物件內可被尋訪 (Enumable) 的屬性，而且複製的來源不限於某個物件，可以多個物件一起進行屬性的複製，這個方法的第一個參數跟 <code>defineProperty</code> ㄧ樣都是目標物件，後面可以有複數個參數，就是要被複製屬性的來源。而使用 <code>Object.assign</code> 來進行複製的時候，後面的相同物件屬性會蓋掉前面相同的物件屬性：</p>
<pre><code>let b = Object.assign({foo: 0}, {foo: 1}, {foo: 2});
ChromeSamples.log(b)
// {foo: 2}
</code></pre>
<p>所以，如果我想要複製某一物件的內容到一個全新的物件上的話，只要這麼寫：</p>
<pre><code>let oldObject = {
	a:'a', 
	b:{
		c:'cinsideb'
	}
} 

let newObject = Object.assign({},oldObject)

console.log(newObject) //{a: &quot;a&quot;, b: {…}}
</code></pre>
<p>另外，如果只是單純要把某個物件內容複製到另外一個物件，可以用 ES6 後的新的、比較簡潔好閱讀的寫法 Spread ，也可以達到一樣的效果：</p>
<pre><code>let newObject = { ...oldObject }
</code></pre>
<h2 id="淺拷貝-shallow-copy"><a class="header-anchor" href="#淺拷貝-shallow-copy"></a>淺拷貝 ( Shallow Copy )</h2>
<p>在使用 <code>Object.assign</code> 時有一個要注意的地方，就是他雖然可以複製屬性，但要是物件屬性的內容也是另外一個物件時，從這個屬性複製到新物件上的，也只會是這個內層物件的參考，而不是這個物件的拷貝，這個現象就稱為淺拷貝（可以理解為，只複製最外層屬性，往下被複製的都只有參考）。</p>
<pre><code>let oldObject = {
	a:'a', 
	b:{
		c:'c'
	}
} 

let newObject = Object.assign({},oldObject)

newObject.b.c = 'modified c' 

console.log(oldObject) 
/* {
	a:'a', 
	b:{
		c:'modified c'
	}
} */
</code></pre>
<p>由上就可以看出，當我修改新的物件的內層屬性物件時，被複製的物件的內層屬性物件 (<code>b.c</code>)，也會跟著一起被改動。</p>
<h2 id="深拷貝-deep-clone"><a class="header-anchor" href="#深拷貝-deep-clone"></a>深拷貝 （ Deep Clone )</h2>
<p>相對於淺拷貝，深拷貝就是完全的複製整個物件內容了。那麼如果要達到這個效果，我們可能要自己動手處理，檢查要複製物件的某屬性是不是物件，如果是的話，就要再以<code>Object.assgn</code> 複製一次，並且這個檢查要搭配遞迴的概念來檢查，才能確保完全的複製。</p>
<pre><code>function cloneDeep(obj){
            if( typeof obj !== 'object'  ){
                return obj
            }
            let resultData = {}
            return recursion(obj, resultData)
        }

function recursion(obj, data={}){
						//對物件屬性做巡訪
            for(key in obj){
                if( typeof obj[key] === 'object'){
										// 如果是物件就繼續往下遞迴
                    data[key] = recursion(obj[key])
                }else{
										// 如果不是物件的話就直接指派
                    data[key] = obj[key]
                }
            }
            return data
        }
let player = {name:'Anakin',friend:{robot:'R2D2'}}
let player2 = cloneDeep(player)
obj.name = 'Darth Vader!!!'
player2.friend.robot = 'no!!!'
console.log(player) // {name:'Anakin猿',friend:{robot:'R2D2'}}
</code></pre>
<h2 id="參考文件"><a class="header-anchor" href="#參考文件"></a>參考文件</h2>
<p><a href="%5Bhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description%5D(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description)"> MDN 官方文件的說明 </a></p>
<p><a href="%5Bhttp://arqex.com/967/javascript-properties-enumerable-writable-configurable%5D(http://arqex.com/967/javascript-properties-enumerable-writable-configurable)"> Javascript properties are enumerable, writable and configurable</a></p>
<p><a href="%5Bhttps://kanboo.github.io/2018/01/27/JS-ShallowCopy-DeepCopy/%5D(https://kanboo.github.io/2018/01/27/JS-ShallowCopy-DeepCopy/)">JS-淺拷貝(Shallow Copy) VS 深拷貝(Deep Copy)</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:18.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    9 分鐘 閱讀文 (大約 1322 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-26/">JS 原力覺醒 Day26 - 常用 API： setTimeout / setTimeInterval</a>
            
        </h1>
        <div class="content">
            <p>來講一下常用到的瀏覽器 API ，其實前面在講 Event Queue 的時候就已經提過 setTimeout 了，不過這邊就讓我們從更具實用性的層面來看這些方法。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>setTimeout / setInterval  使用</li>
<li>setTimeout / setInterval  清除</li>
<li><code>this</code> in  setTimeout / setInterval callback</li>
<li>解決回呼函式內 this 的問題</li>
<li>setTimeout / setInterval 、迴圈與 Closure</li>
</ul>
<h2 id="settimeout-setinterval-使用"><a class="header-anchor" href="#settimeout-setinterval-使用"></a>setTimeout / setInterval  使用</h2>
<h3 id="settimeout"><a class="header-anchor" href="#settimeout"></a>setTimeout</h3>
<p>前面有提到 setTimeout 的基本使用方式，而第一個參數傳入的 callback 會被推送到 Event Queue ，待主執行環境堆疊清空以後，才會被執行 ，所以就算第二個參數設定的時間是 0 秒，也不會立刻執行。</p>
<pre><code>function step(stepNum){
	console.log(`step${stepNum}`)
}

step('1') 
setTimeout(function(){step('2')},0)
step('3')

// will print: step1 --&gt; step3 --&gt; step2
</code></pre>
<h3 id="setinterval"><a class="header-anchor" href="#setinterval"></a>setInterval</h3>
<p>setInterval 使用方式與 setTimeout 的語法相同，差在 setTimeout 只會執行一次，而 setInterval 則會根據開發者給的時間間隔，每隔一段時間執行一次。</p>
<pre><code> setInterval(function(){console.log('da')  },1000)
// print : da -&gt; da -&gt; da
</code></pre>
<h2 id="settimeout-setinterval-清除"><a class="header-anchor" href="#settimeout-setinterval-清除"></a>setTimeout / setInterval  清除</h2>
<p>由於 <code>setTimeout</code> /  <code>setInterval</code> 函式本身會回傳一個計時器 id ，我們就可以把這個 id 記錄下來，當頁面要離開用不到的時候使用 <code>clearTimeout</code> / <code>clearInterval</code> 將他們清除：</p>
<pre><code>let timerId = setInterval(function(){
	console.log('do something') 
},1000) 
</code></pre>
<p>清除計時器在以前可能還不是會非常被注重的問題，但是像現在主流前端框架把渲染工作交給 JS ，如果使用虛擬路由來控制頁面切換的話，就算頁面切換了，JS 檔案也不會重新載入，主執行環境會一直存在，因此前面設定的計時器在不需要時如果沒有清除，就可能會造成頁面運算的負擔。</p>
<h2 id="this-in-settimeout-setinterval-callback"><a class="header-anchor" href="#this-in-settimeout-setinterval-callback"></a><code>this</code> in  setTimeout / setInterval callback</h2>
<p><code>setTimeout</code> / <code>setInterval</code> 裡第一個回呼函式內的 <code>this</code> 如果沒有經過處理的話，預設都是指向全域環境 <code>window</code> ，因為這兩個都是屬於 <code>window</code> 物件底下的函式，我們可以推斷我們傳進去的回呼函式是在裡面被執行。雖然沒辦法直接看到 setTimeout 裡面的原始碼，不過可以推斷內容大概是像這樣 ，下面以 Pseudo code 示意：</p>
<pre><code> window  = {
		... 
		setTimeout:function(timerFunc,time){
			//several minutes later...
			timerFunc() 
		} 
}
</code></pre>
<p>之前提過在思考 <code>this</code> 的連結的時候，有提到，「如何呼叫」函式將會影響 <code>this</code> 的指向，想一想「隱含」的繫結， 再對比上面的 <code>setTimeout</code> 內容，可以看出我們傳入的回呼函式在 <code>setTimeout</code> 被呼叫，但因為是直接呼叫，沒有隱含繫結，因此在內的 <code>this</code> 會指向全域。</p>
<h2 id="解決回呼函式內-this-的指向問題"><a class="header-anchor" href="#解決回呼函式內-this-的指向問題"></a>解決回呼函式內 this 的指向問題</h2>
<p>承上一段，那要怎麼樣才能讓 <code>this</code>  指向目前所屬的執行環境，讓開發者在撰寫程式碼的時候更不容易誤解？</p>
<h3 id="方法一"><a class="header-anchor" href="#方法一"></a>方法一</h3>
<p>有一個方法是：使用箭頭函式，因為箭頭函式內沒有 <code>this</code> ，更準確來說， 箭頭函式內的 <code>this</code> 與他外部語彙範疇的 <code>this</code> 相等。</p>
<pre><code>let boss = 'Yoda'
let user = {
	name:'Luke',
	introduce:function(){
		setTimeout(()=&gt;{
			console.log('hey, ' + this.name) 
		},1000) 
	} 
} 
user.introduce() // print : hey,Luke
</code></pre>
<h3 id="方法二"><a class="header-anchor" href="#方法二"></a>方法二</h3>
<p>另外一個方法是，使用 <code>Function.bind</code>，這個方法跟 <code>call</code> 或 <code>apply</code> 都可以指定函式執行環境內要綁定的 <code>this</code> ，差別在呼叫 <code>bind</code> 後會回傳一個全新、綁定過 <code>this</code> 的函式。</p>
<pre><code>let user = {
	name:'Luke',
	introduce:function(){
		setTimeout(getName.bind(this),1000) 
	} 
} 

function getName(){
	console.log('hey, '+ this.name)	
} 

user.introduce() // print : hey,Luke
</code></pre>
<h2 id="settimeout-setinterval-迴圈與-closure"><a class="header-anchor" href="#settimeout-setinterval-迴圈與-closure"></a>setTimeout / setInterval 、迴圈與 Closure</h2>
<p>這段要講的大概是最經典的面試考題，只要講到跟 Closure 有關的問題，通常一定會提到迴圈。<br>
先來看這段例子：</p>
<pre><code>for(var i =0;i&lt;10;i++){
	setTimeout(
		function (){
			console.log(i)
	},1000) 
}
</code></pre>
<p>在一秒過後我們就很驚訝的會發現， JS 吐出了 10 個 <code>10</code> 給我們，這是因為 <code>var</code> 宣告是屬於 <code>function scope</code> 但是 <code>for</code> 迴圈並不是 <code>function</code> ，所以在之內宣告的變數 <code>i</code> 就等於是全域變數。也因此無法透過 <code>fucntion</code> 產生函式執行堆疊或閉包，於是這個回呼函式會被推到 Event Queue，待時間到要執行，去獲取<code>i</code> 的時候，全域的 <code>i</code> 早就已經被 <code>for</code> 迴圈修改而成為<code>10</code>了 ，所以才會有這樣子的結果</p>
<h3 id="解方："><a class="header-anchor" href="#解方："></a>解方：</h3>
<p>要解決這個問題我們只要想辦法讓維持 setTimeout 回呼函式與每個 i 的聯繫即可，還記得 <code>let</code> 屬於 <code>block scope</code>  ？所以用 <code>let</code> 產生的變數是綁在會在不同的 block 上 ，對 <code>for</code> 回圈來說，每次 <code>i+1</code> 的迴圈迭代之後的，都是一個新的 block，再搭配 <code>block scope</code> 的特性，就可以在每個 <code>block</code> 留下與每個 <code>i</code> 的連結：</p>
<pre><code>for(let i =0;i&lt;10;i++){
	setTimeout(
		function (){
			console.log(i)
	},1000) 
}

// print : 1,2....10
</code></pre>
<p>或是ㄧ樣利用 <code>function scope</code> 的特性：</p>
<pre><code>for(var i=0;i &lt; 10; i++){
	getValueOf_i(i)
}

function getValueOf_i(i){
	setTimeout(function(){
		console.log(i)
	},1000) 
} 
</code></pre>
<p>這樣一來當 <code>i</code> 以參數形式傳入另外一個函式時，就會被函式執行環境保留而產生閉包。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:16.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分鐘 閱讀文 (大約 1864 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-25/">JS 原力覺醒 Day25 - CRP : 關鍵渲染路徑</a>
            
        </h1>
        <div class="content">
            <p>當使用者進入頁面、瀏覽器收到請求並回傳前端相關檔案後，到最後使用者看到的畫面呈現之前，還有很多步驟會被執行，這一連串步驟的總和就稱為 Critical Rendering Path ( 中譯：關鍵渲染路徑），了解關鍵渲染路徑，在網站前端頁面需要做效能優化時，就可以比較容易知道，要從哪裡下手。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<p>關鍵渲染路徑（以下簡稱 CRP ) 大致上會執行以下六個步驟：</p>
<ol>
<li>建構 DOM Tree</li>
<li>建構 CSSOM Tree</li>
<li>執行 JavaScript</li>
<li>創造渲染樹</li>
<li>產生畫面佈局</li>
<li>繪製、產生畫面</li>
</ol>
<p>下面就讓我們一個步驟一個步驟詳細來看：</p>
<h2 id="step1-建構-dom-tree"><a class="header-anchor" href="#step1-建構-dom-tree"></a>Step1. 建構 DOM Tree</h2>
<p>前一章節有講到網頁的 DOM 是根據 HTML 內容而來，這個轉換的過程有點像這個系列一開頭我們討論 JS 語法解析那段，瀏覽器會根據 HTML Tag 將內容轉為一個一個 Token （標記）</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191010/201065802PnTTlOshi.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191010/201065802PnTTlOshi.jpg"></p>
<p>之後會根據這些 Token 將對應的標籤轉換成節點，之後根據 Token 的前後關係產生出 DOM Tree  。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191010/20106580peW9V1tTe4.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191010/20106580peW9V1tTe4.jpg"></p>
<h2 id="step2-建構-cssom-tree"><a class="header-anchor" href="#step2-建構-cssom-tree"></a>Step2.  建構 CSSOM Tree</h2>
<p>CSSOM ( CSS Object Model ) 是代表跟 DOM 元素對應樣式的物件。他的表現形式跟 DOM 很像，只是 CSSOM 是依附著每個節點，各個節點都會有對應的樣式 ( Style )，所以基本上 CSSOM Tree 跟 DOM Tree 長的會很像。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191010/20106580iAbwkUacyT.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191010/20106580iAbwkUacyT.jpg"></p>
<p>這邊要注意的是，CSS 在頁面載入行為裡，是屬於鎖定渲染的資源( Render Blocking Resource ），意思是，在頁面仔入時，只要還沒有拿到所有的 CSS 檔案並成功載入，那瀏覽器就會等到完成載入為止，這意味著，每個網頁上的  CSS 檔案，都會拖到載入速度。</p>
<p>除了 Render Blocking ，也有人說 CSS 是 「Script Blocking 」，因為在瀏覽器載入所有的 CSS 檔案之後，瀏覽器才會進入的我們的下一步「執行 JS」。 在產生 CSSOM 時，越多層的選擇器，在元素與樣式的匹配上會需要更多時間來進行。以下面這兩個 CSS 類別為例：</p>
<pre><code>A : p {  color:red; } 

B : div h1 { font-size:22px;}
</code></pre>
<p>第二種 B 情況的 CSS 會需要更多時間來做匹配，首先瀏覽器會先找到頁面上所有的 <code>h1</code> 元素，而後在看這個元素的父類別是不是一個 <code>div</code> 元素 ，因此瀏覽器在匹配樣式時其實是以「從右邊到左邊」的順序來進行的，所以現在你就了解，如果你有加速前端渲染速度的請求，就要減少 CSS 選擇器層級的長度，在這方面，BEM 的 CSS 命名撰寫風格就把層級關係透過命名的方式來表達，同時也大幅度的減少選擇器的少用次數，建議對 CSS 有興趣鑽研的人一定要看一下。</p>
<p>類似的命名風格或規範，除了 BEM 之外還有 OOCSS 跟 SMACSS ，這些規範都是透過一些原則，來達到最大程度的減少重複，除了好維護之外，其實也能提升畫面渲染的效率，這也是為什麼這些規範常常被資深前端人員提起、並視為圭臬的原因。</p>
<h2 id="step3-執行-js"><a class="header-anchor" href="#step3-執行-js"></a>Step3.  執行 JS</h2>
<p>JS 則是鎖定轉譯，在 JS 執行完之前，瀏覽器都不會繼續做 HTML 文件的轉譯跟建構。當瀏覽器轉譯時碰到 <code>&lt;script&gt;</code> ，他會停下來等到 JS 執行完成之後才會再往下。這也是為什麼我們常常說要把 &lt;<code>script&gt;</code> 標籤放到整個網頁最後面的原因。</p>
<h2 id="step4-創造渲染樹"><a class="header-anchor" href="#step4-創造渲染樹"></a>Step4.  創造渲染樹</h2>
<p>渲染樹 (Rendering Tree) 其實就是 DOM 搭配 CSSOM 的結果，在用白話一點的方式來說，就是「<strong>最後會被渲染在畫面上」的結構樹</strong>，所以如果 CSS 樣式導致某個 Node 沒辦法顯示，（ 如<code>display:none</code> )，那麼他就不會出現在渲染樹上。</p>
<h2 id="step-5-產生畫面編排-layout"><a class="header-anchor" href="#step-5-產生畫面編排-layout"></a>Step.5 產生畫面編排 ( Layout )</h2>
<p>我們已經取得代表元素層級關係的 DOM 樹結構，也匹配了個元素對應的樣式，最終搭配兩者產生出了渲染樹，現在我們離最後產生可視畫面的階段已經不遠了，但是還差一個步驟，我們還必須弄清楚所有元素的實際位置，以及元素該如何呈現，那就是產生畫面編排 ( Layout ) 的步驟。</p>
<p>Layout 產生的方式，會跟 <code>meta tag</code>  裡面的 viewpoint 屬性有很大的關係：</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
</code></pre>
<p><code>viewpoint</code> 的 <code>meta</code> tag 用來告訴瀏覽器，頁面要怎麼縮放，還有維度，就是指畫面像素（瀏覽器畫面）跟螢幕像素（硬體）的比例，<code>content</code> 之中，<code>width</code> 用來設定瀏覽器畫面寬度是多少，把他設定成 <code>device-width</code> 的話就是在告訴瀏覽器，畫面顯示的螢幕寬度要跟硬體裝置相同（手機、電腦），如果沒給 <code>width</code> 值的話，瀏覽器就會使用預設的 <code>980px</code> 來當作預設的畫面顯示寬度。這個屬性在 HTML5 後出現，常用在 RWD 的設計實作之中。 <code>initial-scale=1.0</code> 是指預設的縮放程度，最常見的值也是預設值，就是 <code>1</code> 。</p>
<h2 id="step6-繪製-產生畫面"><a class="header-anchor" href="#step6-繪製-產生畫面"></a>Step6. 繪製、產生畫面</h2>
<p>到最後一個步驟，瀏覽器進入到了繪製階段，前面提到一連串很抽象的設定跟結構，終於可以被轉換成一個個像素，繪製階段所花的時間會跟 DOM 結構樹 與 CSSOM 樹的大小、規模有關，越複雜的結構或是樣式就會需要更多時間，應該不難理解。</p>
<h2 id="從開發者工具看渲染順序"><a class="header-anchor" href="#從開發者工具看渲染順序"></a>從開發者工具看渲染順序</h2>
<p>我們透過瀏覽器的檢查工具，也能看出上面講的 CRP 六個步驟，是不是真的依照順序進行，以 Chrome 為例子，打開開發者工具，並切換到 Performance 之後，按下錄影，重新整理之後結束錄影，就能夠看到這段時間內瀏覽器是怎麼產生畫面的：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191010/20106580UtQhk3zM67.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191010/20106580UtQhk3zM67.jpg"></p>
<p>對應前面步驟說明：</p>
<p>1、2： 拉取資源並解析 DOM 樹</p>
<ol start="3">
<li>
<p>為 index.css 解析 CSSOM 樹</p>
</li>
<li>
<p>執行 JavaScript 檔案 （ index.js )</p>
</li>
<li>
<p>根據 viewpoint 的 meta tag 產生layout</p>
</li>
<li>
<p>繪製螢幕</p>
</li>
</ol>
<h2 id="參考資源"><a class="header-anchor" href="#參考資源"></a>參考資源</h2>
<p>Google 在 Udacity 的教學真的講的蠻仔細的，搭配圖文也能更讓學習者一目瞭然：</p>
<ul>
<li><a href="%5Bhttps://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=zh-tw%5D(https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=zh-tw)">Google 的教學</a></li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:13.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    9 分鐘 閱讀文 (大約 1354 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-24/">JS 原力覺醒 Day24 -  DOM</a>
            
        </h1>
        <div class="content">
            <p>今天要講的是瀏覽器的 DOM 的概念，內容雖然跟 JS 語言比較沒有關係，但是除非你只寫後端 <code>node.js</code> ，否則只要跟介面相關一定會碰到需要處理 DOM 元素的情況出現，今天就讓我們學著好好跟 DOM 相處。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>DOM 是什麼？</li>
<li>畫面是如何透過 DOM 被產生的？</li>
<li>DOM Tree</li>
<li>與 DOM 互動</li>
<li>總結</li>
</ul>
<h2 id="dom-是什麼？"><a class="header-anchor" href="#dom-是什麼？"></a>DOM 是什麼？</h2>
<p>在我們漫長的前端職涯中，每位前端開發者心中都一定曾經出現過、或是被問過這個問題，那就是到底什麼什麼是 DOM 呢？我們都知道 HTML 是透過標籤式的語法來描述網頁中元素與元素的關係，一對標籤通常就代表一個元素，而且標籤又可以放在另外一個標籤之內，因此元素之間是會有上下層級的，而 DOM 呢，就是透過<strong>把這樣子的層級結構轉換為對應的「物件」而成的關係模型</strong>。</p>
<p>DOM 並不是只能透過 HTML 產生，其他類似的語法像是 SVG、XML 這裡的物件並不一定要是 JS 的物件，因為，但是在瀏覽器裡面，是的，這裡我們討論的物件就是 JS 裡的物件，例如我們在操作 DOM 元素時最常用到的 <code>document</code> 物件。</p>
<pre><code> document.createElement('div')
</code></pre>
<p>所以，我認為DOM 是：</p>
<blockquote>
<p>將HTML文本的複雜層級關係，轉換成以物件結構的方式來表現 ，讓程式語言得以與之溝通。</p>
</blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191009/201065801mBHZYtbqQ.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191009/201065801mBHZYtbqQ.jpg"></p>
<h2 id="畫面是如何透過-dom-被產生的？"><a class="header-anchor" href="#畫面是如何透過-dom-被產生的？"></a>畫面是如何透過 DOM 被產生的？</h2>
<p>因為 HTML 語法大部分都是是成雙成對且有層級關係的標籤，而在使用者透過瀏覽器進入網頁，瀏覽器開始讀取 html 檔案，<strong>就會開始把開發者寫的 HTML 程式碼（即指  Document ) 內容轉成對應的層級關係結構</strong>，所以這種結構才會被稱為 Document Object Model （文件-物件模型）。從使用者進入網頁，到顯示最後使用者的畫面之前，會經歷許多步驟，不過大致上可分為兩個階段：</p>
<ul>
<li>第一階段：瀏覽器會先讀取 HTML 程式碼，並決定最後要渲染在網頁上的內容</li>
<li>第二階段：瀏覽器實際開始渲染，形成最後看得見的畫面</li>
</ul>
<p>第一階段執行玩後的結果稱為「渲染樹 ( Render Tree )」，渲染樹就是用來表現會被渲染到最終畫面上的 HTML 元素，還有他們的關係與 CSS 樣式，要完成渲染樹，瀏覽器會需要兩樣東西：</p>
<ol>
<li>DOM ：用來表現 HTML 元素的層級關係</li>
<li>CSSOM： 整個網頁內HTML 元素對應樣式的關聯</li>
</ol>
<h2 id="dom-tree"><a class="header-anchor" href="#dom-tree"></a>DOM Tree</h2>
<p>DOM 裡面用來表現元素層級關係的物件又稱為「 節點樹 ( Node Tree) 」，他會有這樣子的名稱是因為結構都是從最上層的某個元素，例如  <code>&lt;body&gt;</code> ，往下慢慢延伸、長出許多的分支，整個結構就像是樹一樣，透過這樣子的關係表現形式，程式語言（JS) 與畫面表現 (HTML) ，才得以互相溝通。以下面這個 <code>html</code> 內容為例：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;DOM Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
		&lt;h1&gt;	It's All About DOM &lt;/h1&gt;
		&lt;p&gt;Hello World!!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191009/20106580zqwZaavHgD.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191009/20106580zqwZaavHgD.jpg"></p>
<p>HTML 中，在另外一個元素標籤裡面的元素就是該元素的子元素，如 <code>&lt;html&gt;</code> 元素在最上層，所以其他包含在這個元素裡面的都是他的子元素，而這些元素內又會有其他包含的元素，如此重複、不斷往下堆疊，**而把每個元素都看成一個節點的話，就會形成 DOM 的結構樹 ( DOM Tree) 。而每個樹的節點在也都對應為一個物件，**如此一來 JS 才能透過 瀏覽器的 API 如 <code>document. querySelector</code> 跟每個元素互動或溝通。</p>
<h2 id="與-dom-互動"><a class="header-anchor" href="#與-dom-互動"></a>與 DOM 互動</h2>
<p>透過 JS 我們可以跟 DOM 互動來改變畫面的呈現，或是新增一些互動的功能，像是：</p>
<ul>
<li>改變或刪除 DOM 元素</li>
<li>修改元素的 CSS 樣式</li>
<li>讀取及修改 DOM 元素上的屬性 ( id 、 class 、 src 這些標記性的內容）</li>
<li>創造新的 HTML 元素到 DOM 裡面</li>
<li>在 DOM 元素上新增監聽事件（如：點擊）</li>
</ul>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>## 總結</h2>
<p>今天我們了解了什麼是 DOM ，DOM 是從開發者寫的 HTML 程式碼轉換而來，但 HTML 語法本身並不是 DOM ，而瀏覽器就是因為透過 DOM ，才能讓 JS 跟畫面的元素溝通。下一篇，我會講解從使用者進入畫面後，瀏覽器是怎麼從生成 DOM ，然後透過一連串的處理，最後才顯示畫面的。</p>
<h2 id="參考資源"><a class="header-anchor" href="#參考資源"></a>參考資源</h2>
<p><a href="https://www.youtube.com/watch?v=FIORjGvT0kk">JavaScript DOM Tutorial #1 - Introduction</a></p>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Document_Object_Model"> MDN官方說明 </a></p>
<p><a href="%5Bhttps://javascript.info/dom-nodes%5D(https://javascript.info/dom-nodes)">DOM Nodes</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:11.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分鐘 閱讀文 (大約 1780 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-23/">JS 原力覺醒 Day23 - Class 語法糖</a>
            
        </h1>
        <div class="content">
            <p>講完了原型鍊，現在我們知道如何透過建構函式去做到類似類別的效果，也透過設定物件的 <code>prototype</code> 屬性達到物件的繼承效果， ES6  之後，甚至出現了 <code>class</code> 關鍵字，讓我們可以用更物件導向的方式去撰寫 JS。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Class 基本用法</li>
<li>class 宣告式的防呆機制</li>
<li>透過 class 宣告來達成類別繼承</li>
<li>原型物件方法</li>
<li><code>static</code> 靜態方法</li>
<li>類別建構子內的 <code>super</code></li>
</ul>
<h2 id="class-基本用法"><a class="header-anchor" href="#class-基本用法"></a>Class 基本用法</h2>
<p>原本我們必須要透過建構函式來來模擬類別產生物件，但是因為函式子實在太像是函式了，所以很容易被搞混。在 ES6 後出現了 class 宣告的方式，讓相關功能的程式碼整體變得更物件導向且直觀、更好閱讀許多。使用 class 宣告類別的寫法會要使用比較多一點語法，但與建構函式不會相差太多：</p>
<ul>
<li>建構函式：</li>
</ul>
<pre><code>    function User(name){
    	this.name = name 
    }  
    let user1 = new User(name) 
    
    User.prototype.getName = function (){
    	return this.name
    } 
</code></pre>
<ul>
<li>class 宣告式</li>
</ul>
<pre><code>    class User{
    	constructor (name){
    		this.name = name 
    	}
    	getName(){
    		return this.name
    	}   
    } 
</code></pre>
<p>可以看出使用了 class 宣告以後，原本建構函式的內容還是一樣，只是被移動到 constructor 函式內而已。而原本我們要取用 <code>prototype</code> 才能達成方法的共享，現在也只要直接在 class 內直接宣告就可以了( 是不是真的乾淨很多 ），注意在 <code>class</code> 內的方法宣吿方式跟一般物件屬性的宣告不太一樣，那是 ES6 後出現、用來宣告函式屬性的縮寫，且方法與方法之間不需要以逗號相隔。</p>
<h2 id="class-宣告式的防呆機制"><a class="header-anchor" href="#class-宣告式的防呆機制"></a>class 宣告式的防呆機制</h2>
<p>為什麼前面說使用函式宣告式很容易讓開發者把他跟一般函式搞混呢？因為使用 new 運算子搭配函式來創造實體 ( instance ) 的時候，基本上也是一種<strong>函式呼叫，而且就算沒有加上 <code>new</code> 運算子，函式呼叫還是有效，</strong> JS 不會有提示**，**因此就算真的寫錯了也不容易找到錯誤。而使用 <code>class</code> 來宣告的時候，則只有在使用 <code>new</code> 呼叫的時候，才會有效。</p>
<h2 id="透過建構函式來達成類別繼承"><a class="header-anchor" href="#透過建構函式來達成類別繼承"></a>透過建構函式來達成類別繼承</h2>
<p>還記得前面提過，想要用建構函式來達成繼承的話，有幾個步驟我們必須自己進行：</p>
<ol>
<li>
<p>建構函式的繼承：</p>
<p>為了繼承「前代」建構函式的內容，所以我們必須自己在「後代」建構函式內呼叫前代建構函式 ：</p>
</li>
</ol>
<pre><code>        function Human(race){
        		this.race = race
        }
        
        function User(name,race){
        	this.name = name 
        	Human.call(this,race)
        } 
</code></pre>
<ol start="2">
<li>原型物件的繼承</li>
</ol>
<p>修改「後代」建構函式的原型物件使原本存在其中的 <strong>proto</strong>，屬性從參考 <code>Object</code> 改為參考到前代物件，然後再把原型物件內的函式建構子指回「後代」建構函式，完成原型鍊的串接：</p>
<pre><code>    let User.prototype = Object.create(Human.prototype) 
    User.prototype.constructor = Human
</code></pre>
<h2 id="透過-class-宣告來達成類別繼承"><a class="header-anchor" href="#透過-class-宣告來達成類別繼承"></a>透過 class 宣告來達成類別繼承</h2>
<p><code>class</code> 是 ES6 後出現的語法糖，語法糖簡化了整個類別宣告的過程，透過 <code>class</code> 宣告類別，讓這一切複雜的設定都變得簡單許多！我們不需要再去修改原型物件，也能直接完成繼承的效果了。使用 <code>class</code> 來實現繼承，會需要搭配另外一個關鍵字 <code>extends</code> ，步驟如下：</p>
<ol>
<li>創造要被繼承的類別 <code>Human</code>：</li>
</ol>
<pre><code>    class Human{
    	constructor (race){
    		this.race = race 
    	}
    	getRace(){
    		return this.race
    	}   
    } 
</code></pre>
<ol start="2">
<li>創造後代類別 <code>User</code> ，並搭配 <code>extends</code> 指向 <code>Human</code> ，代表 User 繼承 <code>Human</code> ：</li>
</ol>
<pre><code>    class User extends Human{
    			constructor (name, race) {
            // invoke our parent constructor function. 
            super(race);
    				this.name = name
          }
    } 
</code></pre>
<p>類別建構子<code>constructor</code> 的內容就是原本建構函式的內容；而還記得前面有提到我們必須自己在「後代」建構函式內呼叫「前代」建構函式嗎？現在也不需要這麼麻煩， <code>constructor</code> 內的 <code>super</code> 函式就代表了 被 <code>extends</code> 的 <code>Human</code> 建構函式，所以我只要直接呼叫 <code>super</code> 就可以了。</p>
<h2 id="原型物件方法"><a class="header-anchor" href="#原型物件方法"></a>原型物件方法</h2>
<p>使用建構函式，我們可以在原型物件上新增共享的方法，在 <code>class</code> 宣告中當然也做得到，其實就是在 <code>constructor</code> 外定義的方法，其實前面已經有提過了：</p>
<pre><code>    class Human{
    	constructor (race){
    		this.race = race 
    	}
    	getRace(){ // will be set on the prototype object
    		return this.race
    	}   
    } 
</code></pre>
<h2 id="static-靜態方法"><a class="header-anchor" href="#static-靜態方法"></a><code>static</code> 靜態方法</h2>
<p>靜態方法是物件導向裡面的概念。靜態方法只能由類別本身取得的方法，在產生出來的實例 ( instance ）中是無法取得的。<code>static</code> 和 <code>class</code> ㄧ樣是語法糖，使用 <code>static</code> 關鍵字定義的方法，會直接被指派到該 <code>class</code> 上，所以就只能從該類別上直接取得，像是這樣：</p>
<pre><code>    class User {
    	constructor(name){
    		this.name = name
    	}
    	static getUserType (){
    		return 'technical'
    	}
    } 
    
    User.getUsertype() //'techical'
</code></pre>
<p>對應前面的建構函式，就有一點像是這樣：</p>
<pre><code>    function User (name){
    	this.name = name
    }
    User.getUserType  = function(){
    		return 'technical'
    }
</code></pre>
<p>如果從建構函式來看靜態方法的話可能會稍微有一點奇怪，不過畢竟函式本身也是物件嘛，要在之上新增屬性本來就是合法的。</p>
<h2 id="類別建構子內的-super"><a class="header-anchor" href="#類別建構子內的-super"></a>類別建構子內的 <code>super</code></h2>
<p>剛剛說到類別建構子與建構函式內容相同，而裡面的 <code>super</code> 又代表了被繼承類別（或稱前代類別），所以在「後代」類別建構子內一定要呼叫 <code>super</code> 才能有效完成屬性繼承，而在 <code>class</code> 內定義的其他方法則會被定義到原型物件內，所以如果想要取得「前代」建構函式原型物件內的函式，可以直接用 <code>super</code> 來取用，以前面 <code>Human</code> 類別為例子，在 <code>User</code> 類別內就可以這樣做：</p>
<pre><code>    class User {
    	constructor(name){
    		super() 
    		this.name = name
    	} 
    	getRace(){
    		return super.getRace()
    	}
    } 
</code></pre>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>在我們了解了 JS 內，原型的運作方式之後，我們利用原型達成了繼承的效果，了解了什麼是原型鍊，之後在今天的這篇文章裡面我們又結合了上述提到的所有知識了解了 <code>class</code>  語法糖的使用方式，還有跟舊版建構函式寫法的對應。儘管一切很複雜，相信讀到這裡的你一定有不少收穫。</p>
<p>雖然快結束了，不過如果你對我寫的系列文有興趣，歡迎訂閱，已經訂閱我的人，也非常感謝你們，你們的閱讀就是我寫下去的最大動力，希望我可以把 30 天都撐完！</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:08.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    17 分鐘 閱讀文 (大約 2508 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-22/">JS 原力覺醒 Day22 -  原型共享與原型繼承</a>
            
        </h1>
        <div class="content">
            <p>前一天我們提到 JS 的原型，以及為什麼會有原型的出現 ：為了模擬物件導向的行為。 那麼原型實際上帶來什麼好處？又是透過什麼方式達到繼承的目的？</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>原型共享：原型的運作方式</li>
<li>原型鍊</li>
<li>原型繼承</li>
</ul>
<h2 id="原型共享：原型的運作方式"><a class="header-anchor" href="#原型共享：原型的運作方式"></a>原型共享：原型的運作方式</h2>
<p><code>__proto__</code> 屬性會在物件產生的時候被加到這個物件上，這個 <code>__proto__</code> 就是透過參考的方式，將「被生成物件」與函式的「原型物件」做連結 (  看到 <strong>proto</strong> 前後的「＿」有沒有把他跟「連結」做聯想，是不是覺得這個變數取的很好？ )。這個自動產生 <code>__proto__</code> 參考的行為是 JS 預設的動作，有一點像是這樣：</p>
<pre><code>let user1 = new User() 
user1.__proto__ = User.prototype 
</code></pre>
<p>當然因為這件事情是自動發生的，所以我們不需要手動去做這件事情，在開發上也不建議操作 <code>__proro__</code> 這個變數，請讓他自由，所以整理一下提到的兩個名詞。</p>
<ol>
<li><strong>proto</strong> ：會在物件被生成時一起被指派到物件上的屬性，他決定這個物件的原型物件是誰。</li>
<li>prototype ：會一直存在於建構函式上的屬性，所有透過該函式產生的物件都有能力存取。</li>
</ol>
<p>當我們想要取用物件中的某個屬性時，JS 會先去物件中尋找該屬性，如果沒有，就會轉而透過<code>__proto__</code> 往原型物件屬性，也就是 <code>prototype</code> 原型物件，去尋找這個屬性。由於原型物件 <code>prototype</code> 本身也是物件，所以我們在這個物件內也可以另外新增屬性，而透過前面的說明我們也可以知道原型物件是在被生成物件之間被共享的，所以我們就可以把一些共用的變數或是方法，放到這個共用的物件之內。</p>
<pre><code>let defaultName = 'Darth Vader'
User.prototype.name = defaultName

let user1  = new User() 
let user2  = new User() 

user1.name // 'Darth Vader'
user2.name // 'Darth Vader'
</code></pre>
<p>這麼做有什麼好處？ 把共用函式放在函式建構子裡面的話，每個被生成物件還是會有一樣的函式阿？是這樣沒錯，但是這樣等於是把同樣的數值或函式複製好幾次，生成幾個物件，JS 就會需要幾個記憶體空間；而要同樣的目的，其實只要放在 <code>prototype</code> 原型物件內就可以用較低成本的方式達成。</p>
<h2 id="原型鍊"><a class="header-anchor" href="#原型鍊"></a>原型鍊</h2>
<p>剛剛說到當 JS 引擎在物件內找不到某個屬性時會透過 <code>__proto__</code> 去往 <code>prototype</code>  原型物件去搜尋這個屬性，如果原型物件裡還是找不到，這個原型物件上也還會有一個 <code>__proto__</code>，指向他所屬前代類別的原型物件，例如 JS 內 Array 其實也是物件，所以可以說他的前代就是 Object 物件：</p>
<pre><code>Array.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>因此 JS 引擎會再透過原型物件裡的 <code>__proto__</code> 屬性往上一個原型物件尋找，直到真的找不到為止 ( 會找到 JS 內 Object 物件的原型物件為止，你可以再透過 <code>__proto__</code> 往上找找，最後會發現他是 <code>null</code> )。這個行為跟當初我們講到範圍鍊 ( Scope Chain ) 的行為類似，所以也稱為「原型鍊 ( Prototype Chain )」。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20106580PmyBG9ONck.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20106580PmyBG9ONck.jpg"></p>
<h2 id="原型繼承"><a class="header-anchor" href="#原型繼承"></a>原型繼承</h2>
<p>最後這個部分就讓我實際的程式碼範例來實作繼承，順便藉此說明原型鍊概念的實用性，在繼承的行為裡，透過被繼承的「後代類別」，所產生出來的物件，一開始就應該要直接具有「前代類別」的屬性跟方法，我們來嘗試看看有沒有辦法透過 JS 達到這個目的。</p>
<p>現在假設：</p>
<ul>
<li>我們有一個 <code>Human</code> 類別跟 <code>User</code> 類別</li>
<li>在 Human 類別的物件上有一個 getRace 方法</li>
<li>在 User 類別的物件上有一個 getUserName 方法</li>
</ul>
<p>我們的目標是：透過原型鍊實現 Human 與 User 兩者的繼承關係。</p>
<pre><code>function Human (action, height,race){
	this.action = action 
	this.height = height 
	this.race = race
}


function User(fisrtname,lastname){
	this.fisrtname = fisrtname 
	this.lastname = lastname 
}
 

Human.prototype.getHumanRace = function(){
	return this.race
} 

User.prototype.getFullName = function(){
	return this.firstname + this.lastname
}
</code></pre>
<p>在正式開始之前我們要先思考一下有哪些部分要處理，才能夠讓要繼承的函式建構子與被繼承的函式建構子共享屬性跟方法，主要有兩個方向：</p>
<h3 id="1-前後代類別原型物件繼承"><a class="header-anchor" href="#1-前後代類別原型物件繼承"></a>1. 前後代類別<strong>原型物件繼承</strong></h3>
<p>因為透過 <code>new</code> 運算子生成物件的時候，這兩個建構函式上都會各有一個 <code>protorype</code> 物件，一般情況下他們各自為政 ，但是在處理繼承的時候我們必須同時考慮兩者之間的連結。</p>
<p>前面提到物件在找不到屬性時，就會往原型物件找，如果原型物件裡還是找不到，就會再透過原型物件裡的 <code>__proto__</code> 屬性往上一個原型物件尋找，形成原型鍊。原型物件之間要做到繼承就代表了：</p>
<blockquote>
<p>透過「後代類別」產生的物件，其上有屬性不管在物件內還是在原型物件上都無法找到時，會轉而往「前代類別」的原型物件尋找</p>
</blockquote>
<p>能夠做到這樣子的行為，我們才能說我們透過建立原型屬性的原型鍊，而做到繼承的效果。為了達到這樣子的效果，很顯見的我們必須修改物件上的 <code>__proto__</code> 連結，但是前面也有提過再開發上不建議直接修改<code>__proto__</code> 的參考，因為會破壞物件的預設行為，儘管如此，我們還是可以用比較曖昧的方式來修改這個連結：</p>
<pre><code>User.prototype = Object.create(Human.prototype)
</code></pre>
<p>我只用一個之前沒看過的 JS 內建方法 <code>Object.create</code> 修改了繼承物件 User 的 <code>prototype</code> ，<code>Object.create</code> 可以用來創在一個全新的物件，而且他把第一個參數傳入的物件拿來當作這個新物件的 <code>prototype</code> ，之後我們就可以發現 <code>User</code> 的原型物件，被我們修改成一個新的空物件，而這個物件的原型，正是指向 <code>Human</code> ，  透過這樣的方式 ，我們就把兩者之間繼承的原型鍊串起來了。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20106580jQaA3vn2o0.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20106580jQaA3vn2o0.png"></p>
<p>但是如果你有注意到的話，原本在原型物件上都會有個指回建構函式的<code>prototype.constructor</code> 已經不見了，因此我們需要手動把他加回來，JS 才能夠查找到正確的建構函式。</p>
<pre><code>User.prototype.constructor = User
</code></pre>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20106580jaRrWOjwPH.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20106580jaRrWOjwPH.jpg"></p>
<h3 id="2-前後代建構函式內容繼承"><a class="header-anchor" href="#2-前後代建構函式內容繼承"></a>2. 前後代建構函式內容<strong>繼承</strong></h3>
<p>透過原型物件確實可以達成共享，但如果透過這個方法來共享某些特定屬性，因為屬性的記憶體空間只有一個，這麼一來如果是像「姓名」、「年齡」這種每個人（實體）都會有不同數值的資料，就不適合放在原型物件內，所以我們要想辦法讓我們在「後代」建構函式內可以直接取得「前代」建構函式內容。</p>
<p>簡單來說就是讓前代類別的內容出現在透過後代類別的建構函式所產生的物件上，這裡有一個很經典的辦法，那就是在後代 ( 繼承類別 ) 建構函式裡面執行前代( 被繼承類別 ) 建構函式：</p>
<pre><code>function Human (height,race){
	this.height = height 
	this.race = race
}


function User(fisrtname,lastname,race,height){
	this.fisrtname = fisrtname 
	this.lastname = lastname 
  Human(height,race) // This is not totally correct
}
</code></pre>
<p>這麼一來當 User 透過 <code>new</code> 被呼叫的時候，除了會將 <code>User</code> 內的 <code>this</code> 繫結綁到新生成物件上，還會有另外一個充滿使用 <code>this</code> 繫結來設定物件屬性的 <code>Human</code> 方法被執行，如此一來，前代類別的屬性設置就能夠與後代共用，而前兩行定義的 <code>firstname</code> 與 <code>lastname</code> ，也正好是 <code>User</code> 專屬，<code>Human</code> 不會有的資料屬性，當然我們也可以直接把 <code>Human</code>內定義的屬性搬到 User 內，不過這樣就會變成是重新定義一整個物件屬性，就失去繼承的意義了：</p>
<pre><code>// dont do this if you want to make an inheritance.
//THIS IS AN ANTI-PATERN
function User(fisrtname,lastname,race,height){
	this.fisrtname = fisrtname 
	this.lastname = lastname 
	this.height = height 
	this.race = race
}
</code></pre>
<p>但是還沒有完，這邊有一個前面提過很重要的觀念，那就是當我們 執行 <code>Human</code> 方法時，裡面的 <code>this</code> 繫結並非透過 <code>new</code> 被觸發，所以並不是指向剛剛透過 <code>User</code> 函式建構子被生成的新物件，這個時候我們要透過「明確的繫結」來修改 <code>this</code> 的指向，來把 User 內的 <code>this</code> 連結到 <code>Human</code> 函式的 <code>this</code> 上，這樣子我們就達成了所有物件屬性的繼承：</p>
<pre><code>function Human (height,race){
	this.height = height 
	this.race = race
}

function User(fisrtname,lastname,race,height){
	this.fisrtname = fisrtname 
	this.lastname = lastname 
  Human.call(this,height,race) 
}

Human.prototype.getHumanRace = function(){
	return this.race
} 

User.prototype.getFullName = function(){
	return this.firstname + this.lastname
} 

User.prototype = new Human()

let user1 = new User('John','Kai','black','179')   
</code></pre>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20106580dVHNzBM7ks.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20106580dVHNzBM7ks.png"></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:47:06.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 分鐘 閱讀文 (大約 1665 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-21/">JS 原力覺醒 Day21 -  原型</a>
            
        </h1>
        <div class="content">
            <hr>
<p>上一篇提到 JS 是物件原型導向，而非物件導向的語言，如果想要像物件導向那樣達成物件之間屬性的共用，就需要借助原型的幫忙，所以了解「原型」的概念，對於我們後續想要活用 JS  的物件，或是在 JS 裡面撰寫物件導向風格的程式碼的話是非常重要的。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>物件導向：類別與物件</li>
<li>物件導向：繼承的概念</li>
<li>函式上的原型物件屬性</li>
<li>透過函式建構子產生的物件</li>
<li>總結：原型物件屬性</li>
</ul>
<h2 id="物件導向：類別與物件"><a class="header-anchor" href="#物件導向：類別與物件"></a>物件導向：類別與物件</h2>
<p>在物件導向語言裡面，類別定義了描述某件事或某個功能的基本概念，就像一件商品或是建築物的設計圖ㄧ樣；而物件則是透過類別裡所描述的的概念實現出來的東西，對比於建築設計圖，就是建築物：</p>
<ul>
<li>類別 ←→ 建築設計圖</li>
<li>物件 ←→ 建築物</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580XxkBIolrjB.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580XxkBIolrjB.jpg"></p>
<p>當然上面的比喻只能說是非常非常粗淺的描述，完整的物件導向概念是非常博大精深的。這邊是想讓各位讀者了解它的原理，以及從什麼出發點被創造出來的，知道物件導向的根本概念後，後面我們解說 JS 原型的時候，就不會那麼不知所以然。</p>
<h2 id="物件導向：繼承的概念"><a class="header-anchor" href="#物件導向：繼承的概念"></a>物件導向：繼承的概念</h2>
<p>前面也提過原型存在的目的是為了達到繼承，那麼我們先來看看繼承是怎樣的概念，在物件導向裡的繼承是指類別可以以另一個類別為基礎，再往上進行擴充、或是修改，這樣一來就可以用很方便且較低成本的方式創造新的類別，因此，姑且說繼承的目的是為了讓「某些屬性可以共用」且可以減少重複。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580UZUALPHjdm.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580UZUALPHjdm.jpg"><br>
用生活化的方式比喻的話繼承與被繼承物件之間的關係，有點像圖片內的「動物」這個總稱與「鳥」這樣更明確的稱呼，鳥也是動物的一種，所有動物都有特定共用的行為例如呼吸，但是有些行為可能只有鳥類做得出來例如飛行，因此可以知道，繼承可以讓物件同時具有共用的部分與較為特定的部分。</p>
<h2 id="函式上的原型物件屬性"><a class="header-anchor" href="#函式上的原型物件屬性"></a>函式上的原型物件屬性</h2>
<p>在物件導向裡面有類別的概念讓物件得以用很快速清楚的方式擴充，而 JS 裡面只有「物件」，所以只能用模擬的方式來達成類似的效果 — 那就要透過原型的幫忙。</p>
<p>前面在講繫結的時候我們提到，函式可以搭配 <code>new</code> 運算子成為「函式建構子」來產生物件，我們先來討論函式建構子的概念是什麼。在 JS 裡面，函式建構子其實與一般函式呼叫沒有差別，只是前面多了 <code>new</code> 這個關鍵字而已。</p>
<p>而在 JS 裡面，一個函式被創造出來的時候，JS 引擎會新增一個 <code>prototype</code> 屬性到這個函式上面，這個 <code>prototype</code> 是一個物件，我們姑且稱之為「原型物件」，在原型物件裡面我們可以找到一個指回該函式的<code>constructor</code> 屬性。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580QnyFbprfLV.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580QnyFbprfLV.jpg"></p>
<p>我們用下面的程式碼來當作例子：</p>
<pre><code> function User(firstName, lastName) {
	this.firstName = firstName,
	this.lastName = lastName,
	this.fullName = function() {
		return this.firstName + &quot; &quot; + this.lastName;
	}
}

var user1 = new User(&quot;Gin&quot;, &quot;Tsai&quot;);

console.log(user1) 
</code></pre>
<p>我們用 <code>User</code> 函式當作函式建構子來產生物件，這個函式上面會有一個 <code>prototype</code> 屬性，且他是一個物件，裡面有另外兩個屬性：</p>
<ul>
<li>剛剛提到的 <code>constructor</code> 屬性，指向回該建構函式 ( User )</li>
<li><code>＿proto__</code> 屬性 ，裡面又是另外一個物件，這一點後面會再詳談</li>
</ul>
<h2 id="透過函式建構子產生的物件"><a class="header-anchor" href="#透過函式建構子產生的物件"></a>透過函式建構子產生的物件</h2>
<p>那麼，當物件透過這個函式建構子被產生之後，會不會有什麼特別的地方呢？相對於 JS 引擎在 function 上面加上 <code>prototype</code> 屬性，在這個新生成的物件上則是會被加上一個 <code>__proto__</code> 屬性，這個屬性恰好是指向剛剛函式建構子的 <code>prototype</code> 物件。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580aINQGXfUmW.png" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580aINQGXfUmW.png"></p>
<pre><code>User.prototype === user1.__proto__  //true
</code></pre>
<p>因此我們透過上面的例子可以得出這樣子一個結論：透過函式建構子生成的物件，其上面會有一個指向該物件所屬函式建構子 <code>prototype</code> 屬性的 <code>__proto__</code> 屬性，也就是<strong>該新生成物件的「原型」。</strong></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580sg56q0rUHF.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580sg56q0rUHF.jpg"></p>
<p>現在讓我們用同樣的方式創造第二個使用者 <code>user2</code> ，因為一樣都是透過函式建構子所產生的物件，因此在這個物件上照理說也會有一個 <code>__proto__</code> 屬性並指向產生這個物件的函式建構子上的原型物件，所以我們可以知道<strong>只要是透過函式建構子被生成的物件，他們之間都有一個共享的原型物件（ <code>prototype</code> ）</strong>，先知道這一點很重要。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20106580UpsGcXBrmb.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20106580UpsGcXBrmb.jpg"></p>
<h2 id="總結：原型物件屬性"><a class="header-anchor" href="#總結：原型物件屬性"></a>總結：原型物件屬性</h2>
<p>現在我們知道了被生成物件與建構函式之間的關係：</p>
<blockquote>
<p>所有透過函式建構子生成的物件，都透過 <code>__proto__</code> 屬性與函式建構子上的 <code>prototype</code> 屬性做連結，或是說共享這個屬性。</p>
</blockquote>
<p>但是光知道這些還沒有辦法知道實際的應用，下一章節我們會介紹這個部分，就讓我們往下看看 JS 是怎麼透過原型來達到繼承以及減少相同函式宣告的重複性的。</p>
<h2 id="參考資源"><a class="header-anchor" href="#參考資源"></a>參考資源</h2>
<p><a href="https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b">Prototypes in JavaScript </a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:34.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7 分鐘 閱讀文 (大約 1093 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-20/">JS 原力覺醒 Day20 -  物件</a>
            
        </h1>
        <div class="content">
            <p>今天要提到 JS 裡面物件的概念，「物件」的概念在 JS 裡面是非常重要的，也是 JS 的基本元素。但是相對於物件導向語言的物件，意義上又有一點不一樣。就像前面提到在 JS 裡面函式也是屬於物件，這樣子的行為在一般物件導向的語言裡面是沒有的。<br>
<img src="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20106580lJIWdcHc2t.png"></p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>JS 的物件</li>
<li>創造物件的方式</li>
<li>取用物件的方式</li>
<li>物件原型導向</li>
</ul>
<h2 id="js-的物件"><a class="header-anchor" href="#js-的物件"></a>JS 的物件</h2>
<p>在 JS 裡，物件代表一連串「屬性名稱」與「數值」的組合 ( name-value pair )。這些組合湊在一起就形成了對某件事情的描述，就像一本書有許多資訊像是書名、作者、出版日期ㄧ樣，你可以用 JS 物件輕鬆的表示現實世界的許多物品：</p>
<pre><code>{
 title: 'Le Petit Prince', 
 author:'Antoine de Saint-Exupery', 
 pages: '331', 
 ...
} 
</code></pre>
<h2 id="創造物件的方式"><a class="header-anchor" href="#創造物件的方式"></a>創造物件的方式</h2>
<p>最基本的用來創造物件的方式有幾種：</p>
<ul>
<li>物件實字 （ Object Literal ）</li>
<li>函式建構子</li>
</ul>
<h3 id="物件實字-object-literal"><a class="header-anchor" href="#物件實字-object-literal"></a>物件實字 （ Object Literal ）</h3>
<p>物件實字應該是你最長用到的創造物件方式，使用物件實字創造物件的寫法，跟在 API 傳遞、溝通的時候會用到的 JSON 格式長得很像，都是使用大括號逗號來區分屬性，其實我在文章的開頭就已經使用過了：</p>
<pre><code>let object = { propertyName : 'value', ...} 
</code></pre>
<h3 id="函式建構子-function-constructor"><a class="header-anchor" href="#函式建構子-function-constructor"></a>函式建構子 （ Function Constructor ）</h3>
<p>在許多物件導向語言裡面，因為以類別為主的語言特性，通常是以  <code>class</code> 創造物件藍圖，並搭配使用 <code>new</code> 關鍵字來產生新的物件，這也是物件導向的基本概念。雖然 JS 並不是物件導向的語言，但早期為了吸引那些習慣使用物件導向語言的工程師來使用，也創造了使用 <code>new</code> 關鍵字，屬於自己獨特的產生物件的方式，稱為「函式建構子」，也就是把函式內容視為其他物件導向語言的建構子（ constructor ) 來使用：</p>
<pre><code>function book  (name,price) {
	this.name = name; 
	this.price = price  
} 

let starWar = new book('star war', 500) 

console.log(starWar) // book {name: &quot;star war&quot;, price: 500} 
</code></pre>
<p>如果你要產生一個空物件，那麼除了物件實字，你也可以透過下面的方式：</p>
<pre><code> let obj  = new Object(); 
</code></pre>
<p>這是什麼意思？我們都知道 JS 裡面有一個物件叫做 Object，裡面有很多好用的 API 例如 <code>Object.keys</code> 可以取得物件的所有屬性名，但是根據上面的說明，<code>new</code>  應該要搭配函式來使用才對啊？難道 <code>Object</code> 是函式不成？</p>
<p>是的！  在 JS 裡面 Object 就是一個函式，你可以對他使用 typeof 來驗證這個說法：</p>
<pre><code> typeof Object // function 
</code></pre>
<p>既然 <code>Object</code> 本身也是函數，那麼這個說法就合理了，至於為什麼 <code>typeof Object</code> 結果不是 Object ，我想那又是另外一個層面的問題了。</p>
<h2 id="取用物件屬性的方式"><a class="header-anchor" href="#取用物件屬性的方式"></a>取用物件屬性的方式</h2>
<p>取用物件有兩種方式：</p>
<ul>
<li>最常見的<code>.</code>運算子</li>
<li>使用中括號 <code>[]</code></li>
</ul>
<p>使用中括號取用物件來取用屬性，因為能夠使用字串的關係，在取用屬性的時候可以比較有彈性：</p>
<pre><code>let user = {
	name:'Yoda'
} 
user.name // Yoda
user['name'] //Yoda
</code></pre>
<h2 id="物件原型導向"><a class="header-anchor" href="#物件原型導向"></a>物件原型導向</h2>
<p>雖然許多人在 JavaScript  撰寫物件導向風格的程式碼，但 JS 並不是像 JAVA 或是 C# 那樣物件導向的語言，而相對的，JS 是物件原型導向（ Object-Prototype Oriented ）的語言，在 JS 裡面的每個物件都有一個可以用來與其他物件共用屬性跟方法，或是進行複製的隱藏屬性 : <code>[[ Prototype ]]</code>。</p>
<p>這種繼承的行為也稱為原型繼承 ( prototypical inheritance )，相對於其他像是 PHP、JAVA、Python 這種以類別 ( class ) 為基礎的物件導向語言，這算是比較特別的，在後面的章節我會繼續說明 JS 的物件是如何透過原型來共用屬性的。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:31.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 分鐘 閱讀文 (大約 945 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-19/">JS 原力覺醒 Day19 - 一級函式與高階函式</a>
            
        </h1>
        <div class="content">
            <p>今天要提到的是讓 JS 很適合用來撰寫 Functional Programming 的兩個特性的名詞解釋：「 一級函式」與「高階函式」，如果你寫 JS 一段時間，一定會聽過他，高階函式與一級函式可能聽起來有點複雜，其實並不會，只是字面上意思比較不好理解而已。這兩個特性，讓 JS 可以把函式在其他函式之間互傳，所以也是為什麼有人說 JS 很適合用來寫 Functional Programming 的原因。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>一級函式</li>
<li>高階函式</li>
</ul>
<h2 id="一級函式-first-class-functions"><a class="header-anchor" href="#一級函式-first-class-functions"></a>一級函式 （ First-class functions ）</h2>
<p>當我們說一個語言具有一級函式的特性時，代表這個語言把函式當作其他物件一樣看待，也因此可以將函式當作參數一樣傳入另外一個函式裡面。在 Functional Programming 裡面，也是因為這個特性，才有辦法做到複合函式 （Function Composition），</p>
<p>而在 JS 內，函式本身也是一個特殊的物件（就是 Function 物件），在一些使用到 callback 概念的程式碼中，你就會看到這個概念是如何被應用的：</p>
<pre><code>function doSomething(fn, data) { 
   return fn(data);
}
</code></pre>
<p>我們可以試試下面的程式碼來確認上面的描述 ：</p>
<pre><code> function hello (){
		console.log('hello') 
	} 

hello.a = 'a'
console.log(hello.a) //'a' 
</code></pre>
<p>雖然上面的程式碼完全是合法的，因為函式本來就也是物件，但是在實務上請不要這麼做，否則同事或是跟你一起合作的人可能會崩潰，請使用一般的物件。</p>
<p>而既然將函式當作物件一樣看待，那就代表也可以把這個函式指派給變數，這就是我們之前提到的「函式表達式」 （ Function Expression ) 。</p>
<pre><code>let hello = function (){
	//do  some thing 
} 
</code></pre>
<h2 id="高階函式-high-order-function"><a class="header-anchor" href="#高階函式-high-order-function"></a>高階函式 （ High Order Function )</h2>
<p>只要是可以接收函式作為參數，或是回傳函式作為輸出的函式，我們就稱為高階函式，例如，JS 裡面很常用的一些對陣列操作的內建API：</p>
<ul>
<li>Array.map( ()⇒{…} )</li>
<li>Array.filter( ()⇒{…} )</li>
<li>Array.reduce( ()⇒{…} )</li>
</ul>
<p>也可以被稱為是高階函式，因為他們能夠接收函式作為他們的參數。雖然上述幾個 API 的使用方式乍看之下可能會讓人覺得難以理解，但我們可以試著思考看看他們是怎麼被實作的，其實並沒有那麼複雜，下面就以 Array.map 為例，邊實作、邊思考他的運作方式吧！</p>
<p>由於 Arrray.map 是對陣列元素做巡訪，然後做某些操作之後回傳，所以可能的步驟如下：</p>
<ol>
<li>將函式傳入 map 內</li>
<li>執行一個以陣列長度為執行次數的迴圈</li>
<li>每次帶入不同的 array id 以表示目前尋訪的進度</li>
<li>取得陣列元素、逐個進行修改</li>
<li>逐個放入新的陣列並回傳</li>
</ol>
<p>自己實際實作 map function 的話看起來會像是這樣：</p>
<pre><code>function arrayMap(fn,array){
	let length = array.length
	let newArray = [] 
	for(let i=0 ; i&lt;length ; i++){
		newArray.push(fn(array[i]))
	}
	return newArray
}
</code></pre>
<p>透過上面的程式碼我們自己就實作了高階函式 arrayMap ，可以看到我們自己做的 arrayMap 會在陣列傳入之後，逐個訪問每個元素並傳入我們自己寫的函式 fn ，這個 fn 會根據我們寫的內容將該值做處理之後回傳，然後會直接透過 Array.push 將結果推入新的函式（ 看到了嗎？這裡我們用到複合函式的概念 ）</p>
<pre><code>arrayMap((item)=&gt;{
	return item * 2 	
},[1,2,3,4])
</code></pre>
<h2 id="結論"><a class="header-anchor" href="#結論"></a>結論</h2>
<p>透過今天對兩個名詞的說明我們知道了一級函式與高階函式這兩個名詞的意義，然後我們也自己試著實作了自己的高階函式：</p>
<ul>
<li>一級函式是指在一個語言內，函式本身也是物件，因此能夠將函式當成參數傳給另一函式</li>
<li>高階函式則是指一個函式能不能接收函式當作參數，或是回傳函式作為回傳值</li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:29.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分鐘 閱讀文 (大約 1874 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-18/">JS 原力覺醒 Day18 - Functional Programming</a>
            
        </h1>
        <div class="content">
            <p>今天要介紹 Functional Programming （  簡稱FP ) ，FP 是一種程式設計的思考方式，寫程式寫過一段時間的人幾乎都會聽過這個概念，對某些人來說，想要進入資深階段的話，學習 Functional Programming 是一件不可或缺的事情。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Functional Programming</li>
<li>為什麼要使用 FP</li>
<li>純函式 （ Pure functions ）</li>
<li>複合函式（ Function composition ）</li>
<li>共享的狀態 （ Shared State )</li>
<li>不變性( Immutability )</li>
<li>避免副作用（ Side Effect )</li>
</ul>
<h2 id="functional-programming"><a class="header-anchor" href="#functional-programming"></a>Functional Programming</h2>
<p>Functional programming （ 簡稱FP ） 用比較嚴謹的說法，是一種程式設計方法 ( Programming Paradigm )，意味著他是一種根據某些基本原則來進行開發的軟體架構，聽名字應該可以了解他是以函式為主的開發方式，與之相對的是物件導向程式設計，指的是以  物件（Class）為主的軟體架構。</p>
<h2 id="為什麼要使用-functional-programming"><a class="header-anchor" href="#為什麼要使用-functional-programming"></a>為什麼要使用 Functional Programming</h2>
<p>使用 FP 可以讓程式碼看起來更簡潔，且對功能的描述更精準、所以也就更好進行測試，對開發來說有不少好處，但是如果你對 FP 以及相關的概念還沒有很熟悉，FP 的程式碼也可能讓你需要更多時間來閱讀。</p>
<p>Functional Programming 對初學者來說聽起來可能會有點嚇人，不過如果你是一個有一點經驗的開發者，那麼你可能其實已經使用過 FP 的概念了，只是你不知道而已。在你能夠真正了解什麼是 Functional Programming 之前，有幾個相關的概念必須先理解：</p>
<ul>
<li>純函式 （ Pure functions ）</li>
<li>複合函式（ Function composition ）</li>
<li>共享的狀態 （ Shared State )</li>
<li>可修改性 ( Immutability )</li>
<li>避免副作用（ Side Effect )</li>
</ul>
<p>也就是說，如果想要知道 FP 具體來說是什麼的話，就必須了解上述幾個基本概念，在今天的介紹裡面，我會把這些概念依序做簡單的介紹，下面就讓我們一個一個來看看吧。</p>
<h2 id="pure-function"><a class="header-anchor" href="#pure-function"></a>Pure Function</h2>
<p>純函式有很多對 Functional Programming 非常重要的特性，後面有許多進階概念都是基於純函式的概念演變出來的，純函式的特性包含：</p>
<ol>
<li>同一個輸入純函式的參數，永遠都會回傳相同的結果。</li>
<li>純函式永遠都不會有造成 Side Effect 的操作出現，如 API 拉取、裝置的I/O、或者對函式外部資料的修改。</li>
</ol>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20106580vpvJ133cIB.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20106580vpvJ133cIB.jpg"></p>
<h2 id="functional-composition"><a class="header-anchor" href="#functional-composition"></a>Functional Composition</h2>
<p>複合函式的概念來自數學，是指如何組合兩個以上的函式並依照組合的順序去產生另外一個新的函式，或是做些運算。在數學裡面，我們常常用 <code>f(g(x))</code>  來表示複合函式，意思就是把 g(x) 運算產生的結果值，傳入 <code>f()</code> 函式裡面 。 JS 之所以也能做到類似的行為，是基於 JS 被稱為「一級函式」的概念。（把函式當作參數傳入另外一個函式）</p>
<p>舉例來說，我們想要表現 <code>1 + 2 * 3</code> 的話，可以用兩個函式來表示並組合：</p>
<pre><code>const add = (a, b) =&gt; a + b;
const mult = (a, b) =&gt; a * b;
add(1, mult(2, 3))
</code></pre>
<p>我們寫了加法跟乘法的函式，並將兩個函式組合，就能夠表現出「先乘後加」的行為，這就是複合函式的基本概念。</p>
<h2 id="shared-state"><a class="header-anchor" href="#shared-state"></a>Shared State</h2>
<p>共享的狀態 （ Shared State ）是指任何存在被數個分離的範疇。像是像全域範疇或是前面提到的閉包 ( Closure ) 所共享的這類狀態， 通常就是共享的狀態，在 Funtional Progaramming 裡面，共享的狀態應該避免，因為一但函式內有與其他範疇共享的狀態出現，那麼這個函式就不再是純函式了。 一個共享狀態的例子看起來就像這樣：</p>
<pre><code>let age =  15 
function setUserAgeByInfo( info ) {
	age = info.age 
  return age
}
setUserAgeByInfo({age:100})
</code></pre>
<p>根據上面的程式碼，一但我們執行上面的函式之後，全域變數 userInfo 就會受到影響，這就是因為該變數（狀態）同時與全域範疇跟函式範疇共享的結果。這還只是比較小規模的例子，想想看，如果同時有十個函式都這樣使用全域變數，那麼會出現開發者無法避免的情況，也就不奇怪了，所以在使用狀態時，越是全域的狀態，就要越小心使用。</p>
<h2 id="immutability"><a class="header-anchor" href="#immutability"></a>Immutability</h2>
<p>當我們說一個物件是 Immutable ，那就表示這個物件在被產生之後，就無法再被修改了；反過來說，一個 Ｍutable 的物件，就是指在物件被產生後，還可以被修改，在 JS 內，用一般的方式產生的物件，就是這類 Mutable 的物件。不變性是 Functional Programming 的核心概念，因為如果沒有不變性的存在，我們在寫 FP 時就難以追蹤到狀態的歷史變化，奇怪的、無法理解的 Bug 就越有可能出現。</p>
<p>在 JS 的 ES6 版本後出現了使用 <code>const</code> 的宣告方式，<code>const</code> 很容易被跟不變性產生聯想，但其實是兩個不同的概念，<code>const</code> 是產生一個無法再被重新指派的變數而已，但是他並非產生一個 Immutable 的物件，不相信的話你可以試試看下面的程式碼：</p>
<pre><code>const user = { name:'Yoda' } 
user.name = 'Luke'
</code></pre>
<p>真正的 Immutable Object 可以用 Object.freeze 這個函式被產生出來：</p>
<pre><code>const a = Object.freeze({
  foo: 'Hello',
  bar: 'world',
  baz: '!'
});

a.foo = 'Goodbye';
// Error: Cannot assign to read only property 'foo' of object Object
</code></pre>
<p>在 JS 裡面，也有一些函式庫可以用來幫助你以完全 Immutable 的方式來開發，例如 Immutable.js 。</p>
<h2 id="side-effects"><a class="header-anchor" href="#side-effects"></a>Side Effects</h2>
<p>副作用（Side Effects）是指在被呼叫的函式外部，任何可以被看到的狀態改變，剛剛我們提到的狀態共享，就是有可能造成 Side Effect 的原因，Side Effect 的幾個例子如下：</p>
<ul>
<li>使用consoie.log 印出值</li>
<li>寫入檔案</li>
<li>拉取第三方 API</li>
<li>呼叫其他任何有副作用的函式</li>
</ul>
<p>副作用在 FP 內必須極力避免，因為如此一來，才能讓函式變得更簡潔，而且更好測試。</p>
<p>我們看了這麼多概念，其實有幾個概念幾乎是重複的，例如避免副作用、減少狀態共享、使用純函式，在我看來，這些概念都著重於「減少依賴」這件事情，也就是兩個不同部分的程式碼，他們所使用到的資訊應該要是完全獨立的，如此一來，也才能夠讓程式碼更乾淨好閱讀。</p>
<h2 id="參考文章"><a class="header-anchor" href="#參考文章"></a>參考文章</h2>
<p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">Master the JavaScript Interview: What is Functional Programming?</a></p>
<p><a href="https://medium.com/dailyjs/functional-js-3-state-89d8cc9ebc9e">Functional JS #3: State</a></p>
<p><a href="https://medium.com/@jamesjefferyuk/javascript-what-are-pure-functions-4d4d5392d49c">JavaScript: What Are Pure Functions And Why Use Them?</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:27.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    9 分鐘 閱讀文 (大約 1285 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-17/">JS 原力覺醒 Day17 - this 的四種繫結</a>
            
        </h1>
        <div class="content">
            <p>今天要談到的是 JS 裡面最常被提出來討論的部分，也就是 this 的指向，前面有提到當全域執行環境被產生出來之後，除了全域物件 window ，一個指向這個 window 物件的 this 也會跟著被產生。所以接下來你就可以用 this 來指稱 window 物件，除此之外， this 並不永遠都指向 window 物件，根據不同的呼叫方式，this 所指向的值也會不一樣，所以，你「如何呼叫」這件事情就會很大一部分影響 this 的指向。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Javascript 裡面的 this</li>
<li>預設繫結 (Default Binding)</li>
<li>隱含的繫結</li>
<li>明確的繫結（Explicit Binding</li>
<li>new 繫結</li>
<li>this 繫結的優先順序</li>
<li>參考書目</li>
</ul>
<h2 id="javascript-裡面的-this"><a class="header-anchor" href="#javascript-裡面的-this"></a>Javascript 裡面的 this</h2>
<p>在正式進入 <code>this</code> 解說之前，我們先來了解一下為什麼 this 這麼重要， <code>this</code> 讓我們可以很方便地從執行環境內部取得外部物件，用另一個方式說就是，<code>this</code> 可以讓我們在呼叫函式時們決定要指向哪一個物件。</p>
<p>不過如果沒有好好使用的話，就會出現 <code>this</code> 指向錯誤的物件之類的不如預期的情況出現，所以我們在使用之前，一定要先了解 <code>this</code>  檯面下的運作方式。</p>
<h2 id="四種繫結-binding"><a class="header-anchor" href="#四種繫結-binding"></a>四種繫結 （ Binding ）</h2>
<p>所謂 <code>this</code> 的繫結指的是指向哪一個物件，  <code>this</code>  大致上一共有四種繫結，讓我們一個一個來看看：</p>
<h2 id="1-預設繫結-default-binding"><a class="header-anchor" href="#1-預設繫結-default-binding"></a>1. 預設繫結 ( Default Binding )</h2>
<p>預設繫結：foo 的 this 被 bind 到全域物件Window底下，這是最常見也最好理解的繫結。</p>
<pre><code>	function foo(){
         console.log(this.a); 
  }
  
  var a=2; 
  
  foo() //2;
</code></pre>
<h2 id="2-隱含的繫結"><a class="header-anchor" href="#2-隱含的繫結"></a>2. 隱含的繫結</h2>
<p>隱含繫結：隱含的指出 <code>this</code> 綁定的對象，使用 <code>.</code> 可以取用到物件底下的屬性，同時也在告訴 JS  <code>this</code> 的指向：</p>
<pre><code>var foo = {
     a:'I am in foo',     
     bar:function(){
	     console.log(this.a); 
     }, 
 } 
 
 foo.bar() //I am in foo;
</code></pre>
<h3 id="繫結的失去-繫結在賦值時會失效"><a class="header-anchor" href="#繫結的失去-繫結在賦值時會失效"></a>繫結的失去 （ 繫結在賦值時會失效 ）</h3>
<p>當你用隱含的繫結去呼叫物件內的函式時， <code>this</code> 會正確的指向該物件，但是一但你將這個函式指派給另外一個變數時，這個變數就只會參考到該函式，而不是擁有該函式的整個物件，這個時候再去執行的時候， <code>this</code> 就會因為找不到該物件而指向全域，這個現象就稱為隱含繫結的失去：</p>
<pre><code>    var obj = {
       a:'obj a',
       foo: function foo(){
         console.log(this.a);
	     },
   }

   var bar = obj.foo;

   var a = ' global a'; //Something Happened. 

   bar(); // global a
</code></pre>
<h2 id="3-明確的繫結-explicit-binding"><a class="header-anchor" href="#3-明確的繫結-explicit-binding"></a>3. 明確的繫結（Explicit Binding）</h2>
<p>在JS 裡面，函是可以使用 call()、apply()，來指定綁定物件的 <code>this</code>，<code>call</code> 與 <code>apply</code>  在使用上兩個還蠻相像的，只差在參數傳入的方式，第一個參數都是指定 <code>this</code> 指向的物件， 而第二個以後的參數則是要傳入該函式的參數，<code>apply</code> 是以陣列的方式來決定傳入函式的參數順序，而 <code>call</code> 則是直接以第二個參數後的數量及順序來決定：</p>
<pre><code>function foo(arg1,arg2){
       console.log(this.a);   
}
var obj ={
    a:2,
} 

foo() // undefined
foo.call(obj , arg1 , arg2);//2  
foo.apply(obj,[arg1,arg2]);//2  

//call 跟 apply 基本上行為相同，只差在參數傳入的方式不同
</code></pre>
<h3 id="硬繫結-hard-binding"><a class="header-anchor" href="#硬繫結-hard-binding"></a>硬繫結 - ( Hard binding )</h3>
<p>Hard Bind 是明確繫結的一種變化．可以確保某個 function 的 this 每次被呼叫的時候都與目標物件綁定，可以看到因為多包一層function的關係，即時bar在怎麼用call指定this環境，裡面的主要function :foo.call(obj)依然不會受到影響。</p>
<pre><code>function foo(){
            console.log(this.a); 
        }
        
        var obj = {
            a:2
        }
        
        var bar = function(){
            console.log('this= '+this);  
            foo.call(obj); 
        }
         
        bar();            //this= [object Window]
                           //2
        bar.call(window);  //this= [object Window]
                           //2
</code></pre>
<h2 id="4-new-繫結"><a class="header-anchor" href="#4-new-繫結"></a>4. new 繫結</h2>
<p>當一個函式被以 new 的方式呼叫時，神奇的事情發生了：</p>
<ol>
<li>會有一個全新的物件被創造出來</li>
<li>這個新建構的物件帶有 prototype 連結 (先不討論)</li>
<li>這個新建構的物件會被設為那個函示呼叫的 this</li>
<li>除非該函式提供了自己的替代物件，不然這個以new調用的函式呼叫會自動回傳這個新建構的物件。</li>
</ol>
<p>函式搭配 <code>new</code> 關鍵字來創造物件的方式，也是早期物件導向宣告新物件的方式，而後來 <code>class</code> 關鍵字的出現，也讓我們用更直觀的方式宣告物件，因此像這樣使用 <code>function</code> 創造物件的方式也就比較不常見了。</p>
<pre><code>function foo(){
    this.a=2; 
}

var bar = new foo(); 

//{}
//this = {}
//this.a=2 
//{a:2}
//return {a:2}
//bar.a=2

console.log(bar.a); //2
</code></pre>
<h3 id="this-繫結的優先順序"><a class="header-anchor" href="#this-繫結的優先順序"></a>this 繫結的優先順序</h3>
<p>當 this 的繫結重複的時候，會以下面的優先順序決定採用哪一種繫結：</p>
<blockquote>
<p>預設 &lt; 隱含 &lt; 明確繫結 &lt; new 繫節</p>
</blockquote>
<h2 id="參考書目"><a class="header-anchor" href="#參考書目"></a>參考書目</h2>
<p>本篇文章參考 You Dont Know JS 系列的 Scope &amp; Closure</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:24.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 分鐘 閱讀文 (大約 897 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-16/">JS 原力覺醒 Day16 -  Async / Await：Promise 語法糖</a>
            
        </h1>
        <div class="content">
            <p>Promise 讓我們有一個可以很方便寫出非同步函式的方法，不過像這樣非同步的程式碼對於我們在閱讀或是 Debug 要判斷執行的先後順序上可能會比較不值觀，今天要來介紹一組讓 Promise 程式碼的可讀性大大提升的語法糖：Async / Await。</p>
<ul>
<li>Promise 語法的問題</li>
<li>Async</li>
<li>Await</li>
</ul>
<h2 id="promise-語法的問題"><a class="header-anchor" href="#promise-語法的問題"></a>Promise 語法的問題</h2>
<p>常常我們在拉 API 的時候會以 Promise 的方式來實作（例如 axios ），而在這個 Promise 裡的 Callback ，如果又想拉取另外一支 API ，就會需要執行另外一個 Promise ， 結果就寫出了難以閱讀的程式碼：</p>
<pre><code>let promise = new Promise (( resolve, reject)⇒{

resolve('some value') 

}) 

promise.then((value)⇒{
	let promise2 = new Promise((resolve,reject)=&gt;{
		resolve('value2')
	}) 
	promise2.then((value2)=&gt;{
		...
	})
})
</code></pre>
<p>這樣子的寫法可能少少幾行還沒事，但當專案變大之後，如果充滿了這樣子的程式碼，那肯定讓你眼花撩亂，所以我們需要 async / await 來做簡化。</p>
<h2 id="async"><a class="header-anchor" href="#async"></a>Async</h2>
<p><code>async</code> 語法必須寫在函式宣告前面，用來告訴 JS 這個函式是一個非同步的函式，就像這樣：</p>
<pre><code>async function asyncFunc() {
  return &quot;Hey!&quot;;
}

asyncFunc() // will get a resolved promise.
</code></pre>
<p>而用 <code>async</code> 語法所宣告的函式，被呼叫時永遠都會回傳一個 Promise，雖然從上述程式碼看不出來，但是 JS 程式碼會幫你用 Promise 然後包起來回傳給你，就像這樣：</p>
<pre><code>function asyncFunc (){
	return new Promise((resolve,reject)=&gt;{
		resolve(&quot;Hey!&quot;)
	})
} 
</code></pre>
<h2 id="await"><a class="header-anchor" href="#await"></a>Await</h2>
<p><code>await</code> 只能使用在 <code>async</code> 函式內部，在這之外的地方使用的話就會報錯。在 async  函式內部，如果還有其他非同步的程式碼，例如在裡面寫 Promise ，我們就可以用 <code>await</code> ，去告訴 JS 引擎要停下來等待這個非同步程式碼執行完畢，並且等到 Promise 被 resolve 之後才會繼續往下執行。</p>
<pre><code>async function asyncFunc() {
	let data = await new Promise((resolve,reject)=&gt;{
		// do some calculation 
		resolve('api data') 
	})
  console.log(data) //'api data'
}
</code></pre>
<p>有了 <code>await</code>  之後我們就可以寫出非常容易閱讀的程式碼， <code>async</code> 關鍵字也很明確告訴你這個韓式內有非同步的程式碼，而如果沒有 <code>await</code> 我們原本還需要透過 .then 函式才能拿到 Promise 執行完畢 resolve 之後的值。</p>
<p>更棒的是，如果你的函式內本來有不只一個 Promise 想要依序執行，使用 <code>await</code> 就可以讓你的邏輯以很清楚的方式表現：</p>
<pre><code>async function asyncFunc() {
	let promise1 = await new Promise((resolve,reject)=&gt;{
		// do some calculation 
		resolve('api data') 
	})
	let promise2 = await new Promise((resolve,reject)=&gt;{
		// get res data of promise1 and do some thing
		resolve('success!') 
	})
  console.log(promise2) //'success'
}
</code></pre>
<p>不過有一個小缺點是因為使用 <code>await</code> 的話，因為 JS 引擎會一直等待 Promise 執行完畢，所以如果過度濫用的話，那就失去非同步的意義了，這點在使用時要多多注意，自己斟酌。</p>
<h2 id="error-handling"><a class="header-anchor" href="#error-handling"></a>Error Handling</h2>
<p>使用 async / await 這個語法糖時，為了讓錯誤處理也變得更簡潔，可以搭配 try / catch 使用：</p>
<pre><code>async function asyncFunc() {
	try{
			
		let data = await new Promise((resolve,reject)=&gt;{
			// do some calculation 
			resolve('api data') 
		})
	  console.log(data) //'api data'
	}catch(e){
		console.log('error',e)
	}
}
</code></pre>
<h2 id="結論"><a class="header-anchor" href="#結論"></a>結論</h2>
<ul>
<li>async / await 只是一個 Promise 的語法糖，讓你可以更方便寫出非同步程式碼</li>
<li>async 函式一定會回傳一個 Promise</li>
<li>await 只能在 async 函式內使用</li>
<li>await 語法會讓 JS 引擎等待 Promise 執行完畢後才會繼續往下</li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:22.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    9 分鐘 閱讀文 (大約 1283 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-15/">JS 原力覺醒 Day15 - Macrotask 與 MicroTask</a>
            
        </h1>
        <div class="content">
            <p>上一篇針對 Promise 的語法做了一個基本的解說，但其實今天的內容才是我想講的，Promise 的運作邏輯不難理解，但若是 Promise 在整個 JS 以及瀏覽器裡的流程可能就比較複雜了，現在我們都知道幾件事情：</p>
<ul>
<li>一個 Promise 最終會有兩種狀態</li>
<li>對應 Promise 的不同狀態，會各自觸發 .then 與 .catch 兩個函式</li>
<li>利用 Promise 可以達成非同步行為，而且內容可以自訂</li>
</ul>
<p>而雖然在上一章節一直提到非同步，但是對於 Promise 裡所謂非同步執行的部分，目前我們還是沒有很明確的解釋，到底是哪一部分會以非同步的方式被執行？以及什麼時候會執行？這是這篇文章想要探討跟說明的。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Tasks</li>
<li>Micro Tasks</li>
<li>Microtask 與 Macrotask 同時發生的例子</li>
</ul>
<h2 id="macrotasks"><a class="header-anchor" href="#macrotasks"></a>Macrotasks</h2>
<p>我們在 Event Queue 章節裡面所提到 Web API 有些具有非同步的行為，而在非同步的目的達成之後，瀏覽器會把給定的對應的函式推送到 Event Queue 裡面，這些一個一個函式正好代表每一件要做的事情，因此在 JS 裡面，以「 Task 」或 「Macrotask 」來稱呼，為了避免混淆，以下將用 Macrotask Queue 來指稱之前提到的 Event Queue 。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20106580UMeCNMZgKH.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20106580UMeCNMZgKH.jpg"></p>
<p>關於 Task 有兩個細節可以注意：</p>
<ul>
<li>以瀏覽器的角度來看，在每一個 Task 結束之前，不會有任何瀏覽器的 rending 產生</li>
<li>如果一個 Task 執行所花的時間過長，那麼瀏覽器就無法執行其他的 Task ，所以過一段時間之後會提出「頁面沒有回應」的警告，建議你關閉這個分頁，這種情況你應該有遇過。</li>
</ul>
<h2 id="microtasks"><a class="header-anchor" href="#microtasks"></a>Microtasks</h2>
<p>Microtask 通常由 Promise 產生，Promise 裡用到的 .then / .catch 函式會以非同步的方式來被執行，回想下 Queue 的概念，所以的非同步行為指的是，會在全域執行環境執行完之後才被執行，因此一但 Promise 的 callback 內容執行完成，狀態再也不是 pending 時，.then 或 .catch 的函式內容就會被推送到 Queue 裡面等待執行，這個被推送到 Queue 的函式就是 Microtask。</p>
<p>相對於管理 Web API 所屬事件的 Macrotask Queue ，Promise 產生的 Microtask 也有自己的 Queue ，在 JS 內被稱為 Job Queue 或 Microtask Queue，而 Job Queue 與 Event Queue 運作方式上有一點不一樣。</p>
<p>差在哪裡呢？<strong>在 Queue 裡面的每個 Macrotask 執行完畢後 ，就算 Event Queue 裡面還有其他的 Task，JS 引擎依舊會優先執行 Microtask Queue 裡面的所有 Task</strong> ，在這個同時也不會重新渲染網頁，換句話說，Microtask 的執行是穿插在每個 Macrotask 之間，兩者的差異也就在執行順序的不同而已。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20106580a7zj27GtsT.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20106580a7zj27GtsT.jpg"></p>
<h2 id="microtask-與-macrotask-同時發生的例子"><a class="header-anchor" href="#microtask-與-macrotask-同時發生的例子"></a>Microtask 與 Macrotask 同時發生的例子</h2>
<p>如果還是覺得很抽象，下面我會帶個例子，直接用程式碼來比較 Ｍacrotask 與 Microtask 執行順序的不同，應該比較能夠讓你了解，看看下面的程式碼：</p>
<pre><code>setTimeout(() =&gt; alert(&quot;timeout&quot;));

Promise.resolve()
  .then(() =&gt; alert(&quot;promise&quot;));

alert(&quot;global ex. context&quot;);
</code></pre>
<p>這段程式碼剛好同時用到 Web API 與 Promise ，各自在呼叫後會產生一個 Macrotask 以及 Microtask ，不過在順序上是哪個會先被執行呢？稍微分析一下：</p>
<ul>
<li>所有的 Queue 都會等待執行環境堆疊被清空，alert 肯定會先執行</li>
<li>setTimeout 對應的函式會被當作一個 Macrotask ，等待時間到之後被送入 Macrotask Queue</li>
<li>Promise 對應的 .then 或 .catch 的函式會被當作一個 Microtask 送入 Microtask Ｑueue</li>
<li>在執行環境堆疊清空之後，通常網頁會先做一次 Render，Render 的動作同時也算是一個 Macrotask</li>
</ul>
<p>因此推測 alert 的順序應該會像是這樣：</p>
<ol>
<li><code>&quot;global ex. contenxt&quot;</code></li>
<li><code>&quot;timeout&quot;</code></li>
<li><code>&quot;promise&quot;</code></li>
</ol>
<p>但是並不是！結果會是 <code>&quot;promise&quot;</code> 比 <code>&quot;timeout&quot;</code> 還要更先被 log 出來：</p>
<ol>
<li><code>&quot;global ex. contenxt&quot;</code></li>
<li><code>&quot;promise&quot;</code></li>
<li><code>&quot;timeout&quot;</code></li>
</ol>
<p>這是為什麼呢？這邊可能會有點抽象，前面我們在分析 JS 語法與運作模式的時候，大多是從 JS 引擎的角度出發。而前面也有提到， Queue 的概念並不屬於 JS 引擎的一部分，相對的歸屬於瀏覽器。對於瀏覽器來說，在網頁頁面開啟時，載入對應的 JS 檔並且執行這件事情，也是一個 Macrotask 。</p>
<p>而剛剛提到 Macrotask 執行完畢後，會優先執行 Microtask ，因此你會看到 <code>&quot;promise&quot;</code> 出現的順序先於 <code>&quot;timeout&quot;</code>   。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20106580BZxnDVGnKD.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20106580BZxnDVGnKD.jpg"></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:20.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 分鐘 閱讀文 (大約 1585 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-14/">JS 原力覺醒 Day14 - 一生懸命的約定：Promise</a>
            
        </h1>
        <div class="content">
            <p>上一章節我們提到有一些 JS 的 Web API 會需要在「背景執行」，同時又不影響整個網頁主程式的運行，這些 API 利用瀏覽器 Event Queue 的機制來達成這個目的，也就是所謂非同步的動作。不過難道只有在使用 這些 Web API 的時候，才能使用到非同步的行為嗎？我們有沒有可能讓自己寫的功能，也具有非同步的行為呢？</p>
<p>答案是，可以的，只是方式不太一樣，如果想要讓自己寫的功能也具有非同步的行為，我們會需要用到今天要討論的主角 — Promise 。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Promise 簡介</li>
<li>Promise : 成敗之間</li>
<li>成功的 Promise : Succeed and then</li>
<li>失敗的 Promise : Catch with an error</li>
<li>Promise 概念圖</li>
<li>Promise : 一個生活化的例子</li>
</ul>
<h2 id="promise-簡介"><a class="header-anchor" href="#promise-簡介"></a>Promise 簡介</h2>
<p>Promise 是什麼呢？以語法字面上的意義來看，用比較白話的方式解釋的話有一種：「我承諾幫你做某件事情，能不能成功還不一定，但是我做完之後會把結果告訴你」的意思。</p>
<p>那麼來看看比較技術層面的定義，在官方文件中的定義則是：</p>
<blockquote>
<p>Promise 是一個代表非同步運作的最終狀態的物件 （成功或失敗）</p>
</blockquote>
<blockquote>
<p>A Promise is an object representing the eventual completion or failure of an asynchronous operation.  （MDN)</p>
</blockquote>
<p>雖然技術文件的解釋就顯得比較抽象，不過從上面看得出來 Promise 在 JS 裡面是以物件的方式存在，那麼接下來我們就來看看要怎麼使用 Promise 吧，基本的 Primise 宣告方式如下：</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
  // executor code
}) 
</code></pre>
<p>我們以 Callback 的方式來告訴 Promise ，接下來我們定義的非同步函式要做什麼事情，而且也必須跟 Promise 說，做完想做的事情，得到結果後，怎樣的結果算是成功，怎樣的結果算是失敗？這些都會被記錄在這個 Promise 物件裡面，Promise 物件裡面有幾個相關屬性：</p>
<ol>
<li>state （狀態） ：一個 Promise 裡一共會有三種狀態：
<ul>
<li>fulfilled ：成功的狀態</li>
<li>rejected：失敗的狀態</li>
<li>pending ：還在執行中的狀態</li>
</ul>
</li>
<li>result :  執行完 Promise 後的結果值</li>
</ol>
<h2 id="promise-成敗之間"><a class="header-anchor" href="#promise-成敗之間"></a>Promise : 成敗之間</h2>
<p>那要定義 Promise 的運行結果？ 你可以看到在 Callback 函式內有兩個引數，分別是 resolve 跟 reject ，就是由 JS 提供、用來決定 Promise 結果狀態時使用的兩個函式 ：</p>
<ol>
<li>
<p>resolve 用在 Promise 成功且結果如預期時，呼叫這個函式會把 Promise 的 state 設為 fulfilled ，將執行結果數值傳入這個函式會讓上述提到的 Promise 的 result 設為給定的值。</p>
<p>什麼意思呢？下面的程式碼就是一個 Promise 成功，並且把 result  設為 <code>'Success'</code> 的範例：</p>
</li>
</ol>
<pre><code>    let promise = new Promise((resolve, reject) =&gt; {
    	 resolve(' Success ') 
    })  
</code></pre>
<ol start="2">
<li>
<p>reject 則與 resolve ，呼叫 reject 會將 state 設為 rejected ，意即失敗。</p>
<p>let promise = new Promise((resolve, reject) =&gt; {<br>
		if(someValueIwant){<br>
			//do other things and resolve<br>
		}else{<br>
				reject(‘Failure’)<br>
		}<br>
})</p>
</li>
</ol>
<h2 id="成功的-promise-succeed-and-then"><a class="header-anchor" href="#成功的-promise-succeed-and-then"></a>成功的 Promise : Succeed and then</h2>
<p>寫到這邊有個要注意的重點是，上述提到 Promise 的兩個值 state 跟 result 是沒有辦法直接被取用的，他們只能透過某種方式被取用。所以這邊要講的是 then 函式，then 是指在 Promise 順利執行完成後，要取得結果值的方法。</p>
<p>在前面我們提到，Promise 的 callback 內，我們可以將取得的結果值丟給 resolve 函式，之後我們就可以夠過 .then 來取得這個結果，然後做其他事情。then 函式 一樣接收的是一個 callback ，並且帶有一個參數，這個參數就是 Promise 剛剛計算完的結果，以上述例子為例的話就像這樣：</p>
<pre><code>let promise = new Promise((resovlve,reject)=&gt;{
	//after some calculation
	let result  = 'value from some where'
	resolve(result) 
}) 

promise.then(result =&gt; {
		//use result to do something 
}) 
</code></pre>
<p>而為什麼要使用 .then 與 callback 的方式呢？因為這樣一來，JS 可以保證這個 callback 在 Promise 執行完之後才被呼叫。</p>
<h2 id="失敗的-promise-catch-with-an-error"><a class="header-anchor" href="#失敗的-promise-catch-with-an-error"></a>失敗的 Promise : Catch with an error</h2>
<p>如果一個 Promise 因為某些原因而被 reject ，那麼上面提到的 .then 裡的 calback 就不會被執行，相反的，他會執行另外一個 callback — 在 .catch 函式內被傳入的 callback。這裡提到的 catch 的用途有點像是在捕捉錯誤時的語法：try &amp; catch 裡的 catch 部分，都是用在錯誤發生時。</p>
<pre><code> let promise = new Promise((resovlve,reject)=&gt;{
	//after some calculation
	let error = 'some error happended!!'
  if (!result){
		reject( error ) 
	} 
}) 

promise.catch(error =&gt; {
	// log the error
})  
</code></pre>
<h2 id="promise-概念圖"><a class="header-anchor" href="#promise-概念圖"></a>Promise 概念圖</h2>
<p>「狀態」的概念對使用 Promise 來說是很重要的事情，那麼讓我用一張簡單的狀態圖來表示運行的順序吧，首先 Promise 會有一段執行的時間，所以直到剛剛說的 resolve 函式被執行之前，狀態都會是 pending ，而在這之後如果 resolve 被順利呼叫，Promise 的狀態就會變成 fulfilled ，否則就會是 rejected：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190929/20106580vaLn6I6Vvn.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190929/20106580vaLn6I6Vvn.jpg"></p>
<h2 id="promise-一個生活化的例子"><a class="header-anchor" href="#promise-一個生活化的例子"></a>Promise : 一個生活化的例子</h2>
<p>前面提到，一個 Promise 會有三種狀態：fulfilled 、reject 與 pending 。其實在我們生活中就常常遇到這樣的例子，那就是提款機啦！回想一下剛才提到的「狀態」，提款機其實剛好就有剛剛說的三種狀態可以類比到 Promise 上面！</p>
<p>使用提款機送出提款的要求時，會需要等待一段時間，這時候可以看成 Promise 的執行時間，也就是 pending ，那麼在執行完畢後，可能會發生兩種結果：一種是沒什麼問題 ( fulfilled 的狀態 )，提款機就直接吐錢出來 ( then )；另一種是你的餘額不夠，那麼 ATM 直接進入 rejected 拒絕讓你提款，並解顯示錯誤訊息（ catch ）。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190929/2010658031IXCxGbUr.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190929/2010658031IXCxGbUr.jpg"></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:18.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    13 分鐘 閱讀文 (大約 1930 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-13/">JS 原力覺醒 Day13 -  Event Queue &amp; Event Loop 、Event Table</a>
            
        </h1>
        <div class="content">
            <p>我們越來越深入 JS 運作方式的重要部份了，今天要提到 「 Event Loop 」的概念，這是 JS 最獨特的地方，幾乎沒有其他語言有這個特性。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>Parts Of JavaScript Engine</li>
<li>Event Queue</li>
<li>Event Queue 運行流程</li>
<li>Event Table</li>
<li>Event Loop</li>
</ul>
<h2 id="parts-of-javascript-engine"><a class="header-anchor" href="#parts-of-javascript-engine"></a>Parts Of JavaScript Engine</h2>
<p>之前提到過「 執行環境堆疊 」，函式呼叫時會產生執行環境，若在這個函式執行環境內還有其他函式被呼叫，就會在之上產生另一個執行環境，形成堆疊。而在上層的執行環境結束之前，下層部分的其他程式碼是無法被執行的 — 包含全域執行環境。</p>
<p>因此，只要在這之中某個堆疊執行過久，就算只有一個函式執行環境的堆疊，都有可能影響整個主程式（ 全域執行環境 ）的運行。不過應用程式裡面總是會有某些功能需要時間來提取 / 運算，這時候為了不讓整個主程式停下來等待太久，我們可以而且其實我們很常把這些比較耗時的工作放到主程式以外的另外一個部分去執行。</p>
<p>而在進入正題之前，必須先複習一下，前幾章節我們提到， JS 引擎底下有三個部分：</p>
<ul>
<li>「 記憶體堆疊」</li>
<li>「全域執行環境」</li>
<li>「執行環境堆疊」。</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20106580oOL27vmCrq.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20106580oOL27vmCrq.jpg"></p>
<p>然而瀏覽器內可不只有 JS 引擎，接下來我們要提到一個很重要的概念 — 「 Queue 」（又稱  Message / Event / Callback Queue ）。</p>
<p>整個瀏覽器的運行環境並非只由 JS 引擎組成。因為 JS 語言特性屬於單執行緒，同時又為了讓網頁具有像「監聽事件」、「計時」、「 拉第三方API 」這些類似「背景作業」的功能，瀏覽器提供了另外一些部分來達成，分別是：</p>
<ol>
<li>Event Queue</li>
<li>Web API</li>
<li>Event Table</li>
<li>Event Loop</li>
</ol>
<p>整個由上述部分，包含 JS 引擎所組成的環境，也稱為 JS Runtime Environment  ( JRE )</p>
<h2 id="event-queue"><a class="header-anchor" href="#event-queue"></a>Event Queue</h2>
<p>Queue （儲列）是什麼樣的概念呢？ 我們先來看一下，在寫網頁程式的時候，有一些所謂「內建的」API 如 SetTimeout / setInterval ，這些 API 不存在於 JavaScript 原始碼內，但你仍然可以在開發時直接使用。因為這些 API 是屬於瀏覽器提供的 Web API 。Web API 並非 JS 引擎的一部分，但他屬於瀏覽器運行流程的一環。</p>
<p>關於 Web API ，舉一些例子：</p>
<ul>
<li>操作 DOM 節點的 API 如 ：document.getElementById</li>
<li>AJAX 相關 API 像是：XMLHttpRequest</li>
<li>計時類型的 API ，就像剛剛提到的 setTimeout</li>
</ul>
<p>這類 Web API 在與 JS 原始碼一起執行的時候，並不會直接影響 JS 主執行環境的運行，否則的話網頁在執行像是拉取第三方 API 資料的動作時，就只能乾等，無法執行任何其他事情了！ <strong>所以瀏覽器將這些必須等待執行結果的動作，丟給其他部分去執行，然後讓 JS 引擎可以繼續做他應該做的事情</strong>，上述提到要等待執行結果的行為，其實也就是「非同步」的行為。（因為不會一次直接從頭跑到尾做完）</p>
<p>這就是  Event Queue （ 事件儲列 ）的工作了， 事件儲列專門用來存放這些非同步的函式，然後等到整個主執行環境運行結束以後，才開始依序執行事件儲列裡面的函式。而所謂 Queue 是一種「先進先出」的資料結構，與 Stack 的「後進先出」相反，所以先被推送到 Queue 裡面的函式會相對於其他函式優先被執行。</p>
<h2 id="event-queue-運行流程"><a class="header-anchor" href="#event-queue-運行流程"></a>Event Queue 運行流程</h2>
<p>下面會以 setTimeout 為例，解說 Event Queue的運行流程。</p>
<pre><code> setTimeout(callbackFunction, timeToDelay)
</code></pre>
<p>像是 setTimeout 與 setInterval 這些計時的 API ，是在給定的時間到了之後，執行對應的函式內容。</p>
<pre><code>function executeAfterDelay() {
  console.log(&quot;I will be printed after 1000 milliseconds&quot;)
}

setTimeout(executeAfterDelay, 1000)

console.log(&quot;I will be executed first&quot;)
</code></pre>
<p>但在給定時間到達之後，確切來說也並非是直接執行，而是會等待整個 JS 的執行環境結束， Call Stack 清空了之後，才開始執行。像上面的程式碼，會在一秒後印出對應的 console 內容，但是 JS 引擎在看到 setTimeout 這個函式的時候，並不會停下來等一秒過後才繼續往下，而是會直接往下執行。</p>
<p>而在 JS 引擎繼續往下執行的時候，剛才我們呼叫setTimeout所造成的計時的動作依然在進行，直到一秒到了以後，瀏覽器會把給定的對應的函式推送到 Event Queue 裡面，然後等待主程式運行完畢。</p>
<p>整個流程看起來像這樣：</p>
<ol>
<li>JS 引擎執行到瀏覽器提供的 setTimeout 函式</li>
<li>JS 引擎繼續運行，同時瀏覽器開始根據給定的秒數計時</li>
<li>等待計時完成後，把剛才給定的函式推送到 Event Queue 內</li>
<li>等待 JS 引擎運行完畢，主執行環境結束後，將 Event Queue 內的函式推送到 JS 主執行環境，產生堆疊（執行該函式）。</li>
</ol>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20106580ea5AJm1VDH.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20106580ea5AJm1VDH.jpg"></p>
<h2 id="event-table"><a class="header-anchor" href="#event-table"></a>Event Table</h2>
<p>Event Table 與 Event Queue 互相搭配的資料集合，他負責記錄在非同步目的達成後，有哪些函式或者事件要被執行，這裡指的非同步目的指的是像計時完畢、API資料獲取完畢、事件被觸發。當我們執行 setTimeout 這個函式時，JS 會把給定的函式與像是倒數的秒數之類的附帶資訊 ( meta data )推送到 Event Table裡面，等到一秒過後（目的達成）該函式就會被正式推送到Event Queue 等待執行。</p>
<h2 id="event-loop"><a class="header-anchor" href="#event-loop"></a>Event Loop</h2>
<p>那麼，什麼又是 Event Loop 呢？可以把 Event Loop 想成是另外一個幾乎無時無刻、每一毫秒都在執行的程式，他負責檢查現在主執行環境堆疊是否是空的？如果是空的，再去檢查 Event Queue ，若 Event Queue 有函式待執行，則將這些函式從 Event Queue 依序推出，並執行。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20106580oVudusuOwX.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20106580oVudusuOwX.jpg"></p>
<h2 id="總結"><a class="header-anchor" href="#總結"></a>總結</h2>
<p>在這個章節，其實你只要能夠了解 JS 內 Event Queue 的概念，知道setTimeout 內的函式是何時被執行、以及怎麼運作的，就可以抓住我想提的非同步運行方式的重點了，其他像是 Event Loop 、Event Table 都只是概念性的名詞解釋，如果你原本對 JS 的非同步特性不是很了解，希望上面的概念模型圖可以幫助到你。</p>
<p>這邊文章同時也會在 Medium 上的 Publication 分享，上面未來會有囊括 前端 / 後端 / DevOps / 資訊安全等相關的技術文章，如果有興趣<a href="https://medium.com/walkout">歡迎追蹤。</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:15.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 分鐘 閱讀文 (大約 2184 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-12/">JS 原力覺醒 Day12-   傳值呼叫、傳址呼叫</a>
            
        </h1>
        <div class="content">
            <p>今天要談的是另一個 JS 裡面很重要的特性，我們在做變數宣告與赴值時， JS 引擎是如何為我們保留記憶體位置的？還記得前面有提到 JS 裡面概括可以分為兩大類別：「物件型別」、「原始型別」嗎？這兩種型別，在變數操作時，記憶體位置的運作方式各有不同。</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>原始型別的傳值呼叫 ( Call  By Value )</li>
<li>物件型別的傳參考呼叫 ( Call  By Reference )</li>
<li>補充：Call By Sharing</li>
</ul>
<h2 id="原始型別的傳值呼叫-call-by-value"><a class="header-anchor" href="#原始型別的傳值呼叫-call-by-value"></a>原始型別的傳值呼叫 ( Call  By Value )</h2>
<p>原始型別的記憶體位置是透過「傳值呼叫（ Call by Value ）」的方式來傳遞。那具體來說是怎麼運作呢？我們都知道變數在被宣告的時候，引擎會為我們預留記憶體空間（還記得什麼是「創造階段」嗎？忘記可以往前看），接著這個變數就會被赴值成為我們預期的變數內容。我們姑且稱一個被指派純值的變數為純值變數。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/201065803oQCVhZRB7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/201065803oQCVhZRB7.jpg"><br>
上面我們透過宣告，產生一個變數， <code>var a = 12</code> ，接著再把 <code>a</code> 指派給另外一個變數 <code>b</code> ，所以現在 <code>b</code> 的值應該與 <code>a</code> 相同。但是 JavaScript 引擎知道這是一個純值之後，就會幫我們另外創造記憶體空間，而就算我們修改 <code>b</code> 的內容，a 也不會受到影響，兩者之間是完全沒有關聯的。</p>
<pre><code> b = 21 

 console.log(a) //12
 console.log(b) //21
</code></pre>
<h2 id="物件型別的傳參考呼叫-call-by-reference"><a class="header-anchor" href="#物件型別的傳參考呼叫-call-by-reference"></a>物件型別的傳參考呼叫 ( Call  By Reference )</h2>
<p>當一個變數被賦予物件型別時候，這個物件實際上並非存在該變數裡面，而是被存在某個位置，既然是「位置」當然有地址，就稱為該物件存放的記憶體位置，而存在這個變數內的就是這個「記憶體位置」。因此這個「以記憶體位置為參考」而在變數間傳遞的存取行為，就稱為「傳參考呼叫」。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20106580OsgJIIjubY.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20106580OsgJIIjubY.jpg"></p>
<p>現在我們「傳值」所傳遞的是「數值的複製」，而「傳參考」所傳的則是「記憶體的參考位置（ 我要去哪裡找這個物件？ ）」。那傳參考呼叫跟剛開始提到的傳值，在行為上會有什麼不一樣呢？</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/201065800HcRlJdm9b.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/201065800HcRlJdm9b.jpg"></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20106580AHYSLGu03v.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20106580AHYSLGu03v.jpg"></p>
<p>當我們像剛才那樣新增了一個 <code>a</code> 物件變數，然後再把 <code>a</code> 的值傳給另外一個變數 <code>b</code> ，這時候有一個很重要的問題：「 <code>a</code> 裡面存的值是什麼？ 」還記得剛剛提到，是記憶體位置嗎？所以我傳給 <code>b</code>的時候，傳的正是記憶體位置。 因此如果後面我修改了 <code>b</code> 內容的值， <code>a</code>  理所當然的也會被改變，因為他們指的，是同一個物件。</p>
<h2 id="補充：call-by-sharing"><a class="header-anchor" href="#補充：call-by-sharing"></a>補充：Call By Sharing</h2>
<p>如果你多讀幾篇文章，可能會發現有的文章會說「JavaScript 是 Call By Sharing 」。「 Call By Sharing 」這個詞因為定義曖昧，模糊不清的關係，並不被廣泛地使用。「Call By Sharing」也有「 Call By Object-Sharing 」之稱，看到這個詞有沒有覺得跟「 Call By Reference 」意義很像？事實上，還真的有點像，但這個詞的定義更模糊。什麼意思呢？我們先來看看一個與 function 有關的經典例子：</p>
<pre><code>let jediList = ['Anakin' , 'Luke' , 'Ahsoka'] 

function addFellow(list){
	list.push('Yoda') 
}

addFellow(jediList)

console.log('jediList',jediList)
</code></pre>
<p>我在這個裡面做了幾件事情：</p>
<ol>
<li>在全域宣告陣列以及一個函式</li>
<li>把這個陣列傳入函式裡面</li>
<li>修改這個函式被傳入的陣列</li>
<li>回到全域執行環境，發現剛剛宣告的陣列在函式執行後也一併被修改</li>
</ol>
<p>為什麼會這樣呢？這就要先提到函式的參數，其實在參數被傳遞進函式的時候，會重新創造一個變數，然後把參數的值丟進這個變數裡面。不過</p>
<p>因為 Call By Reference 傳參考的特性，如果傳入的值是物件，那麼雖然函式試圖創造新的變數與外部環境做區隔，但是指派給這個新變數的值仍然會是「記憶體位置」！因此在這個情況下，函式內對 argument 做的修改，是對傳入物件參考的修改，連帶也會影響到全域環境下的 list 陣列值。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20106580ianSvW0gQt.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20106580ianSvW0gQt.jpg"></p>
<p>上面是當傳入函式參數是物件型別的情況，但是如果這個參數是原始型別，那麼情況又不同了，還記得原始型別在不同變數之間傳遞時的行為是「傳值」嗎？也就是「數值的拷貝」，所以就不會有上述修改到物件參考的奇怪情況：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20106580rrkNDOLwsG.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20106580rrkNDOLwsG.jpg"></p>
<p>好，上面兩種情況正好運用到今天的兩個重點「傳值呼叫」與「傳參考呼叫」，我們回到剛剛的程式碼，現在，為了討論 Call By Sharing 與 Call By Reference 的差異，我稍微修改一下程式碼，你可以思考一下結果回有怎樣的不同：</p>
<pre><code>let jediList = ['Anakin' , 'Luke' , 'Ahsoka'] 

function addFellow(list){
	 //somebody bad wants to change the result.
   list = ['nobody']
}

addFellow(jediList)

console.log('jediList',jediList) // ['Anakin' , 'Luke' , 'Ahsoka'] 
</code></pre>
<p>如何？ 根據剛剛的原則，傳入參數是物件，那麼我對這個物件作修改，就會影響到全域環境傳進參數的陣列內容，所以最後 console 出來的結果就是 <code>['nobody']</code>  囉？並不是！答案是維持原來的 <code>['Anakin' , 'Luke' , 'Ahsoka']</code>   ，也就是說在函式內的修改並沒有影響到這個全域變數。</p>
<p>這裡有一個關鍵差別是在做 <code>list = ['nobody']</code> 的時候，是指派一個全新的陣列物件給 <code>list</code> 變數，JS 知道這點之後就會為這個變數創造一個新的記憶體空間，然後把新指派的陣列存進去，而不會直接修改到外部傳進來的變數，造成連帶影響，這個創造新空間的行為，其實有點像是 Call By Value。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20106580n5AOAxQnql.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20106580n5AOAxQnql.jpg"></p>
<blockquote>
<p>也就是說，雖然透過記憶體位置參考，函式內被傳入的參數，有能力影響 / 修改到外部環境傳進來的變數，但是已經被宣告的物件無論如何都不會因為對這個變數的修改而被消滅。</p>
</blockquote>
<p>在看完 wiki 以及數篇文章的說明後，我認為上面的描述就是 Call By Sharing 與 Call By Reference  最大的不同，我相信看到這裡的你應該已經能夠了解它與「記憶體位置」脫不了關係。而 Call By Sharing 則在 Call By Value 與 Call By Reference 兩者之間有著曖昧模糊的地位  -  已經不單純取決於型別，而端看你對變數操作的行為。</p>
<h2 id="結論"><a class="header-anchor" href="#結論"></a>結論</h2>
<p>今天我們了解了基本的 Call By Value 與 Call By Reference 兩種行為，兩者在 JS 環境內所發生的時間點，Call By Value 發生在當指派給變數的值是純值時，而 Call By Reference 則發生在物件型別。最後，我用一個函式的範例，針對一個比較特殊的名詞 Call By Sharing 做了解說。</p>
<p>你在別的語言可能也會看到以上這些名詞，甚至，在某些語言裡面相同的名詞的意義也完全不同（ 如 Call By Reference ) 。但那不重要，在這個篇幅內，我希望看到最後的你，能夠了解 JS 變數與記憶體的關係與運作方式就好。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-01-05T07:25:10.000Z">2020-01-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/IThome-鐵人賽30天/">IThome - 鐵人賽30天</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5 分鐘 閱讀文 (大約 760 個字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/01/05/iron30-11/">JS 原力覺醒 Day11 - Falsy / Truthy</a>
            
        </h1>
        <div class="content">
            <p>上一章節的強制轉型，在布林值轉換的部分有提到 Truthy 與 Falsy ，這個特性我們應該常常碰到，至於背後的運作邏輯如何，今天就讓我們來看看吧：</p>
<h2 id="outline"><a class="header-anchor" href="#outline"></a>Outline</h2>
<ul>
<li>使用布林值自動轉型的情境</li>
<li>Falsy</li>
<li>Truthy</li>
<li>嚴格比較與寬鬆比較</li>
</ul>
<h2 id="布林值自動轉型的情境"><a class="header-anchor" href="#布林值自動轉型的情境"></a>布林值自動轉型的情境</h2>
<p>再有多重條件的情況下，那我們寫程式的時候常常用到這樣子的寫法：</p>
<pre><code>if(isTrue) {
	// if isTrue is equal to true 
} else {
	isTrue) {
	// if isTrue is equal to false
} 

while(isTrue){
	// if isTrue is equal to true 
} 

isTrue ? true : false 
</code></pre>
<p>邏輯判斷是大概是 JS 裡面最常用到的語法了，而因為 JS 是這個寬鬆靈活的語言，甚至我們寫在判斷式括號內的數值都不一定要是布林值，也可以是物件或字串。因為裡面的值會被 JS 自動轉型，這有點像是用兩個等號來做的寬鬆比較：</p>
<pre><code>if(isTrue) 
//is like 
isTrue == true 
</code></pre>
<p>至於邏輯區塊裡面的數值是依照怎麼樣的規則被轉型成為布林值，那就是我們需要探討的部分。</p>
<h2 id="falsy"><a class="header-anchor" href="#falsy"></a>Falsy</h2>
<p>在 JavaScript 裡面，每個數值都有其對應的布林值，也因而形成了接下來要提到的轉型邏輯，其在轉型的情況下，ㄧ定會被判斷為 <code>false</code> ，也就是說，與 <code>false</code> 等價，讓我們先來認識一下：</p>
<ul>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>''</code> (空字串)</li>
<li><code>false</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ul>
<h2 id="truthy"><a class="header-anchor" href="#truthy"></a>Truthy</h2>
<p>至於 truthy ，情況就比較多了，到底有多多呢？可以用一句話來解釋：「 除了 falsy 以外的值都是 truthy 」，也就是說只要知道上面 falsy 的值有哪些，就可以知道 truthy 的值有哪些囉！ 下面都是 truthy 的狀況：</p>
<ul>
<li><code>'0'</code> ( 一個內容為 0 的字串 )</li>
<li><code>'false'</code> ( 一個內容為 false 的字串 )</li>
<li><code>[]</code> ( 空陣列 )</li>
<li><code>{}</code> (空物件)</li>
<li><code>function(){}</code> (空函式)</li>
</ul>
<h2 id="嚴格比較與寬鬆比較"><a class="header-anchor" href="#嚴格比較與寬鬆比較"></a>嚴格比較與寬鬆比較</h2>
<p>上一章節為什麼說要盡量使用全等於，這邊說明一下，因為使用兩個等號 <code>==</code> 來比較的時候會觸發自動轉型，而其中就會有比較複雜的轉型邏輯，所以你會比較難以判斷比較的結果。我的建議是，盡量在你需要比較某數值的時候使用全等於（<code>===</code>），也就是嚴格比較，而只在需要判斷某物件是否存在時，才依賴自動轉型。 附上使用兩種判斷方式，分別會產生的結果值，你就會知道為什麼 (圖片來自這個 <a href="https://dorey.github.io/JavaScript-Equality-Table/">Repo</a>)：</p>
<ul>
<li>==</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20106580dRJICx6KM2.png" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20106580dRJICx6KM2.png"></p>
<ul>
<li>
<p>===</p>
<p>可以看出如果使用全等於，除非等號兩邊的數值完全相同，不然不可能得到 true</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20106580RfSTvPvXGp.png" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20106580RfSTvPvXGp.png"></p>
</li>
</ul>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/tags/frontend-force/page/0/">上一頁</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/tags/frontend-force/page/2/">下一頁</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/tags/frontend-force/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/tags/frontend-force/page/2/">2</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-4-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="/images/avatar.png" alt="Mujing Tsai">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Mujing Tsai
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        -
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Taipei, Taiwan</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            64
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分類
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            9
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        標籤
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            18
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://www.facebook.com/mujing" target="_blank" rel="noopener">
                追蹤</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Github" href="https://github.com/moojing">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Facebook" href="https://www.facebook.com/mujing">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Twitter" href="https://www.linkedin.com/in/mu-jing-tsai/">
                
                <i class="fab fa-linkedin"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            連結
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://ithelp.ithome.com.tw/users/20106580/ironman/2503" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">11th鐵人賽</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">ithelp.ithome.com.tw</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分類
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Canvas/">
            <span class="level-start">
                <span class="level-item">Canvas</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/FullStack/">
            <span class="level-start">
                <span class="level-item">FullStack</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/IThome-鐵人賽30天/">
            <span class="level-start">
                <span class="level-item">IThome - 鐵人賽30天</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">30</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Javascript/">
            <span class="level-start">
                <span class="level-item">Javascript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/TypeScript/">
            <span class="level-start">
                <span class="level-item">TypeScript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Webpack/">
            <span class="level-start">
                <span class="level-item">Webpack</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/devOps/">
            <span class="level-start">
                <span class="level-item">devOps</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/w3HexSchool-2020-年度鐵人賽/">
            <span class="level-start">
                <span class="level-item">w3HexSchool 2020 年度鐵人賽</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/走在漫漫長路-工作心得/">
            <span class="level-start">
                <span class="level-item">走在漫漫長路 - 工作心得</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            彙整
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2021/04/">
                <span class="level-start">
                    <span class="level-item">四月 2021</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/09/">
                <span class="level-start">
                    <span class="level-item">九月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/03/">
                <span class="level-start">
                    <span class="level-item">三月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">二月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/01/">
                <span class="level-start">
                    <span class="level-item">一月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">30</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/05/">
                <span class="level-start">
                    <span class="level-item">五月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/04/">
                <span class="level-start">
                    <span class="level-item">四月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">三月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">二月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">17</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            標籤雲
        </h3>
        <a href="/tags/backend/" style="font-size: 15.71px;">backend</a> <a href="/tags/canvas/" style="font-size: 10px;">canvas</a> <a href="/tags/devOps/" style="font-size: 11.43px;">devOps</a> <a href="/tags/frontend/" style="font-size: 20px;">frontend</a> <a href="/tags/frontend-force/" style="font-size: 17.14px;">frontend-force</a> <a href="/tags/ironman30/" style="font-size: 17.14px;">ironman30</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/rails/" style="font-size: 15.71px;">rails</a> <a href="/tags/ruby/" style="font-size: 15.71px;">ruby</a> <a href="/tags/ruby-on-rails/" style="font-size: 15.71px;">ruby on rails</a> <a href="/tags/typeScript/" style="font-size: 11.43px;">typeScript</a> <a href="/tags/typescript/" style="font-size: 12.86px;">typescript</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/vue-js/" style="font-size: 10px;">vue.js</a> <a href="/tags/w3HexSchool/" style="font-size: 14.29px;">w3HexSchool</a> <a href="/tags/working/" style="font-size: 11.43px;">working</a> <a href="/tags/地下城/" style="font-size: 14.29px;">地下城</a> <a href="/tags/鐵人賽30天/" style="font-size: 17.14px;">鐵人賽30天</a>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2021/04/03/react-compound-component/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="react-compound-component">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2021-04-03T10:14:38.000Z">2021-04-03</time></div>
                    <a href="/2021/04/03/react-compound-component/" class="title has-link-black-ter is-size-6 has-text-weight-normal">react-compound-component</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Javascript/">Javascript</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/09/06/working-reward/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/thumbnails/reward-cover.JPG" alt="每個衝擊都是一次學習的機會 - 近期的一點心得">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-09-06T09:36:53.000Z">2020-09-06</time></div>
                    <a href="/2020/09/06/working-reward/" class="title has-link-black-ter is-size-6 has-text-weight-normal">每個衝擊都是一次學習的機會 - 近期的一點心得</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/走在漫漫長路-工作心得/">走在漫漫長路 - 工作心得</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/09/working-environment/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/thumbnails/work-life.jpg" alt="寫給職場工作者：工作環境是否會影響一個人的思考方式？">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-08T20:54:46.000Z">2020-03-09</time></div>
                    <a href="/2020/03/09/working-environment/" class="title has-link-black-ter is-size-6 has-text-weight-normal">寫給職場工作者：工作環境是否會影響一個人的思考方式？</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/走在漫漫長路-工作心得/">走在漫漫長路 - 工作心得</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/07/web-dnd-2/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/thumbnails/DragnDrop.jpg" alt="就是要一起拖拖拉拉！(二) - 利用 DataTransfer API 實作拖拉元素間的資料傳遞">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-07T08:39:14.000Z">2020-03-07</time></div>
                    <a href="/2020/03/07/web-dnd-2/" class="title has-link-black-ter is-size-6 has-text-weight-normal">就是要一起拖拖拉拉！(二) - 利用 DataTransfer API 實作拖拉元素間的資料傳遞</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/02/28/web-dnd-1/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/thumbnails/DragnDrop.jpg" alt="就是要一起拖拖拉拉！(一) - 瀏覽器 Drag and Drop API 操作">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-28T02:04:03.000Z">2020-02-28</time></div>
                    <a href="/2020/02/28/web-dnd-1/" class="title has-link-black-ter is-size-6 has-text-weight-normal">就是要一起拖拖拉拉！(一) - 瀏覽器 Drag and Drop API 操作</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/w3HexSchool-2020-年度鐵人賽/">w3HexSchool 2020 年度鐵人賽</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                標籤
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/backend/">
                        <span class="tag">backend</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/canvas/">
                        <span class="tag">canvas</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/devOps/">
                        <span class="tag">devOps</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/frontend/">
                        <span class="tag">frontend</span>
                        <span class="tag is-grey">62</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/frontend-force/">
                        <span class="tag">frontend-force</span>
                        <span class="tag is-grey">30</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ironman30/">
                        <span class="tag">ironman30</span>
                        <span class="tag is-grey">30</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/javascript/">
                        <span class="tag">javascript</span>
                        <span class="tag is-grey">56</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/rails/">
                        <span class="tag">rails</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ruby/">
                        <span class="tag">ruby</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ruby-on-rails/">
                        <span class="tag">ruby on rails</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/typeScript/">
                        <span class="tag">typeScript</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/typescript/">
                        <span class="tag">typescript</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/vue/">
                        <span class="tag">vue</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/vue-js/">
                        <span class="tag">vue.js</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/w3HexSchool/">
                        <span class="tag">w3HexSchool</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/working/">
                        <span class="tag">working</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/地下城/">
                        <span class="tag">地下城</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/鐵人賽30天/">
                        <span class="tag">鐵人賽30天</span>
                        <span class="tag is-grey">30</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="Moojing&#39;s Blog" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2021
                 <!-- Moojing&nbsp; -->
                
                <!-- Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> -->
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-TW");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://www.muji.dev',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到頁首" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="請輸入關鍵字..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '頁面',
                CATEGORIES: '分類',
                TAGS: '標籤',
                UNTITLED: '(無標題)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>